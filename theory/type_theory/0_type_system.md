# 0 type system

- [0 type system](#0-type-system)
    - [타입 시스템의 기본 원리](#타입-시스템의-기본-원리)
        - [타입 검사](#타입-검사)
        - [타입 안정성](#타입-안정성)
        - [타입 추론](#타입-추론)
        - [타입 폴리모피즘](#타입-폴리모피즘)
        - [실용적 예시](#실용적-예시)
    - [정적 vs 동적 타입 시스템](#정적-vs-동적-타입-시스템)
    - [기본 개념](#기본-개념)
        - [타입 이론의 실제 적용](#타입-이론의-실제-적용)
        - [고급 주제](#고급-주제)
    - [Abstract Syntax Trees (AST)](#abstract-syntax-trees-ast)
        - [치환(Substitution)](#치환substitution)
        - [구조적 귀납법(Structural Induction)](#구조적-귀납법structural-induction)
        - [변수와 치환](#변수와-치환)
        - [연산자와 표현](#연산자와-표현)
        - [정의와 규칙](#정의와-규칙)
    - [정리 1.1](#정리-11)
        - [수식의 의미](#수식의-의미)
            - [1. `[b/x]x=b` and `[b/x]y=y` if `x ≠ y`](#1-bxxb-and-bxyy-if-x--y)
            - [2. `[b/x]o(a1;...;an)=o([b/x]a1;...;[b/x]an)`](#2-bxoa1anobxa1bxan)
        - [적용 예](#적용-예)
        - [정리 1.1의 의미](#정리-11의-의미)
        - [증명 방법](#증명-방법)
        - [Go 코드에서 AST의 사용 예](#go-코드에서-ast의-사용-예)
        - [치환의 예](#치환의-예)
        - [실제 개발에서의 적용](#실제-개발에서의-적용)

## 타입 시스템의 기본 원리

타입 시스템은 프로그래밍 언어의 변수, 표현식, 함수 등을 분류하고 타입 안정성을 제공하는 체계입니다.
타입 시스템은 코드의 안정성을 높이고, 오류를 사전에 방지하는 데 중요한 역할을 합니다.

### 타입 검사

타입 시스템은 변수나 표현식의 타입을 검사하여, 그 타입에 적합한 연산과 상호작용이 이루어지도록 합니다. 예를 들어, 숫자형 변수에 문자열을 더하는 것은 타입 오류를 일으키며, 이는 대부분의 정적 타입 시스템에서 컴파일 시간에 검출됩니다.

### 타입 안정성

타입 안정성이란 프로그램이 실행되는 동안 타입 관련 오류가 발생하지 않음을 보장하는 성질을 말합니다. 타입 안정성이 높은 언어는 런타임 오류의 가능성을 크게 줄여 줍니다. 타입 안정성은 개발자가 의도치 않은 타입 오류로부터 자유롭게 코드를 작성할 수 있도록 도와줍니다.

- **TypeScript 예제** (타입스크립트는 자바스크립트에 타입 안정성을 추가):

```typescript
// 타입스크립트에서 정적 타입 체크를 통해 발생할 수 있는 오류를 컴파일 시간에 잡아내는 것을 보여 줍니다.

function greet(name: string) {
    console.log("Hello, " + name);
}

greet("Alice");
greet(42);  // 오류: Argument of type 'number' is not assignable to parameter of type 'string'.
```

### 타입 추론

모던 프로그래밍 언어에서는 타입 추론을 지원하여, 개발자가 모든 변수에 타입을 명시하지 않아도 컴파일러가 자동으로 타입을 유추할 수 있습니다. 이는 코드의 가독성을 향상시키고, 개발 과정을 간소화합니다. 예를 들어, Haskell이나 Scala 같은 언어는 매우 강력한 타입 추론 기능을 제공합니다.

### 타입 폴리모피즘

타입 폴리모피즘은 다양한 타입에서 작동할 수 있는 함수를 정의할 수 있게 해 줍니다. 가장 흔한 형태는 제네릭 프로그래밍으로, 하나의 함수나 자료구조가 다양한 타입에 대해 재사용될 수 있습니다. 예를 들어, Java에서 `List<T>`는 어떠한 타입 `T`의 요소를 담는 리스트를 의미합니다.

### 실용적 예시

```java
// Java에서의 타입 시스템 예시
public class TypeSystemExample {
    public static int addNumbers(int a, int b) {
        return a + b;
    }

    public static void main(String[] args) {
        int result = addNumbers(5, 10); // 올바른 타입 사용
        System.out.println(result); // 출력: 15

        // int error = addNumbers("Hello", "World"); // 컴파일 오류: 타입 불일치
    }
}
```

이 예시에서 `addNumbers` 함수는 정수 타입의 매개변수를 요구합니다. 정수를 올바르게 전달하면 함수가 예상대로 작동하지만, 문자열을 전달하려고 하면 컴파일 시 타입 오류가 발생합니다. 이처럼 타입 시스템은 개발자가 코드의 오류를 미리 예방할 수 있도록 도와줍니다.

타입 시스템에 대한 이러한 이해는 소프트웨어 개발에서 버그를 줄이고, 유지 보수를 용이하게 하는 데 큰 도움을 줍니다. 이러한 이론적 배경과 실제 예시를 통해 타입 시스템의 중요성과 기능을 보다 깊이 있게 이해할 수 있습니다.

## 정적 vs 동적 타입 시스템

- **이론**: 정적 타입 시스템은 변수의 타입이 컴파일 시 결정되며, 한 번 선언된 타입은 변경되지 않습니다. 반면 동적 타입 시스템은 런타임에 타입이 결정되어 더 큰 유연성을 제공합니다.
- **실습 예제**:
    - **Python 예제** (동적 타입 시스템):

    ```python
    def add(a, b):
        return a + b

    print(add(5, 10))  // 15
    print(add("Hello, ", "world!"))  // Hello, world!
    ```

    - 이 예제는 동적 타입 시스템에서 같은 함수가 다른 타입의 인자를 받아 처리하는 유연성을 보여 줍니다.

## 기본 개념

1. **타입 시스템(Type Systems)**:
   - **타입의 정의**: 타입은 값의 집합과 그 값들에 적용할 수 있는 연산들을 정의합니다. 예를 들어, 정수 타입은 더하기나 빼기 같은 연산을 할 수 있는 모든 정수의 집합입니다.
   - **타입 검사(Type Checking)**: 프로그램이 타입 규칙을 준수하는지 확인하는 과정입니다. 이는 컴파일 시간에 주로 수행되어 실행 시간의 오류를 방지할 수 있습니다 .

2. **함수형 프로그래밍(Functional Programming)**:
   - **불변성(Immutability)**: 데이터가 생성된 후 변경될 수 없는 성질을 의미합니다. 이는 프로그램의 예측 가능성과 재입력성을 향상시킵니다.
   - **일급 함수(First-Class Functions)**: 함수를 일반 데이터처럼 변수에 저장하거나 다른 함수의 인자로 전달할 수 있음을 의미합니다 .

3. **대수적 타입(Algebraic Types)**:
   - **합 타입(Sum Types)**: 두 타입 중 하나의 값을 가질 수 있는 타입으로, 예를 들어 'Either' 타입은 두 가지 가능한 타입 중 하나의 값을 담을 수 있습니다.
   - **곱 타입(Product Types)**: 두 타입의 값을 모두 갖는 타입으로, 튜플이 이에 해당합니다 .

### 타입 이론의 실제 적용

- **API 설계**: 타입 시스템은 API의 각 함수에서 기대하는 입력과 반환을 명확하게 함으로써, API 사용자가 올바른 사용 방법을 쉽게 이해할 수 있도록 도와줍니다.
- **안전성 보장**: 강력한 타입 시스템을 사용함으로써, 프로그램이 더 안전하게 실행될 수 있도록 도와주며, 실행 시간에 발생할 수 있는 많은 오류들을 컴파일 시간에 잡아낼 수 있습니다.

### 고급 주제

- **모나드(Monads)**와 **함자(Functors)**: 함수형 프로그래밍에서 사용되는 추상적 개념들로, 사이드 이펙트를 관리하고, 함수 간의 데이터 흐름을 추상화하는 데 도움을 줍니다 .

## Abstract Syntax Trees (AST)

- **AST (추상 구문 트리)**: 변수가 잎(leaves)이고 내부 노드가 연산자인 정렬된 트리입니다. 각 연산자는 자식 노드를 인수로 사용합니다.
    - **잎(Leaf) 노드**는 변수를 나타냅니다.
    - **내부 노드**는 연산자를 나타내며, 그 자식 노드들이 연산자의 인자가 됩니다.
- **변수와 연산자**: 변수는 지정된 유형의 일반적인 구문을 나타내며, 연산자는 정해진 유형과 인자의 수(arity)를 가집니다. 연산자는 n개의 AST를 결합하여 복합 AST를 형성합니다.

AST는 다양한 '종류'의 구문 형태에 따라 분류됩니다. 연산자는 종류와 인자의 수(arity, 아리티)를 갖는데, 이는 연산자가 받을 수 있는 인자의 수와 종류를 정의합니다. 연산자는 n개의 AST를 결합하여 복합 AST를 형성합니다.

- AST의 기본 개념

    AST는 프로그래밍 언어의 문법을 나타내기 위해 사용되며, 각 노드는 연산자나 변수를 나타냅니다.

- 치환

    변수에 구체적인 값이나 다른 AST를 할당함으로써 수행되며, 이 과정을 통해 프로그램의 의미가 결정됩니다.

- 구조적 귀납법

    AST의 속성을 증명하는 데 필수적인 방법으로, 모든 가능한 경우를 체계적으로 검토하여 전체적인 속성을 입증합니다.

이러한 이론은 프로그래밍 언어의 설계와 구현, 그리고 코드 최적화에 중요한 역할을 합니다.

### 치환(Substitution)

- **치환의 정의**: 변수의 의미는 치환을 통해 부여됩니다. 치환은 변수가 포함된 수식에서 변수를 특정 값으로 대체하는 과정입니다.
- **치환의 예**: 수식 `2 + (3 × x)`에서 변수 `x`의 위치에 숫자 `4`를 치환하면 `2 + (3 × 4)`가 됩니다. 이는 수식에서 `x`를 `num[4]`로 치환한 결과입니다.

### 구조적 귀납법(Structural Induction)

- **구조적 귀납법**: AST의 모든 가능한 구성에 대해 주어진 속성이 성립함을 증명하는 방법입니다. AST가 생성될 수 있는 모든 방식을 고려하여 각 경우에 대해 속성이 성립함을 보이면 전체적으로 속성이 성립한다고 결론지을 수 있습니다. 이 방법을 사용하여, 변수나 수, 그리고 복합 표현에 대해 속성이 유효함을 단계적으로 보일 수 있습니다.
- **귀납법 적용 예**: 연산자 `plus`와 `times`에 대해 특정 속성 `P`가 성립한다면, `plus(a1; a2)`와 `times(a1; a2)`에 대해서도 속성 `P`가 성립해야 합니다.

### 변수와 치환

변수는 어떤 지정된 종류의 구문을 대표하지만, 구체적인 내용은 정해지지 않은 '일반적인' 구문 조각입니다. **치환(Substitution)**은 수학에서와 마찬가지로, 특정 변수에 구체적인 값을 할당하여 수식의 의미를 구체화하는 과정입니다. 예를 들어, 다항식에서 `x` 대신 π(파이)를 대입하여 계산하는 것과 유사하게, 프로그래밍에서는 변수 위치에 적절한 AST를 대입하여 새로운 AST를 생성합니다.

### 연산자와 표현

연산자는 특정 '종류'와 인자의 수에 따라 정의됩니다. 예를 들어:
- **nullary operator (0항 연산자)**: 인자가 없는 연산자입니다.
- **unary operator (1항 연산자)**: 하나의 인자를 가집니다.
- **binary operator (2항 연산자)**: 두 개의 인자를 가집니다.

이런 연산자들을 사용하여 복잡한 표현을 구성할 수 있습니다. 예를 들어, `2 + (3 × x)`라는 표현은 `plus`와 `times`라는 두 개의 이항 연산자를 사용하여 구성됩니다.

### 정의와 규칙

- **변수 집합**과 **연산자 집합**을 정의하여, 이들을 조합하여 AST를 구성합니다.
- 각 변수는 특정 '종류'에 속하며, 연산자는 정해진 아리티에 따라 특정 수와 종류의 인자를 받아 새로운 AST를 생성합니다.

## 정리 1.1

이 내용은 추상 구문 트리(AST)에서의 변수 치환 및 그 결과를 정의하고 증명하는 방법에 관한 것입니다. 아래 각 수식과 정리는 치환의 정의 및 그 효과를 명확히 하고, 구조적 귀납법을 사용하여 이러한 치환 과정이 잘 정의되어 있다는 것을 증명합니다.

### 수식의 의미

아래 두 수식은 프로그래밍에서 추상 구문 트리(AST)를 활용한 변수의 치환(substitution) 과정을 정의합니다.
이 과정은 특정 변수를 다른 표현식이나 변수로 대체하는 것을 포함하며, 코드 변환 또는 리팩토링 시에 자주 사용됩니다.

#### 1. `[b/x]x=b` and `[b/x]y=y` if `x ≠ y`

이 수식은 변수 치환의 가장 기본적인 형태를 나타냅니다. 특정 변수 x를 b로 치환할 때, x는 b로 대체되고, 다른 모든 변수는 변경되지 않습니다. 이는 치환의 "정확성"과 "최소한의 변경" 원칙을 수학적으로 보장하기 위해 필요합니다.

이 수식은 두 부분으로 구성되어 있습니다:
- **\[b/x\]x = b**: 이 부분은 변수 `x`를 표현식 `b`로 치환할 때, `x`는 `b`로 대체된다는 것을 의미합니다. 즉, `x` 자리에 `b`가 들어가게 됩니다.
- **\[b/x\]y = y if x ≠ y**: 이 부분은 다른 변수 `y` (여기서 `y`는 `x`와 다른 변수임)에 대한 치환을 설명합니다. `x`와 다른 변수 `y`는 치환 과정에서 변경되지 않고 그대로 유지된다는 것을 의미합니다. 즉, `x`가 아닌 다른 변수에는 영향을 미치지 않습니다.

#### 2. `[b/x]o(a1;...;an)=o([b/x]a1;...;[b/x]an)`

복합 표현식에서 각 요소에 대한 치환을 독립적으로 적용한 후 전체 구조를 재조합하는 방식입니다.
이는 프로그램의 구조적 특성을 보존하면서 치환을 적용하는 것이 중요하기 때문에 도입됩니다.

- `[b/x]`

    이 표현은 "변수 x를 b로 치환"하는 작업을 나타냅니다.
    이것은 일종의 연산자로서, 주어진 표현식이나 함수 내에서 모든 x를 b로 대체하는 치환을 표현하기 위해 사용됩니다.

- `(a1;...;an)`

    이 표현은 일련의 인자들, 또는 표현식들을 나열할 때 사용됩니다.
    `;`는 각각의 요소를 구분하는 구분자로 사용되며, 여러 개의 인자나 표현식을 나타내는 데 쓰입니다.
    이는 특히 함수나 연산자가 여러 인자를 받을 때 사용됩니다.

- `[b/x]o(a1;...;an)`

    이 수식은 연산자 `o`가 적용된 복합 표현식에 치환을 적용할 경우, 각각의 인자 `a1, ..., an`에 대해 동일한 치환을 적용하고, 그 결과를 다시 `o`에 적용하여 최종 결과를 얻는 과정을 설명합니다.

    이 전체 표현은 "연산자 `o`가 적용된 표현식 `o(a1, ..., an)`에서 모든 `x`를 `b`로 치환하라"는 의미를 갖습니다.
    - `o`는 어떤 연산자(예: 함수, 수학적 연산 등)
    - `a1;...;an`은 그 연산자의 인자들을 나타냅니다.

    치환 작업은 각 인자에 대해 독립적으로 수행된 후, 변환된 인자들을 다시 연산자 o에 적용하여 최종 결과를 구성합니다.

    예를 들어, `plus(x; num[3])`에서 `x`를 `num[2]`로 치환하면 `plus(num[2]; num[3])`이 됩니다.

- **\[b/x\]o(a1;...;an)**

    연산자 `o`가 적용된 표현식에 대해 치환을 수행할 때, 전체 표현식에 대한 치환 결과는 연산자 `o`와  각각의 인자 `a1, ..., an`에 대한 치환 결과의 조합으로 나타납니다.

- **o(\[b/x\]a1;...;\[b/x\]an)**

    각 인자 `a1, ..., an`에 대해서 독립적으로 치환을 수행한 후, 그 결과를 다시 연산자 `o`에 적용합니다.
    이는 재귀적으로 각 인자에 대한 치환을 수행하고, 최종적으로 치환된 인자들을 이용해 새로운 표현식을 구성함을 의미합니다.

### 적용 예

예를 들어, 표현식 `plus(x, 3)`에서 `x`를 `5`로 치환하려는 경우:
- **\[5/x\]plus(x, 3) = plus(\[5/x\]x, \[5/x\]3)**
- **= plus(5, 3)**

여기서 `plus([5/x]x, [5/x]3)`이 `plus(5, 3)`이 되는 이유는 다음과 같습니다:

1. **치환 과정**

    `[5/x]x`는 `x`를 `5`로 치환한다는 의미입니다. 따라서 `[5/x]x`는 `5`가 됩니다.

2. **상수에 대한 치환**

    `[5/x]3`는 숫자 `3`에 대해 어떠한 치환도 적용되지 않습니다.
    왜냐하면 `3`은 `x`와 관련이 없기 때문에, `3` 자체가 그대로 유지됩니다.
    치환 연산자는 주어진 변수(`x`)에만 적용되고, 다른 변수나 상수에는 영향을 미치지 않습니다.

따라서, `plus([5/x]x, [5/x]3)`는 `plus(5, 3)`으로 계산되며, 여기서 `15`가 되지 않는 이유는 `3`이 치환의 대상이 아니기 때문입니다. `plus(5, 15)`가 되려면, `3`을 무언가로 치환하거나, `plus` 함수 자체가 `x`와 `3`의 곱셈으로 정의되어야 합니다. 그러나 기본적으로 `plus`는 입력된 두 인자를 단순히 더하는 함수로 가정합니다.

이 예시는 함수의 인자에 대해 치환을 적용할 때, 오직 지정된 변수에만 치환을 적용하고 그 외에는 원래 값을 유지함을 보여줍니다. 이러한 방식으로 프로그래밍에서 함수의 동작과 변수 치환의 영향을 명확히 이해할 수 있습니다.

이처럼, 복잡한 표현식에서도 변수의 치환을 체계적으로 적용할 수 있으며, 이는 코드에서 특정 변수의 값을 변경하거나, 더 복잡한 코드 리팩토링 작업을 수행할 때 유용하게 활용됩니다.

### 정리 1.1의 의미

- **정리 1.1**

    만약 `a`가 `A[X, x]`에 속한다면,
    모든 `b`가 `A[X]`에 속할 때,
    유일한 `c`가 `A[X]`에 존재하여 \[b/x\]a = c가 된다

- 이 정리는 모든 `a`에 대해 `b`를 `x`에 대한 치환으로 적용하면, 결과로서 유일한 `c`가 존재한다는 것을 주장합니다. 즉, 치환 연산은 일관되고 예측 가능한 결과를 제공합니다.

### 증명 방법

**증명**: 구조적 귀납법을 사용하여 `a`의 모든 가능한 형태에 대해 치환의 결과가 유일하게 결정되는 것을 보입니다:
- **기본 경우**:
    - `a = x`인 경우, \[b/x\]x는 정의에 의해 `b`입니다. 따라서 `c = b`.
    - `a = y`이고 `y ≠ x`인 경우, \[b/x\]y는 `y`입니다. 따라서 `c = y`.
- **귀납적 경우**:
    - `a`가 `o(a1, ..., an)` 형태인 경우, 각 `ai`에 대해 치환 \[b/x\]ai의 결과가 `ci`라고 가정합니다 (귀납 가정). 그러면 \[b/x\]o(a1, ..., an) = o(\[b/x\]a1, ..., \[b/x\]an) = o(c1, ..., cn)이고, 따라서 `c = o(c1, ..., cn)`입니다.

이 증명은 치환 작업이 모든 형태의 AST에 대해 잘 정의되고, 예상대로 작동함을 보장합니다. 따라서, 어떤 AST 구조에도 일관된 방식으로 변수를 치환할 수 있으며, 그 결과는 항상 유일하게 결정됩니다.

### Go 코드에서 AST의 사용 예

추상 구문 트리(AST)의 개념과 치환은 실제 프로그래밍 언어와 코드 분석에서 매우 중요합니다.
Go에서 AST는 주로 소스 코드의 구조를 분석하거나 수정할 때 사용됩니다.
예를 들어, 코드 리팩토링, 스타일 가이드 검사, 또는 코드의 새로운 버전으로의 마이그레이션 등에 활용됩니다.

1. **소스 코드 분석**:
   - Go 코드를 파싱하여 AST를 생성하고, 이 트리를 통해 특정 함수 호출을 검사하거나 변수 사용의 유효성을 체크할 수 있습니다.

2. **코드 리팩토링**:
   - 함수의 인자를 변경하거나, 새로운 로직을 추가하고, 기존 코드를 재구성할 때 AST를 수정하여 이를 수행할 수 있습니다.

### 치환의 예

Go 코드에서 변수 `x`가 있다고 가정해 보겠습니다. 이 변수에 대한 모든 인스턴스를 다른 변수명 `y`로 치환하고자 할 때, 이 과정을 코드로 구현하면 다음과 같습니다.

```go
package main

import (
    "go/ast"
    "go/parser"
    "go/token"
    "strings"
)

func main() {
    src := `
package main
import "fmt"
func main() {
    x := 10
    fmt.Println(x)
}
`
    // 소스 코드를 파싱하여 AST 생성
    fset := token.NewFileSet()
    node, err := parser.ParseFile(fset, "", src, parser.ParseComments)
    if err != nil {
        panic(err)
    }

    // 치환: 'x'를 'y'로 변경
    ast.Inspect(node, func(n ast.Node) bool {
        if ident, ok := n.(*ast.Ident); ok && ident.Name == "x" {
            ident.Name = "y"
        }
        return true
    })

    // 수정된 AST를 기반으로 소스 코드 출력
    ast.Print(fset, node)
}
```

위 코드는 Go의 `ast` 및 `parser` 패키지를 사용하여 소스 코드 문자열에서 `x`라는 변수를 `y`로 치환합니다.
이 과정은 AST의 노드를 순회하면서 변수 이름이 `x`인 모든 식별자 노드(`Ident`)의 이름을 `y`로 변경하는 방식으로 이루어집니다.

### 실제 개발에서의 적용

이와 같은 AST의 생성과 치환 기법은 실제 개발에서 다음과 같은 상황에서 유용하게 사용됩니다:

- **자동 코드 수정**: 레거시 코드의 특정 API 호출을 새로운 것으로 대체하거나, 코드의 스타일을 새로운 팀 규칙에 맞게 자동으로 수정할 때 유용합니다.
- **코드 분석**: 코드의 복잡성을 평가하거나, 특정 코드 패턴을 찾아내기 위해 사용됩니다.
- **보안 검사**: 취약한 코드 패턴을 찾아내고 수정하는 데 도움을 줍니다.
