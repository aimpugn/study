# options

- [options](#options)
    - [jvm 메모리, GC 빈도를 VisualVM으로 모니터링](#jvm-메모리-gc-빈도를-visualvm으로-모니터링)
    - [옵션의 의미와 종류](#옵션의-의미와-종류)
        - [표준 옵션 (Standard Options)](#표준-옵션-standard-options)
        - [`-X` 옵션 (Non-standard Options)](#-x-옵션-non-standard-options)
        - [`-XX`: 옵션 (Advanced Options)](#-xx-옵션-advanced-options)
    - [`sun.io.useCanonCaches`](#suniousecanoncaches)
        - [정규화 캐시의 역할](#정규화-캐시의-역할)
        - [캐시 사용의 잠재적 문제](#캐시-사용의-잠재적-문제)
        - [권장 사항](#권장-사항)
    - [`-XX:+AlwaysPreTouch`](#-xxalwayspretouch)
    - [`-XX:+UnlockExperimentalVMOptions`](#-xxunlockexperimentalvmoptions)
    - [`-XX:+UseCGroupMemoryLimitForHeap`](#-xxusecgroupmemorylimitforheap)
    - [`-XX:+UseCompressedOops` 옵션](#-xxusecompressedoops-옵션)

## jvm 메모리, GC 빈도를 VisualVM으로 모니터링

```text
-Dcom.sun.management.jmxremote.port=8000 
-Dcom.sun.management.jmxremote.ssl=false 
-Dcom.sun.management.jmxremote.authenticate=false 
```

## 옵션의 의미와 종류

JVM 옵션은 Java 애플리케이션의 실행 환경을 조정하는 데 사용됩니다. JVM 옵션은 크게 세 가지 유형으로 나뉩니다:

1. **표준 옵션 (Standard Options)**: 모든 JVM 구현에서 지원되는 옵션
2. **-X 옵션**: 비표준 옵션으로, JVM 구현에 따라 다를 수 있음
3. **-XX 옵션**: 고급 옵션으로, JVM 내부 동작을 세밀하게 제어하는 데 사용됨

### 표준 옵션 (Standard Options)

1. **-cp 또는 -classpath**: 클래스 파일과 JAR 파일의 경로를 설정합니다.

   ```sh
   java -cp .:/path/to/jar MyClass
   ```

2. **-Dproperty=value**: 시스템 속성을 설정합니다.

   ```sh
   java -Dmy.property=value MyClass
   ```

### `-X` 옵션 (Non-standard Options)

1. **-Xms{SIZE}**: 초기 힙 메모리 크기를 설정합니다.

   ```sh
   java -Xms512m MyClass
   ```

2. **-Xmx{SIZE}**: 최대 힙 메모리 크기를 설정합니다.

   ```sh
   java -Xmx2g MyClass
   ```

3. **-Xss{SIZE}**: 각 스레드의 스택 크기를 설정합니다.

   ```sh
   java -Xss1m MyClass
   ```

### `-XX`: 옵션 (Advanced Options)

`-XX:`로 시작하는 옵션은 고급 옵션으로, JVM의 성능, 메모리 관리, GC 동작 등을 세밀하게 조정할 수 있습니다.
이러한 옵션은 주로 JVM 튜닝 및 디버깅에 사용됩니다.

1. **메모리 관리**
   - **-XX:MaxHeapSize=2g**: 힙 메모리의 최대 크기를 설정합니다.(여기서는 2G)
   - **-XX:MaxMetaspaceSize**: 메타스페이스의 최대 크기를 설정합니다.

2. **GC 옵션**
   - **-XX:+UseG1GC**: G1 Garbage Collector를 사용합니다.
   - **-XX:+UseConcMarkSweepGC**: Concurrent Mark-Sweep (CMS) GC를 사용합니다.

3. **디버깅 및 로깅**
   - **-XX:+PrintGC**: GC 이벤트를 로그에 출력합니다.
   - **-XX:+PrintGCDetails**: GC 이벤트에 대한 자세한 정보를 출력합니다.

4. **성능 최적화**
   - **-XX:+AggressiveOpts**: 최신 성능 향상 기능을 사용합니다.
   - **-XX:CompileThreshold**: 메서드가 JIT 컴파일되기 전에 호출되어야 하는 횟수를 설정합니다.
   - **-XX:+UseStringDeduplication**: 문자열 중복 제거 기능을 활성화합니다.
   - **-XX:+AlwaysPreTouch**: JVM 시작 시 힙 메모리를 미리 터치하여 초기화합니다.

이런 옵션은 다음과 같이 사용할 수 있습니다.

```sh
java -Xms512m -Xmx2g -XX:+UseG1GC -XX:+PrintGCDetails -jar myapp.jar
```

위의 예시는 다음과 같은 설정을 사용하여 JVM을 실행합니다:
- 초기 힙 메모리 크기를 512MB로 설정
- 최대 힙 메모리 크기를 2GB로 설정
- G1 Garbage Collector를 사용
- GC 이벤트에 대한 자세한 정보를 출력

## `sun.io.useCanonCaches`

- **파일 시스템의 정규화된(canonical) 경로를 캐싱**할지 여부를 결정하는 내부 시스템 속성

> 정규화된 경로란?
>
> 파일 시스템에서 실질적으로 같은 위치를 가리키는 여러 경로명 중 '표준' 형태의 경로명을 말한다
> 예를 들어, 심볼릭 링크나 `.`과 `..` 등이 포함된 경로명은 해당 파일이나 디렉토리의 정규화된 경로명으로 변환될 수 있다

### 정규화 캐시의 역할

- **정규화 캐시의 사용 이유**
    - 파일의 정규화된 경로를 계산하는 것은 비용이 많이 드는 연산일 수 있다. 특히 파일 시스템에서 심볼릭 링크를 많이 사용하거나 복잡한 구조를 가진 경우에 더 그렇다
    - 이 속성이 `true`로 설정되어 있으면, Java는 이러한 정규화 연산의 결과를 캐시하여, 같은 파일에 대한 후속 호출이 더 빠르게 수행될 수 있도록 한다
- **캐시 사용의 영향**
    - 정규화 캐시를 사용하면 파일 **I/O 작업의 성능이 향상**될 수 있습니다.
    - 특히 파일에 대해 반복적인 접근이 이루어지는 애플리케이션의 경우에 더욱 그렇다
    - 캐시를 사용하면 정규화된 경로의 계산을 한 번만 수행하고, 결과를 재사용하여 성능을 향상시킬 수 있다

### 캐시 사용의 잠재적 문제

- **캐시 무효화 문제**
    - 시스템의 파일 구조가 변경되면 캐시된 경로가 더 이상 유효하지 않을 수 있다.
    - 예를 들어, 심볼릭 링크가 변경되거나 삭제될 경우, 캐시된 경로는 실제 파일 시스템의 상태를 반영하지 않게 된다
    - 이러한 경우에는 캐시를 사용하지 않도록 설정하여, 항상 최신의 정확한 경로를 얻을 수 있도록 할 필요가 있다
- **보안 문제**
    - 정규화 캐시는 보안에 영향을 줄 수 있다
    - 예를 들어, 애플리케이션이 사용자의 파일 접근 권한을 확인할 때, 캐시된 경로가 사용되면 권한 변경이 반영되지 않을 수 있다

### 권장 사항

- `sun.io.useCanonCaches` 속성을 `false`로 설정하여 정규화 캐시를 비활성화하는 것이, 파일 시스템의 변경 사항을 즉각적으로 반영해야 하거나 보안이 중요한 애플리케이션에서는 권장된다
- 반면, 파일 시스템의 변경이 드물고 성능 최적화가 중요한 애플리케이션의 경우에는 `true`로 설정하여 캐시를 활성화할 수 있다

## `-XX:+AlwaysPreTouch`

기본적으로 JVM은 필요에 따라 메모리 페이지를 할당합니다.
`-XX:+AlwaysPreTouch` 옵션을 사용하면 JVM이 시작될 때 모든 메모리 페이지를 미리 초기화하여 터치합니다.
`-XX:+AlwaysPreTouch` 옵션은 JVM이 힙 메모리를 할당할 때 모든 페이지를 미리 터치하도록 설정합니다.
즉, JVM이 시작될 때 할당된 모든 메모리 페이지를 초기화하여 실제 물리 메모리에 맵핑합니다.
이는 메모리 할당을 빠르게 하지만, 초기 시작 시에 추가적인 CPU 자원을 사용합니다.

1. **초기화 시 CPU 사용 증가**:
   - JVM 시작 시 모든 메모리 페이지를 미리 터치하므로 CPU 사용이 증가합니다.
   - 메모리 할당이 더 빠르게 이루어지기 때문에 초기화 시간 동안 CPU 부하가 높아질 수 있습니다.

2. **런타임 성능 향상**:
   - 초기화 후에는 메모리 페이지가 이미 물리 메모리에 맵핑되어 있기 때문에, 런타임 동안의 페이지 폴트(page fault)를 줄여 성능을 향상시킬 수 있습니다.
   - 이는 특히 대규모 힙을 사용하는 애플리케이션에서 효과적입니다.

3. 사용 사례

    - **대규모 애플리케이션**: 대규모 힙 메모리를 사용하는 애플리케이션에서 초기 페이지 폴트를 줄여 성능을 향상시킬 수 있습니다.
    - **예측 가능한 성능 요구**: 예측 가능한 성능을 요구하는 시스템에서는 초기 CPU 사용량 증가를 감수하고 런타임 성능을 최적화할 수 있습니다.

## `-XX:+UnlockExperimentalVMOptions`

이 옵션은 JVM의 실험적인 기능을 활성화합니다. 실험적인 기능은 JVM 개발자들이 새로운 기능을 테스트하거나 성능을 최적화하기 위해 추가한 기능으로, 기본적으로는 비활성화되어 있습니다.
이는 테스트와 성능 튜닝에 유용하지만, 안정성 문제를 일으킬 수 있습니다.

- 작동 방식
    - **기능 활성화**: 이 옵션을 설정하면, 실험적인 기능을 사용할 수 있게 됩니다. 이는 다른 `-XX` 옵션들과 조합하여 사용됩니다.
    - **예시**: 특정 GC 알고리즘이나 성능 튜닝 옵션이 아직 공식적으로 지원되지 않는 경우, 이 옵션을 통해 사용할 수 있습니다.

- 영향을 미치는 부분
    - **안정성**: 실험적인 기능이기 때문에 예상치 못한 동작이나 안정성 문제를 일으킬 수 있습니다.
    - **최적화**: 성능 최적화나 새로운 기능 테스트에 유용할 수 있습니다.

```sh
java -XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC -jar myapp.jar
```

여기서 `-XX:+UseEpsilonGC`는 실험적인 GC 알고리즘인 Epsilon GC를 활성화합니다.

## `-XX:+UseCGroupMemoryLimitForHeap`

이 옵션은 컨테이너 환경에서 JVM이 CGroup에 설정된 메모리 제한을 인식하고, 이를 기반으로 힙 메모리 크기를 조정하도록 합니다.
CGroup은 리눅스 커널 기능으로, 컨테이너 내에서 CPU, 메모리 등의 리소스 사용을 제한할 수 있습니다.
이는 메모리 관리와 안정성을 향상시키는 데 도움이 됩니다.

- 작동 방식
    - **메모리 제한 인식**: 이 옵션을 활성화하면 JVM이 CGroup에서 설정한 메모리 제한을 읽어 힙 메모리 크기를 자동으로 조정합니다.
    - **힙 메모리 설정**: JVM의 힙 메모리 크기가 CGroup의 제한 내에서 적절히 설정되어 메모리 초과를 방지합니다.

- 영향을 미치는 부분
    - **메모리 관리**: 컨테이너 환경에서 JVM의 메모리 사용량을 더 효과적으로 관리할 수 있습니다.
    - **안정성**: 메모리 초과로 인한 OOM(Out Of Memory) 오류를 줄일 수 있습니다.
    - **성능**: CGroup 제한에 맞춰 힙 메모리를 조정하므로, 메모리 사용 최적화가 이루어질 수 있습니다.

```sh
java -XX:+UnlockExperimentalVMOptions -XX:+UseCGroupMemoryLimitForHeap -jar myapp.jar
```

## `-XX:+UseCompressedOops` 옵션

`-XX:+UseCompressedOops` 옵션은 메모리 사용 효율을 높이고 성능을 최적화하는 데 유용한 옵션입니다.
여기서 `Oops`는 "Ordinary Object Pointers"의 약자입니다.

`-XX:+UseCompressedOops` 옵션은 64비트 JVM에서 사용 가능한 메모리 최적화 기능 중 하나로, 기본적으로 활성화되어 있습니다.
이 옵션은 객체 포인터를 32비트로 압축하여 메모리 사용 효율을 높이는 데 사용됩니다.
대규모 객체를 다루는 애플리케이션에서 특히 효과적입니다.
이 옵션을 사용하여 메모리 사용량을 줄이고 캐시 효율성을 높일 수 있습니다.

시스템이 최대 32GB의 힙 메모리를 사용하지 않는 한, 이 옵션을 활성화 상태로 두는 것이 좋습니다.

- 작동 원리

    1. **포인터 압축**: 64비트 JVM에서 객체 포인터는 64비트입니다. 하지만, 대부분의 애플리케이션은 4GB 이상의 힙 메모리를 사용하지 않습니다. `-XX:+UseCompressedOops` 옵션은 객체 포인터를 32비트로 압축하여 메모리 사용을 최적화합니다.
    2. **주소 공간**: 압축된 포인터는 32비트 주소 공간을 사용하므로, 더 많은 객체를 힙에 저장할 수 있습니다.

- 장점

    1. **메모리 절약**: 객체 포인터 크기가 줄어들어 메모리 사용량이 감소합니다. 이는 특히 대규모 객체를 다루는 애플리케이션에서 유용합니다.
    2. **캐시 효율성**: 작은 포인터 크기로 인해 캐시 효율성이 높아져 메모리 접근 속도가 향상될 수 있습니다.
    3. **GC 성능**: 더 작은 힙을 더 효율적으로 관리할 수 있어 가비지 컬렉션 성능이 향상될 수 있습니다.

- 단점

    1. **제한된 주소 공간**: 압축된 포인터는 최대 32GB의 힙 메모리까지 지원합니다. 이 한계를 넘는 경우 압축된 포인터를 사용할 수 없습니다.
    2. **추가 연산**: 포인터 압축과 압축 해제 작업이 추가되므로, 약간의 성능 오버헤드가 있을 수 있습니다. 하지만, 이는 대부분의 경우 무시할 수 있는 수준입니다.

- 실제 사용 사례

    - **메모리 절약**: 대규모 객체를 많이 생성하고 사용하는 애플리케이션에서 메모리 사용량을 줄이는 데 효과적입니다.
    - **고성능 애플리케이션**: 메모리 접근 속도가 중요한 고성능 애플리케이션에서 캐시 효율성을 높일 수 있습니다.

기본적으로 64비트 JVM에서는 `-XX:+UseCompressedOops`가 활성화되어 있습니다. 필요에 따라 비활성화할 수도 있습니다.

```sh
# 활성화 (기본적으로 활성화됨)
java -XX:+UseCompressedOops -jar myapp.jar
```

```sh
# 비활성화
java -XX:-UseCompressedOops -jar myapp.jar
```
