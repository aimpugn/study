# Garbage Collector

## GC 종류 개요

Java 플랫폼은 여러 가지 가비지 컬렉터를 제공하고 있으며, 각각의 특성과 사용 사례에 맞게 선택할 수 있습니다.
기본적으로 제공하는 GC 옵션들은 다음과 같습니다.

1. **Serial GC**: `-XX:+UseSerialGC`
   - 단일 스레드 환경에서 사용하기 적합한 GC
   - 간단하고 예측 가능한 성능을 제공
2. **Parallel GC (Throughput Collector)**: `-XX:+UseParallelGC`
   - 멀티스레드를 사용하여 가비지 컬렉션을 병렬로 수행
   - 처리량(throughput)을 최대화하는 데 초점을 맞추고 있다
3. **Concurrent Mark Sweep (CMS) GC**: `-XX:+UseConcMarkSweepGC`
   - 낮은 응답 시간을 요구하는 애플리케이션에 적합하다
   - CMS GC는 더 이상 Java 9 이후 버전에서는 권장되지 않으며, 점차 사용이 줄어들고 있다
4. **Garbage-First (G1) GC**: `-XX:+UseG1GC`
   - 대규모 힙을 대상으로 설계되었다
   - 응답 시간에 대한 예측 가능한 성능을 제공한다
5. **Shenandoah GC**: `-XX:+UseShenandoahGC`
   - 낮은 응답 시간을 목표로 한다
   - GC 중에도 애플리케이션 스레드가 계속 실행될 수 있도록 설계되었다
6. **Z Garbage Collector (ZGC)**: `-XX:+UseZGC`
   - 낮은 지연 시간을 가진다
   - 애플리케이션 스레드의 작업을 방해하지 않으려는 목적으로 설계
   - 멀티테라바이트의 힙에서도 일관된 낮은 지연 시간을 유지할 수 있도록 설계된 가비지 컬렉터
7. **Epsilon GC (No-Op GC)**: `-XX:+UseEpsilonGC`
   - 성능 테스트 목적으로 설계된 "No-Op" 가비지 컬렉터
   - 가비지 컬렉션을 수행하지 않고, 메모리 할당만을 처리한다

## G1GC vs ParallelGC 비교 분석

### ParallelGC (Parallel Garbage Collector)

- 멀티 스레드를 사용하여 병렬로 가비지 컬렉션을 수행합니다.
- Stop-the-world 방식으로 작동하며, GC 동안 모든 애플리케이션 스레드가 일시 중지됩니다.

#### 장점

1. 높은 처리량(Throughput): 전체 애플리케이션 실행 시간 중 GC에 소요되는 시간의 비율이 낮습니다.
2. 멀티코어 시스템에서 효율적: 여러 CPU 코어를 활용하여 GC를 수행합니다.

#### 단점

1. 긴 일시 중지 시간: GC 수행 중 애플리케이션이 완전히 중지될 수 있습니다.
2. 대용량 힙에서의 성능 저하: 힙 크기가 매우 큰 경우 GC 시간이 길어질 수 있습니다.

#### 적합한 사용 사례

- 배치 처리 작업이나 백그라운드 작업과 같이 응답 시간보다 처리량이 중요한 애플리케이션
- 중소 규모의 힙 크기를 가진 애플리케이션

### G1GC (Garbage-First Garbage Collector)

- 힙을 균등한 크기의 영역(region)으로 나누어 관리합니다.
- 점진적이고 동시적인 방식으로 가비지 컬렉션을 수행합니다.
- 가장 많은 가비지를 포함한 영역부터 수집하는 방식으로 작동합니다.

#### 장점

1. 짧은 일시 중지 시간: GC로 인한 애플리케이션 중단 시간을 최소화합니다.
2. 대용량 힙 처리에 효과적: 수 TB 크기의 힙도 효율적으로 관리할 수 있습니다.
3. 자동 튜닝: 사용자가 설정한 일시 중지 시간 목표를 달성하기 위해 자동으로 조정됩니다.

#### 단점

1. CPU 사용량 증가: 백그라운드에서 지속적으로 작업을 수행하므로 CPU 사용량이 높습니다.
2. 메모리 오버헤드: 영역 관리를 위한 추가 메모리가 필요합니다.

#### 적합한 사용 사례

- 대용량 힙을 사용하는 애플리케이션
- 응답 시간이 중요한 애플리케이션 (예: 웹 서버, 데이터베이스)
- 복잡한 객체 그래프를 가진 애플리케이션

### IntelliJ IDEA에 G1GC가 더 적합한 이유

1. 대용량 힙 처리: IntelliJ IDEA는 대규모 프로젝트와 많은 플러그인을 사용할 때 대용량 힙을 필요로 합니다. G1GC는 이러한 환경에서 더 효과적입니다.

2. 응답성 유지: IDE는 사용자 상호작용이 빈번한 애플리케이션입니다. G1GC의 짧은 일시 중지 시간은 IDE의 반응성을 유지하는 데 도움이 됩니다.

3. 복잡한 객체 구조: IDE는 복잡한 객체 그래프를 가지고 있으며, G1GC는 이러한 구조를 효율적으로 처리할 수 있습니다.

4. 자동 튜닝: G1GC의 자동 튜닝 기능은 다양한 작업 부하에 대해 IDE의 성능을 최적화하는 데 도움이 됩니다.

5. 장기 실행: 개발자들은 종종 IDE를 장시간 실행하며, G1GC는 장기 실행 애플리케이션의 성능 저하를 방지하는 데 더 효과적입니다.

결론적으로, ParallelGC가 특정 상황에서 높은 처리량을 제공할 수 있지만, IntelliJ IDEA와 같은 복잡하고 리소스 집약적인 애플리케이션의 경우 G1GC가 전반적으로 더 나은 성능과 사용자 경험을 제공합니다.

## 기타

### 참고

- [JVM Garbage Collection](https://www.devkuma.com/docs/jvm/garbage-collection/)
