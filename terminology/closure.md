# closure

- [closure](#closure)
    - [클로저란?](#클로저란)
    - [용어의 유래](#용어의-유래)
    - [개발자들이 사용하는 이유](#개발자들이-사용하는-이유)
        - [수학에서의 예](#수학에서의-예)
        - [컴퓨터 과학에서의 예](#컴퓨터-과학에서의-예)
    - [전이적 폐쇄(transitive closure)](#전이적-폐쇄transitive-closure)
        - [전이적 폐쇄와 프로그래밍 언어의 클로저와의 차이](#전이적-폐쇄와-프로그래밍-언어의-클로저와의-차이)
        - [발생 전 관계와 전이적 폐쇄](#발생-전-관계와-전이적-폐쇄)
    - [Examples](#examples)
        - [Rust에서 컬렉션 요소 처리](#rust에서-컬렉션-요소-처리)

## 클로저란?

클로저는 자신이 정의된 범위(scope) 밖의 변수를 "캡쳐"할 수 있는 익명 함수다.
클로저는 일반 함수와 유사하게 동작하지만, 클로저는 *실행될 때 정의된 환경의 일부를 "닫아(capture)"서 저장*할 수 있다.
이러한 특성 때문에 클로저는 주변 컨텍스트의 데이터를 사용하여 실행될 수 있으며, 이 데이터는 클로저가 살아 있는 동안 계속 유지된다.

클로저는 함수형 프로그래밍 뿐만 아니라, 이벤트 처리, 비동기 프로그래밍, 데이터 변환 등 다양한 컨텍스트에서 사용된다.
Rust에서 클로저는 메모리 안전성과 타입 안전성을 보장하는 동시에, 강력한 기능과 편의성을 제공한다.

## 용어의 유래

클로저(closure)라는 용어는 수학과 컴퓨터 과학에서 오랜 기간 사용되어 온 개념이다.
"닫힘" 또는 "완결성"을 의미하는 "closure property"에서 유래되었다.
프로그래밍에서의 클로저는 함수가 자신이 생성될 때의 환경을 "닫는"(즉, 캡쳐하는) 능력에서 그 이름이 유래되었다.
클로저는 함수형 프로그래밍 언어에서 유래했다. 알고리즘(algorithm)와 람다 계산(λ-calculus) 같은 이론적 모델에서 중요한 개념으로, 함수형 프로그래밍 언어의 발전과 함께 널리 사용되기 시작했다.

수학과 컴퓨터 과학에서의 "폐쇄" 개념은 어떤 집합에 대해 정의된 연산이나 관계가 *그 집합 내의 모든 요소에 대해 적용될 때, 그 결과 역시 해당 집합에 속하는 성질*을 의미한다.
이를 통해 집합이 특정 연산에 대해 '닫혀있다(closed)'고 표현한다.

## 개발자들이 사용하는 이유

클로저는 다음과 같은 이유로 개발자들에게 유용하다:

- **익명성**

    클로저는 이름 없이 정의될 수 있으므로, 일시적인 동작이나 작은 범위의 동작을 정의할 때 편리하다.

- **유연성**:

    클로저는 주변 환경의 변수를 캡쳐할 수 있어, 데이터를 클로저에 전달하고 조작하는 데 유연성을 제공한다.

- **코드 간결성**

    클로저를 사용하면 복잡한 동작을 간결하게 표현할 수 있으며, 콜백 함수나 고차 함수를 사용하는 패턴을 간편하게 구현할 수 있다.

### 수학에서의 예

- **정수 집합에 대한 덧셈 연산**: 정수 집합 \(Z\)는 덧셈 연산에 대해 폐쇄적이다. 즉, 어떤 두 정수 \(a\)와 \(b\)를 더하더라도 그 결과는 항상 정수 집합 \(Z\)에 속합니다. 예를 들어, \(3 + (-5) = -2\)는 여전히 정수다.

- **자연수 집합에 대한 나눗셈 연산**: 자연수 집합 \(N\)은 나눗셈 연산에 대해 폐쇄적이지 않다. 예를 들어, 자연수 5와 2를 나누면 \(5 / 2 = 2.5\)이며, 이 결과는 자연수 집합에 속하지 않는다.

### 컴퓨터 과학에서의 예

- **프로그래밍 언어의 타입 시스템**: 특정 프로그래밍 언어에서 정수 타입의 변수에 대한 덧셈 연산은 그 결과도 정수 타입으로, 해당 타입 시스템 내에서 폐쇄적이다. 예를 들어, C 언어에서 `int a = 5; int b = 3; int c = a + b;`라고 할 때, `c`의 값 `8` 역시 정수(`int`) 타입이다.

- **데이터베이스의 조인 연산**: 특정 테이블의 레코드 집합에 대한 조인 연산을 수행할 때, 결과로 반환되는 레코드 집합은 여전히 데이터베이스 테이블의 형태를 유지한다. 이는 데이터베이스 테이블 집합이 조인 연산에 대해 폐쇄적임을 의미한다.

## 전이적 폐쇄(transitive closure)

전이적 폐쇄는 관계의 개념에서 유래한다.
어떤 집합에서 정의된 이항 관계가 있을 때, 그 관계에 대한 전이적 폐쇄는 그 관계를 간접적으로 확장하여, 집합 내의 모든 요소들 간에 가능한 모든 연결을 포함시키는 새로운 관계를 형성한다.

> **이항 관계(Binary Relation)?**
>
> 두 집합 간의 관계를 나타내는 수학적 개념이다. 보다 구체적으로, 이항 관계는 한 집합의 요소와 다른 집합의 요소 사이에 존재하는 관계를 정의한다. 이 때, 두 집합은 같을 수도 있고 다를 수도 있다.
> 이항 관계는 집합 (A)와 집합 (B)의 요소들 사이에 쌍을 형성하여 나타낼 수 있으며, 이러한 쌍들의 집합으로 표현된다. 즉, 이항 관계는 ($A \times B$)의 부분집합으로 정의된다.
>
> 집합 $A = \{1, 2, 3\}$과 집합 $B = \{a, b\}$ 사이의 이항 관계
> $R = \{(1, a), (2, b), (3, a)\}$.
>
> 이 경우, (1)은 (a)와 관계가 있고, (2)는 (b)와 관계가 있으며, (3)은 다시 (a)와 관계가 있다.

- **전이적(Transitive)**: A가 B와 관계가 있고, B가 C와 관계가 있다면, A와 C도 같은 관계에 있다는 성질이다
- **폐쇄(Closure)**: 특정 연산이나 관계에 대해, 그 연산/관계를 적용한 결과가 원래의 집합을 벗어나지 않고 그 집합 내에 '폐쇄'되는 성질을 의미한다.

### 전이적 폐쇄와 프로그래밍 언어의 클로저와의 차이

- **전이적 폐쇄**는 관계의 모든 가능한 경로를 포함시키는 수학적 개념입니다. 이는 관계나 연산이 어떤 집합 내에서 완결성을 가지는 것을 보장합니다.
- **프로그래밍 언어의 클로저**는 함수가 정의될 때의 환경을 "포획"하여, 함수가 실행될 때도 그 환경에 접근할 수 있게 하는 기능입니다.

두 용어 모두 "폐쇄"라는 단어를 사용하지만, 각각 완전히 다른 맥락에서 사용됩니다.

### 발생 전 관계와 전이적 폐쇄

"발생 전(happens-before)" 관계에서의 전이적 폐쇄는, 프로그램 내의 모든 메모리 작업(읽기와 쓰기) 사이의 간접적인 순서 관계를 포함하여, 프로그램의 실행에 대한 전체적인 순서를 정의합니다. 이는 프로그램이 예측 가능하고 일관된 방식으로 동작하도록 하는데 필수적인 요소입니다.

- **순서 전(sequenced before)**: 프로그램 코드에서 명시적으로 표현된 순서입니다.
- **동기화 이전(synchronized before)**: 스레드 간의 동기화 메커니즘에 의해 정의된 순서입니다.

"발생 전" 관계는 이러한 두 관계를 합친 것의 전이적 폐쇄로, 프로그램 내에서 가능한 모든 순서 관계를 포괄합니다. 여기서 "폐쇄"는 이 관계가 프로그램의 모든 메모리 작업에 대해 완결되고 포괄적인 것임을 의미합니다.

결국, 전이적 폐쇄는 복잡한 관계 집합 내에서 간접적인 관계까지 고려하여, 그 관계를 완전하고 포괄적으로 표현하는 수단입니다. 프로그램의 실행 순서와 메모리 일관성에 있어서 이는 매우 중요한 개념입니다.

## Examples

### Rust에서 컬렉션 요소 처리

```rs
let numbers = vec![1, 2, 3, 4, 5];
let squared_numbers: Vec<i32> = numbers.iter().map(|&x| x * x).collect();
//                                                 ^^^^^^^^^^^ 이 부분이 클로저
//                                                 `x`라는 입력에 대해 `x * x`를 계산하여 반환
println!("{:?}", squared_numbers); // [1, 4, 9, 16, 25]
```
