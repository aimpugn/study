package p42860

import kotlin.math.min

/**
 * [조이스틱](https://school.programmers.co.kr/learn/courses/30/lessons/42860)
 */
class Solution {
    /**
     * - 조이스틱으로 알파벳 이름 완성하기
     * - 맨 처음에는 A로만 이루어져 있음
     *      - 3글자 경우: AAA
     *      - 4글자 경우: AAAA
     *  - 방향
     *      - 위: 다음 알파벳
     *      - 아래: 이전 알파벳(A에서 아래로 이동하면 Z)
     *      - 왼쪽: 커서 왼쪽 이동(첫번째에서 좌측으로 이동시 우측 끝으로)
     *      - 오른쪽: 커서 오른쪽 이동(마지막에서 오른쪽으로 이동시 좌측 끝으로)
     * Example:
     * 1. JAZ
     *      초기 상태 AAA
     *      1. 첫번째 위치에서 조이스틱을 위로 9번 조작하여 JAA (+9)
     *      2. 왼쪽 이동하여 커서를 마지막 위치로 JAA| (+1)
     *      3. 아래로 1번 조작하여 Z 완성 -> JAZ (+1)
     *      총 11회 이동하여 완성
     * 2. JAN
     *      초기 상태 AAA
     *      1. 첫번째 위치에서 조이스틱을 위로 9번 조작하여 JAA (+9)
     *      2. 왼쪽 이동하여 커서를 마지막 위치로 JA|A (+1)
     *      3. 아래로 13번 조작하여 N 완성 -> JAN (+13)
     *      총 23회 이동하여 완성
     * 3.JEROEN
     *      초기 상태 AAAAAA
     *      1. 첫번째 위치에서 조이스틱을 위로 9번 조작하여 JAAAAA (+9)
     *      2. 오른쪽으로 한 칸 이동(+1)
     *      3. 위로 4번 조작하여 E 선택 JEAAAA (+4)
     *      4. 오른쪽으로 한 칸 이동(+1)
     *      5. 아래로 9번 조작하여 R 선택 JERAAAA(+9)
     *      6. 오른쪽으로 한 칸 이동(+1)
     *      7. 아래로 12번 조작하여 O 선택 JEROAA (+12)
     *      8. 오른쪽으로 한 칸 이동(+1)
     *      9. 위로 4번 조작하여 E 선택 JEROEA (+4)
     *      10. 오른쪽으로 한 칸 이동(+1)
     *      11. 위 또는 아래 13번 조작하여 N 선택 JEROEN (+13)
     *      총 5+9+4+9+12+4+13 = 56회 이동하여 완성
     *
     * @param name 만들고자 하는 이름
     *  - 알파벳 대문자로만 구성
     *  - 1 <= name.length <= 20
     *
     * @return 이름에 대해 조이스틱 조작 횟수의 최솟값 리턴
     */
    fun solution(name: String): Int {
        // 어떻게 하면 최솟값을 구할 수 있을까?
        // 이동 케이스
        // - 문자열 두 개: AA
        //      좌로 가든, 우로 가든 같습니다.
        // - 문자열 세 개: AAA
        //      중간이 A인 경우 좌로 가야 하고,
        //      중간이 A가 아닌 경우 우로 가야 합니다.
        // - 문자열 네 개: AAAA
        //      1. 중간이 AA인 경우 좌로 가야 하고, 중간이 AA가 아닌 경우 우로 가야 합니다.
        //      2. AABA 같은 경우 좌든 우든 두 번 조작해야 해서 같습니다.
        // - 문자열 다섯 개: AAAAA
        //      1. 중간이 AAAA인 경우 좌로 가야 하고, 중간이 AAAA가 아닌 경우 우로 가야 합니다.
        //      2. AAABA 같은 경우 좌로 두 번 가야 합니다.
        //      3. AABAA 같은 경우 우로 두 번 가야 합니다.
        //      4. AABBA 같은 경우 좌/우 상관없습니다.
        //      5. ABBAA 경우 우로 가야 합니다.
        // 이러면 조작이 어려워 보이는데, 미리 차이들을 계산해두면?
        //   JAZ
        // - AAA
        //   901
        //
        //   J E R  O E  N
        // - A A A  A A  A
        //   9 4 9 12 4 13
        //
        //   AAABA
        // - AAAAA
        //   00010
        //
        //   JAADBA
        // - AAAAAA
        //   900310
        //
        // 0을 제외하고 가장 작은 수의 위치로 이동합니다.
        // 이동할 위치를 고를 때는 현재 위치 기준으로 투 포인터를 사용해서 이동 거리를 확인합니다.

        // 1. 위/아래 조작 횟수를 구합니다.
        val diffList = name.toList().map {
            min(it - 'A', 'Z' - it + 1)
        }

        // 모든 문자가 'A'인지 확인
        if (diffList.all { it == 0 }) {
            return 0
        }
        
        // 2. 조작 횟수 기준으로 좌/우 이동을 구합니다.
        //      `*`: 시작 지점
        //
        //      - JAZ 경우 1번 이동이 최적
        //        9 0 1
        //        *
        //            ^
        //      - JEROEN 경우 5회 이동이 최적
        //        9 4 9 12 4 13
        //        *
        //          ^
        //            ^
        //               ^
        //                 ^
        //                    ^
        // 한번 방향을 정하면 그쪽 방향으로 계속 진행해야 할 거 같은데,
        // 돌아감으로써 이득이 있는 경우가 존재하는지?
        //
        // A A A J A A A A A B
        // 0 0 0 9 0 0 0 0 0 1
        // *
        //                   ^
        //       ^
        // - 좌로 쭉 간다고 할 경우: 7번 이동
        // - 우로 쭉 간다고 할 경우: 9번 이동
        // - 좌로 갔다가 우로 갈 경우: 5번 이동
        // 한쪽 방향으로 쭉 가는 게 아니라, 어디가 됐든 0이 아닌 어떤 숫자가 있는 값이 있다면 현재 기준으로 정/역방향 이동 계산합니다.
        // 계산 방법:
        // - 투 포인터로 left, right 움직이면서 다음으로 이동할 곳 찾기?
        // - 인덱스와 값을 페어로 갖고 있는 우선순위 큐 차감? 근데 인덱스 사용하는 것과 다를 게 없을 거 같음 (X)

        // 2. 투 포인터로 좌/우 이동 횟수를 계산합니다.
        val length = name.length
        // 방향 전환 없이 가장 단순하게 이동하는 경우가 최악의 경우에 해당합니다.
        var minMove = length - 1

        for (i in diffList.indices) {
            if (diffList[i] == 0) continue
            // nextIndex는 현재 위치 i에서 시작하여, 연속된 'A'를 건너뛰고 다음으로 변경해야 하는 문자의 인덱스를 찾습니다.
            var nextIndex = i + 1
            // 다음 변경해야 하는 문자를 찾습니다.
            while (nextIndex < length && diffList[nextIndex] == 0) {
                nextIndex++
            }
            // 방향을 바꾸는 경우의 이동 횟수를 계산합니다.
            // 현재 위치 i까지 오른쪽으로 이동했다가, 다시 왼쪽으로 돌아가서 끝에서부터 다음 변경 위치까지 이동하는 경우의 총 이동 횟수
            val move1 = i + // 현재 i까지 이동한 거리
                i + // 다시 i만큼 되돌아 가는 거리
                length - nextIndex // 끝에서부터 다음 변경 위치까지의 거리

            // 끝까지 왼쪽으로 이동하여 다음 변경 위치까지 이동한 후, 다시 오른쪽으로 돌아와서 현재 위치 i까지 이동하는 경우의 총 이동 횟수
            val move2 = (length - nextIndex) + // 왼쪽으로 이동하여 다음 변경 위치까지 이동한 거리
                (length - nextIndex) + // 다시 오른쪽으로 돌아가는 거리
                i // 현재 위치 i까지 오른쪽으로 이동한 거리

            // 최소(최초 선형으로 쭉 이동하는 경우, i까지 갔다가 다시 왼쪽으로 돌아가는 경우, 왼쪽으로 갔다가 다시 오른쪽으로 돌아오는 경우)
            minMove = minOf(minMove, move1, move2)
        }
        return minMove + diffList.sum()
    }
}

fun main() {
    val testCases = arrayOf(
        "AAAAAA",
        "AAABAAA",
        "JAZ",
        "JAN",
        "JEROEN",
        "JAADBA",
        "AAAJAAAAAB",
    )
    for (testCase in testCases) {
        println(Solution().solution(testCase))
    }
}