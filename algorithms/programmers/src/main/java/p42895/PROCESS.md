# process

```java
    /**
    * - 5와 사칙연산만으로 12 표현 가능
    *
    *   1. 5 + 5 + (5/5) + (5/5) = 10 + 1 + 1 = 12
    *      ^   ^    ^ ^     ^ ^ 6회
    *   2. 55/5 + 5/5 = 11 + 1 = 12
    *      ^^ ^   ^ ^ 5회
    *   3. (55 + 5) / 5 = 12
    *       ^^   ^    ^ 4회
    *
    * - 2와 사칙연산만으로 11 표현 가능
    *
    *   1. 2 + 2 + 2 + 2 + 2 + (2/2) = 11
    *   2. 2 + 2 + 2 + 2 + (2/2) + (2/2) + (2/2) = 11
    *      => 근데, 이미 1번에서 7개 사용해서 해결했기에,
    *         7번 넘어가는 경우는 고려치 않아도 됩니다.
    *   3. 22/2 = 11
    *
    * rule:
    * - 사칙연산만 가능
    * - 나누기에서 나머지 무시
    *
    * @param N 표현에 사용될 숫자. 1 <= N <= 9.
    * @param number 사칙연산으로 도출해낼 수. 1 <= number <= 32,000.
    *
    * @return N 사용횟수 최솟값. if returnValue > 8 then return -1
    */
    public int solution(int N, int number) {
        int answer = 0;

        // 사칙연산을 해야 합니다.
        // 사칙연산 외에 N이 붙어서 자리수가 증가하는 경우도 고려해야 합니다.
        // - if N = 5, then 5, 55, 555... < 32,000(한도)
        //
        // - '(5/5)'를 12번 더하면 12가 나올 수 있으므로, 이것도 가능한 경우입니다.
        //   (5/5) + (5/5) + (5/5) + ... + (5/5) = 12
        //
        //
        // 구상...
        // - 도움이 될 거 같은 자료구조 또는 변수
        //   - 연산 결과 캐싱하는 HashMap
        //   - 가장 최근 number 연산 성공한 조합의 N 개수를 저장해둘 변수 => 초과시 백트래킹
        //
        // - 어떻게 자료구조를 탐색하고 제어할 것인지?
        //
        //   시작 지점을 5로 잡고 55, 555, 5555... 로 체크?
        //   - 5555555 / 5, 5555555 / 55 이런 경우?
        //   - 5/5, 55/55, 555/555 처럼 그 결과가 동일한 경우?
        //     => "NNN"/"NNN" 문자열로 만들어서 길이가 같으면 1로 처리
        //
        //   다른 방법? 일단 5를 붙여나가면서
        //   재귀적으로 연산을 시도해보는 방법 외에는 당장은 떠오르는 게 없습니다.

        return answer;
    }
```

처음 시도로 위와 같이 정리했습니다.
하지만 아직 구체적인 알고리즘 설계가 부족합니다.
- 어떤 순서로 연산을 수행할 것인지
- 어떻게 N을 붙여나갈 것인지
- 반복문은 언제, 왜 사용할 것인지
- 이때 사용할 자료구조는 무엇을 왜 사용할 것인지
- 어떻게 모든 가능한 경우를 고려할지 등

일단 문제를 보면 동일한 연산을 반복적으로 수행할 것으로 보입니다.
`(5/5)`가 12번 더하면 그 결과가 12인데, 이때 `(5/5)` 연산을 12번하는 것은 낭비입니다.
이 부분에서 캐시 같은 게 필요할 것으로 판단됩니다.

최적해(최소 사용 횟수)를 찾아야 합니다. 최적해는 결국 가능한 모든 경우의 수를 알아야 합니다.
물론 제한이 있어서 백트래킹이 되겠지만, 제한된 범위 내의 모든 경우의 수를 탐색할 수 있어야 합니다.
이 점에서 완전 탐색 문제로 보입니다.

N을 붙여 나가는 과정에서 앞의 결과를 기반으로 새로운 케이스를 생성할 것으로 보입니다.

```plaintext
N=5일 때

level
1                       5 (N을 1번 사용)
                        |
             +---------++---------+
             |          |         |
2        5+5 (2번)   5-5 (2번)  5*5 (2번)
         |   |
     +---+---+---+
     |   |   |   |
3   5+10 5+5 10+5 10-5 ... (3번 사용)
     |
     +---+---+---+
     |   |   |   |
...

level
1                 55 (N을 2번 연속 사용)
                   |
           +-------+-------+
           |       |       |
2      55+5 (3번) 55-5   55*5
         |
     +---+---+
     |   |   |
     ...

level
1                 555 (N을 3번 연속 사용)
                   |
           +-------+-------+
           |       |       |
2      555+5     555-5   555*5
         |
     +---+---+
     |   |   |
    ...

```

가능한 접근 방식들은 다음과 같을 거 같습니다.
- ~~완전 탐색 (Brute Force)~~:

    모든 가능한 조합을 시도하지만,
    경우의 수가 너무 많아 비효율적입니다. (사칙연산 4, 최대 8개의 N => 4^8)

- ~~그리디 알고리즘~~:

    각 단계에서 최선의 선택하지만, 최적해를 보장하지 않습니다.

    예: `5 * 5 = 25`가 `5 + 5 + 5 + 5 + 5 = 25` 보다 효율적입니다.

- DFS/BFS:

    모든 가능한 연산을 트리 형태로 탐색합니다.
    모든 경우를 고려할 수 있지만, 중복 계산이 많습니다.

- 동적 프로그래밍 (DP):

    부분 문제의 해를 저장하고 재사용합니다.
    중복 계산 제거, 최적 부분 구조 활용 가능합니다.

DP는 *현재 상태에서 다음 상태로의 전이(Transition)를 정의할 수 있을 때 유용*합니다.
이 문제에서는 숫자 `N`을 사용하여 만들 수 있는 숫자들을 단계적으로 전이해 나가며 연산을 수행하는 과정이 있습니다.

예를 들어, 숫자 5를 가지고 (5 + 5), (5 * 5), (5 / 5) 등의 다양한 연산을 통해 다른 숫자로 전이할 수 있습니다.

DP 적용 가능성 검토:
- 최적 부분 구조: N을 k번 사용한 결과는 N을 k-1번 이하로 사용한 결과들의 조합
- 중복되는 부분 문제: 같은 수를 만드는 여러 방법 존재 (예: 5+5와 5*2)
- 상향식 접근 가능: N을 1번 사용한 경우부터 시작하여 단계적으로 확장 가능

DP 설계:
- 상태 정의

    ```java
    dp[i] = N을 i번 사용하여 만들 수 있는 수들의 집합
    ```

    N=5일 때 dp 배열의 구조입니다:

    ```java
    dp[1] = {5}
    dp[2] = {0, 1, 10, 25, 55}  // 55 포함 (5를 두 번 연속 사용)
    dp[3] = {6, 15, 30, 555, ...}  // 여기에는 dp[2]와 dp[1]의 조합, 그리고 555가 포함됩니다.
    ```

    `dp[2]`가 `dp[3]`의 최적 부분 구조가 되는 방식은 다음과 같습니다.

    **`dp[3]`의 원소 생성 방법**:
    - `dp[2]`의 각 원소와 `dp[1]`의 원소(5)를 조합:
        - 0+5, 0-5, 0*5, 0/5
        - 1+5, 1-5, 1*5, 1/5
        - 10+5, 10-5, 10*5, 10/5
        - 25+5, 25-5, 25*5, 25/5
        - 55+5, 55-5, 55*5, 55/5
    - `dp[1]`의 원소와 `dp[2]`의 각 원소를 조합:
        - 5+0, 5-0, 5*0, 5/0
        - 5+1, 5-1, 5*1, 5/1
        - 5+10, 5-10, 5*10, 5/10
        - 5+25, 5-25, 5*25, 5/25
        - 5+55, 5-55, 5*55, 5/55
    - 5를 세 번 연속 사용: 555

    **최적 부분 구조의 의미**:
    - `dp[3]`의 모든 원소는 `dp[2]`와 `dp[1]`의 원소들을 조합하여 만들어집니다.
    - 이는 `N`을 3번 사용하여 만들 수 있는 모든 수가 `N`을 2번 사용하여 만든 수와 `N`을 1번 사용하여 만든 수의 조합으로 표현될 수 있음을 의미합니다.

- 점화식:

    ```java
    dp[i] = dp[j] (+, -, *, /) dp[i-j]

    (1 ≤ j < i) U {int(N* '1' * i)}
    ```

- 베이스 케이스

    ```java
    dp[1] = {N}
    ```
