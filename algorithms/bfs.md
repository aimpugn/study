# BFS

- [BFS](#bfs)
    - [BFS?](#bfs-1)
    - [동작 방식](#동작-방식)
    - [특징](#특징)
        - [BFS 사용이 적합한 문제](#bfs-사용이-적합한-문제)
    - [장점](#장점)
    - [공간 복잡도: `O(V)`](#공간-복잡도-ov)
    - [시간 복잡도: `O(V + E)`](#시간-복잡도-ov--e)
    - [함수의 콜 스택](#함수의-콜-스택)
    - [예제](#예제)

## BFS?

Breadth First Search, **너비**를 우선 탐색하는 알고리즘입니다.
시작 노드에서 시작해서 *인접한 모든 노드*를 먼저 탐색합니다.

BFS는 그래프나 트리를 탐색하기 위한 알고리즘 중 하나입니다.

기본적인 탐색 방식은 다음과 같습니다:
- 시작 노드에서 출발하여 인접한 모든 노드를 먼저 방문
- 그 다음 레벨의 모든 노드를 방문하고
- 이 과정을 모든 노드를 방문할 때까지 반복

## 동작 방식

```java
/**
 * @param 그래프 탐색할 그래프 구조
 * @param 시작_노드 탐색을 시작할 노드
 */
function BFS(그래프, 시작_노드):
    방문_기록 = set()
    큐 = Queue()

    방문_기록.add(시작_노드)
    큐.enqueue(시작_노드)

    while not 큐.is_empty():
        현재_노드 = 큐.dequeue()
        print(현재_노드)  // 노드 방문

        for 이웃_노드 in 그래프[현재_노드]:
            if 이웃_노드 not in 방문_기록:
                방문_기록.add(이웃_노드)
                큐.enqueue(이웃_노드)

// 실행
그래프 = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': ['G'],
    'F': [],
    'G': []
}
BFS(그래프, 'A')
```

```plaintext
Init:    A
        / \
       B   C
      / \   \
     D   E   F
        /
       G


Step 1:   A*
         / \
        B   C
       / \   \
      D   E   F
         /
        G
     (방문: A)

Step 2:   A*
         / \
        B*  C*
       / \   \
      D   E   F
         /
        G
     (방문: A,B,C)

Step 3:   A*
         / \
        B*  C*
       / \   \
      D*  E*  F
         /
        G
    (방문: A,B,C,D,E)

Step 4:   A*
         / \
        B*  C*
       / \   \
      D*  E*  F*
         /
        G
      (방문: A,B,C,D,E,F)

Step 5:   A*
         / \
        B*  C*
       / \   \
      D*  E*  F*
         /
        G*
  (방문: A,B,C,D,E,F,G)
```

## 특징

- *현재 깊이의 모든 노드*를 탐색한 후 다음 깊이로 이동합니다.

- BFS는 최단 경로를 찾는 문제에 자주 사용됩니다.
    반면, DFS는 모든 경로를 탐색하므로 최단 경로를 찾는 데는 적합하지 않을 수 있습니다.

- 시작 노드로부터의 최단 경로를 찾는 데 유용합니다.

- 탐색할 모든 노드를 저장해야 하므로 메모리 사용량이 높을 수 있습니다.

- 모든 레벨의 노드를 탐색하기 때문에, 해가 존재한다면 반드시 찾을 수 있습니다.

- 레벨별로 탐색을 진행하기 때문에, 레벨에 따라 해석이 필요한 문제에 적합합니다.

- 주로 큐를 사용하여 구현합니다.

### BFS 사용이 적합한 문제

1. 최단 경로 문제:
    - 특징: 시작점으로부터 각 노드까지의 최단 거리를 보장합니다.
    - 예: 네트워크에서의 최단 경로, 최소 편집 거리

2. 레벨 순서 탐색:
    - 특징: 각 레벨의 노드를 순서대로 처리해야 할 때 유용합니다.
    - 예: 트리의 레벨 순서 순회, 간단한 AI의 의사결정 트리

3. 최소 단계 문제:
    - 특징: 목표 상태에 도달하기 위한 최소 변경 횟수를 찾는 데 유용합니다.
    - 예: 슬라이딩 퍼즐, 워드 래더 문제

4. 그래프의 연결성 확인:
    - 특징: 두 노드 사이의 연결 여부를 빠르게 확인할 수 있습니다.
    - 예: 소셜 네트워크에서 두 사용자 간의 연결 확인

## 장점

- 최단 경로를 찾을 때 유용합니다. (가중치가 없는 경우).
- 두 노드 사이의 최소 경로나 최소 비용을 찾는 문제에 적합합니다.
- 특정 경우에 시간 복잡도가 DFS보다 예측 가능합니다.

## 공간 복잡도: `O(V)`

일반적으로 `O(V)`의 공간 복잡도(V = 그래프의 노드 수)를 갖습니다.
이는 방문한 노드와 방문할 노드를 관리하기 위해 큐 자료구조를 사용하기 때문입니다.

## 시간 복잡도: `O(V + E)`

모든 노드와 엣지를 한 번씩 방문하므로 `O(V + E)`입니다.
- `V` = 노드 수
- `E` = 엣지 수

## 함수의 콜 스택

BFS는 일반적으로 재귀 호출을 사용하지 않고, 명시적인 큐 자료구조를 사용해 구현합니다.

따라서 함수의 콜 스택과는 별개로 동작하며, 스택 오버플로우의 위험이 적습니다.

## 예제

```go
package main

import "fmt"

func BFS(graph map[string][]string, start string) {
    var queue []string
    visited := make(map[string]bool)

    // 큐를 기반으로 작동하므로, 큐에 첫 노드를 추가한다
    queue = append(queue, start)
    visited[start] = true

    for len(queue) > 0 {
        // 큐에서 노드를 꺼내 방문하고,
        vertex := queue[0]
        queue = queue[1:]
        fmt.Println(vertex)

        for _, neighbor := range graph[vertex] {
            if !visited[neighbor] {
                // 그 노드의 이웃을 큐에 추가하는 과정을 반복
                queue = append(queue, neighbor)
                visited[neighbor] = true
            }
        }
    }
}

func main() {
    graph := make(map[string][]string)
    graph["A"] = []string{"B", "C", "E"}
    graph["B"] = []string{"A", "D", "E"}
    graph["C"] = []string{"A", "F", "G"}
    graph["D"] = []string{"B"}
    graph["E"] = []string{"A", "B", "D"}
    graph["F"] = []string{"C"}
    graph["G"] = []string{"C"}

    BFS(graph, "A")
}
```
