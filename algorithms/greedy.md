# Greedy

## 탐욕 알고리즘

## 그리디 접근법의 최적성 증명: [Exchange Arguments](https://www.cs.cornell.edu/courses/cs482/2007su/exchange.pdf)

탐욕 알고리즘은 일반적으로 다음과 같은 형태를 갖습니다:
1. 매 단계에서 현 시점에서 최적이라고 판단되는 후보를 선택합니다.(국소적인 최적 선택)
2. 선택한 후보를 현재 해답에 추가해도 실현 가능성을 해치지 않는다면 추가합니다.
3. 완료되지 않았다면 반복합니다.

'탐욕 교환'은 탐욕 알고리즘의 정확성을 증명하는 데 사용되는 기법 중 하나입니다.
교환 증명의 아이디어는 다른 알고리즘으로 생성된 해답을 점진적으로 수정하여 여러분의 탐욕 알고리즘이 생성한 해답으로 변환하되,
그 과정에서 해답의 품질을 악화시키지 않는 방식으로 진행하는 것입니다.

> 교환 논증의 핵심은 탐욕 알고리즘이 선택한 해답이 최적해와 동일한지 증명하는 과정에서, 탐욕 해답과 다른 최적해를 점진적으로 탐욕 해답으로 변환하는 것입니다.

따라서 여러분의 해답의 품질은 다른 어떤 해답의 품질보다 적어도 같거나 더 좋습니다.
특히, 최적의 해답보다 적어도 같거나 더 좋기 때문에, 여러분의 알고리즘은 실제로 최적의 해답을 반환한다고 할 수 있습니다.

교환 논증의 핵심 아이디어:
1. 최적해가 존재한다고 가정합니다.
2. 이 최적해가 우리의 탐욕적 해법과 다르다면, 최적해를 조금씩 수정해 나갑니다.
3. 각 수정 단계에서 해의 품질이 나빠지지 않음을 보입니다.
4. 결국 최적해가 우리의 탐욕적 해법과 같아짐을 보입니다.

알고리즘을 설명한 후, 교환 논증 증명을 위한 3가지 주요 단계는 다음과 같습니다:

1. 알고리즘의 해답과 일반 해답에 레이블 지정

    예를 들어,

    A = {a1, a2, ..., ak}를 여러분의 알고리즘이 생성한 해답이라 하고,

    O = {o1, o2, ..., om}을 임의의(또는 최적의) 실현 가능한 해답이라고 합시다.

2. 탐욕 해답과 다른 해답 비교

    임의의/최적의 해답이 여러분의 탐욕 해답과 같지 않다고 가정합니다(같다면 증명이 끝납니다).
    일반적으로 이 차이의 간단한 예를 다음과 같이 분리할 수 있습니다:
    - O에는 있지만 A에는 없는 요소와 A에는 있지만 O에는 없는 요소가 있다.
    - O에 있는 두 개의 연속된 요소가 A에서는 다른 순서로 되어 있다(즉, 역전이 있다).

3. 교환

    O에서 해당 요소들을 교환합니다(첫 번째 경우라면 한 요소를 빼고 다른 요소를 넣거나, 두 번째 경우라면 요소들의 순서를 바꿉니다).
    그리고 이전보다 나빠지지 않은 해답을 얻었다고 주장합니다.
    그 다음, 계속해서 교환을 수행하면 해답의 품질을 악화시키지 않으면서 다항 시간 내에 O와 A 사이의 모든 차이를 제거할 수 있다고 주장합니다.
    따라서, 생성된 탐욕 해답은 최적의(또는 임의의) 해답만큼 좋으며, 그러므로 그 자체로 최적입니다.

다음 사항들에 주의합니다:

1. G ≠ O라는 가정으로 시작하는 모순 증명을 사용할 때 주의해야 합니다.

    탐욕 해답이 선택한 최적 해답과 같지 않다고 해서 탐욕 해답이 최적이 아니라는 뜻은 아닙니다.
    여러 개의 최적 해답이 존재할 수 있으며, 탐욕 해답은 그중 하나일 수 있습니다.
    하지만 최종적으로 탐욕 해답이 최적해임을 증명하려면, 교환을 통해 최적해와 탐욕 해답이 같아짐을 보여야 합니다.
    따라서 G ≠ O를 가정하는 것만으로는 모순에 도달하지 않을 수 있습니다.

2. 교환하려는 두 요소가 왜 순서가 다르거나, 왜 O에는 있지만 A에는 없는 등의 상황이 발생하는지 등을 설명해야 합니다.

3. 선택한 해답에서 탐욕 해답으로 여러 번의 교환을 통해 도달할 수 있다는 점을 주장해야 합니다.

    대부분의 경우 한 번의 교환으로는 충분하지 않습니다.
    또한, 첫 번째 단계뿐만 아니라 모든 단계에서 해답의 품질을 해치지 않는다는 점을 확인해야 합니다.

### 교환 논증 과정

'최적해 O가 존재한다고 가정'한다는 말은
- 실제로 그 최적해를 알고 있다는 뜻이 아니며, 이는 증명을 위한 논리적 가정입니다.
- "만약 이 알고리즘보다 더 좋은 해가 있다면, 그것을 이 알고리즘의 해로 점진적으로 변환할 수 있고, 그 과정에서 해의 품질이 나빠지지 않는다"는 것을 보이기 위한 논리적 장치입니다.

최적해의 구체적인 모습을 모르지만, 그것이 *존재한다고 가정하고 논리를 전개*합니다.

따라서 아래 예시에서 사용된 `O: [5, 4, 2, 2]`는 단순히 설명을 위해 임의로 선택한 가상의 '최적해'입니다.
실제 최적해가 이와 다를 수 있습니다.

- 문제: n개의 양의 정수가 주어졌을 때, k번의 연산으로 제곱의 합을 최소화하려 합니다. 각 연산은 하나의 수를 1 감소시킵니다.
- 예시: n = 4, k = 3인 경우를 고려해봅시다.
- 초기 상태: [5, 4, 3, 2]

초기 상태에서 3번의 연산을 수행하여 제곱의 합을 줄여야 합니다.
*가장 큰 수를 줄이는** 것을 **탐욕적 선택 기준**으로 정합니다.

여기서 **"가장 큰 수를 줄인다"**는 것은 탐욕적 해법의 휴리스틱에 해당하며, 교환 논증은 탐욕 알고리즘의 선택이 최적임을 증명하기 위한 과정입니다.

```java
초기 상태: [5, 4, 3, 2]
각 원소의 제곱합: 5^2 + 4^2 + 3^2 + 2^2 = 25 + 16 + 9 + 4 = 54

// 가장 큰 값인 5를 1 감소시킵니다:
변경: [5 -> 4]
변경 후 배열: [4, 4, 3, 2]
새로운 제곱합: 4^2 + 4^2 + 3^2 + 2^2 = 16 + 16 + 9 + 4 = 45

//두 번째로 가장 큰 값인 4를 다시 줄입니다:
변경: [4 -> 3]
변경 후 배열: [3, 4, 3, 2]
새로운 제곱합: 3^2 + 4^2 + 3^2 + 2^2 = 9 + 16 + 9 + 4 = 38

// 마지막으로 4를 다시 줄입니다:
변경: [4 -> 3]
변경 후 배열: [3, 3, 3, 2]
새로운 제곱합: 3^2 + 3^2 + 3^2 + 2^2 = 9 + 9 + 9 + 4 = 31

전체 과정을 정리하자면 다음과 같습니다:

초기 상태: [5, 4, 3, 2] -> 제곱합: 54
1. 첫 번째 연산: [4, 4, 3, 2] -> 제곱합: 45
2. 두 번째 연산: [3, 4, 3, 2] -> 제곱합: 38
3. 세 번째 연산: [3, 3, 3, 2] -> 제곱합: 31
```

여기서 중요한 점은 **큰 값을 줄이는 것이 작은 값을 줄이는 것보다 항상 더 효율적**이라는 것입니다.
각 연산 단계에서 가장 큰 값을 줄임으로써 제곱합을 효과적으로 줄일 수 있습니다.

#### *가장 큰 수를 줄이는 것*을 *탐욕적 선택 기준*으로 정하는 이유

이 문제에서, 가장 큰 수를 줄이는 것이 더 나은 선택인 이유는 *수학적 변화율*에 근거하고 있습니다.
각 수의 제곱합을 최소화해야 하므로, *어떤 수를 줄였을 때 제곱합이 얼마나 변하는지*를 비교해보면 명확해집니다.

예를 들어, 배열에 두 수 $a$와 $b$가 있다고 가정하고, $a > b$입니다.
이때, 각각의 수를 1씩 줄이면 제곱합은 다음과 같이 변합니다:

- $a^2 - (a-1)^2 = 2a - 1$
- $b^2 - (b-1)^2 = 2b - 1$

*큰 수를 줄였을 때 감소 폭이 더 크다*는 점은 이 차이를 보면 명확합니다.
$a > b$이므로, **2a - 1**은 **2b - 1**보다 큽니다.
즉, *큰 수를 줄였을 때 제곱합이 더 많이 감소*합니다.

이 수학적 근거가 바로 **가장 큰 수를 줄이는 탐욕적 선택**이 최적화에 유리한 이유입니다.

이 문제에서 목표는 *제곱합을 최소화*하는 것입니다.
따라서, 각 연산에서 제곱합을 가능한 한 많이 줄이는 선택을 해야 합니다.
앞서 살펴본 대로, *큰 값을 줄이는 것이 제곱합을 더 많이 줄이는 방법*입니다.

### Exchange Arguments 예제1: 활동 선택 문제(Activity Selection Problem)

> n개의 활동이 주어지며, 각 활동은 *시작 시간 `si`*와 *종료 시간 `fi`*를 가집니다.
> 목표는 서로 겹치지 않는 최대 개수의 활동을 선택하는 것입니다.

활동들을 종료 시간 `fi`에 따라 정렬하고, 가장 일찍 끝나는 활동부터 선택합니다.
이후 선택한 활동과 겹치지 않는 다음 활동을 계속해서 선택합니다.

이에 대해 교환 논증 증명을 해보면 아래와 같습니다:

1. 레이블 지정
    - A = {a1, a2, ..., ak}: 탐욕 알고리즘으로 선택한 활동들
    - O = {o1, o2, ..., om}: 최적의 해답

2. 비교

    A와 O가 다르다고 가정합니다.
    그렇다면 A에는 있지만 O에는 없는 활동이 존재합니다.
    이 중 가장 일찍 끝나는 활동을 `ai`라고 합시다.

3. 교환:

    O에서 `ai`와 겹치는 활동 `oj`를 `ai`로 교체합니다.
    이때, `ai`는 `oj`보다 일찍 끝나기 때문에 `oj`가 차지하던 자리를 대체할 수 있으며,
    그 이후의 다른 활동들과 겹치지 않음을 보장합니다.
    이 교환을 반복하여 모든 차이를 제거할 수 있습니다.

교환 후 논증:
1. 이 교환은 O의 활동 수를 줄이지 않습니다 (하나를 빼고 하나를 넣었으므로).
2. `ai`는 `oj`보다 일찍 끝나므로, 이 교환은 O의 다른 활동들과의 겹침을 새로 만들지 않습니다.
3. 이 과정을 반복하면 결국 O는 A와 동일해집니다.

따라서 탐욕 알고리즘의 해답 A는 최적해 O와 적어도 같은 수의 활동을 포함하며, 이는 A도 최적해라는 것을 의미합니다.

### Exchange Arguments 예제2: [제곱의 합 최소화](./programmers/src/main/java/p12927/Main.java)

"매 순간 가장 큰 값을 차감하는 것"이 최적해를 보장한다는 것은 수학적으로 증명할 수 있습니다.
이를 "교환 논증(Exchange Argument)"이라고 합니다.

증명:
두 개의 양의 정수 $a$와 $b$가 있고 $a > b$라고 가정합시다.
*큰 수를 줄이고 작은 수를 늘리는 것이 항상 제곱의 합을 줄인다*는 것을 보이기 위해,
여기서 $a^{2} \; + \; b^{2} > (a-1)^{2}+(b+1)^{2}$임을 증명합니다.

$$
a^{2}+b^{2} \\
= (a - 1 + 1)^{2}+(b+1)^{2} \\
= (a - 1)^{2} + 2(a - 1) + 1 + b^{2} \\
$$
$$
(a - 1)^{2} + (b + 1)^{2} \\
= (a - 1)^{2} + b^{2} + 2b + 1 \\
$$

두 식의 차이는

$$
((a - 1)^{2} + 2(a - 1) + 1 + b^{2}) \; \\
- \; ((a - 1)^{2} + b^{2} + 2b + 1) \\
= \; 2(a - 1) - 2b \\
= \; 2(a - b - 1) > 0 \; (a > b)
$$

따라서 항상 $a^{2} \; + \; b^{2} > (a-1)^{2}+(b+1)^{2}$입니다.
이는 큰 수를 줄이고 작은 수를 늘리는 것이 항상 제곱의 합을 줄인다는 것을 의미합니다.

이 논리를 확장하면, 매 순간 가장 큰 값을 차감하는 것이 전체 제곱의 합을 최소화하는 최적의 전략임을 알 수 있습니다.

이를 Exchange Arguments로 증명하면 아래와 같습니다.

- 문제:

    n개의 양의 정수가 주어졌을 때, k번의 연산으로 제곱의 합을 최소화하려 합니다.
    각 연산은 하나의 수를 1 감소시킵니다.

- 탐욕적 해법: 매번 가장 큰 수를 1 감소시킵니다.

- 교환 논증 적용:

    1. 최적해 O가 존재한다고 가정합니다.
    2. O가 탐욕적 해법 G와 다르다고 가정합니다.
    3. O에서 G와 다른 부분을 찾습니다. 즉, O에서는 작은 수를 줄였지만 G에서는 큰 수를 줄인 경우를 찾습니다.
    4. O에서 이 부분을 G와 같게 수정합니다. 즉, 작은 수를 줄이는 대신 큰 수를 줄입니다.
    5. 이 수정이 해의 품질을 개선함을 보입니다.

결론:
1. 최적해 O를 우리의 탐욕적 해법 G와 같아질 때까지 계속 수정할 수 있습니다.
2. 각 수정 단계에서 해의 품질이 개선됩니다.
3. 이 과정을 통해 탐욕 해법 G는 최적해 O와 동일한 해답을 생성함을 알 수 있습니다. 각 교환 단계에서 해답의 품질이 나빠지지 않기 때문에, 탐욕 해법 G는 최적해임을 증명할 수 있습니다.

### 모든 경우의 수를 고려하는 방식의 문제점

조합 최적화 문제로 접근하여 모든 경우의 수를 고려하는 방식에는 다음과 같은 문제가 있습니다:

a. 시간 복잡도:
- 작업의 수가 m이고, 차감할 수 있는 시간이 n이라면, 가능한 모든 조합의 수는 대략 m^n입니다.
- 예를 들어, m=20(작업의 최대 개수)이고 n=1,000,000(최대 시간)이라면, 경우의 수는 20^1,000,000으로 엄청나게 큽니다.
- 이는 현실적으로 계산 불가능한 수준의 복잡도입니다.

b. 공간 복잡도:
- 모든 경우의 수를 저장하려면 엄청난 양의 메모리가 필요합니다.

c. 불필요한 계산:
- 그리디 접근법이 최적해를 보장하는 이 문제의 특성상, 모든 경우를 고려하는 것은 불필요한 계산을 하는 것입니다.

따라서, 이 문제에서는 그리디 알고리즘을 사용하는 것이 훨씬 효율적이고 실용적인 접근 방법입니다. 시간 복잡도는 O(n log m)으로, 주어진 제약 조건 내에서 충분히 빠르게 동작합니다.

이러한 분석을 통해, 우리는 문제의 특성을 이해하고 가장 적절한 해결 방법을 선택할 수 있습니다. 항상 모든 경우를 고려하는 것이 최선은 아니며, 때로는 문제의 특성을 활용한 효율적인 알고리즘이 더 좋은 해결책이 될 수 있습니다.

## [미로 탈출 명령어](https://school.programmers.co.kr/learn/courses/30/lessons/150365?language=go)

### 미로에 벽과 같은 제한 사항이 일절 존재하지 않는다

일단 여기부터 의심해야 합니다. 보통의 완탐문제는 벽과 같은 장애물이 나타나는데, 문제는 정말 깔끔하게 아무런 제약사항이 없습니다.
이는 항상 매번 벽에 대한 조건을 체크하지 않아도 된다는 의미이며, 일일히 한 칸씩 탐색 할 필요가 없다는 의미가 됩니다.

### 목표와의 이동 횟수를 이미 알고 있다

이미 문제에서 k라고 주어졌습니다. 이를 사용하여, 남은 거리를 계산하고 해당 방향으로 이동가능한지 유추가 가능합니다.

### 답은 무조건 사전순이다

답이 사전순으로 들어가므로, 'd', 'l', 'r', 'u' 순서의 탐색으로 이루어져야 합니다.
즉, 현재 위치에서, 저 순서대로 탐색하여, 갈 수 있는 조건이 되면, 바로 가면 됩니다.
항상 사전순으로 가야 하므로, 항상 저 순서대로 탐색하고, 조건에 되면 빠져나가면 됩니다.

### 해당 방향으로 가는 것이 옳은 방향인지 미리 판단이 가능하다

지금까지 이동한 거리에서 현재이동한 거리 1을 더하고, 새로운 위치에서 목표지점까지의 위치를 더한 값이 k를 넘기게 되면, 더 이상 이동이 힘들다는 사실을 알 수 있습니다.
이와 같은 판단이 가능하기에, 항상 해당 턴마다 가장 탐욕적인 선택을 수행 할 수 있게됩니다.

## 기타

- [탐욕 알고리즘 분석하기 (Correctness of Greedy Algorithms)](https://gazelle-and-cs.tistory.com/59)
