# Backtracking

- [Backtracking](#backtracking)
    - [백트래킹 (Backtracking)](#백트래킹-backtracking)
        - [백트래킹이란 단어의 의미](#백트래킹이란-단어의-의미)
    - [백트래킹의 동작 원리](#백트래킹의-동작-원리)
    - [백트래킹의 사용 사례](#백트래킹의-사용-사례)
    - [백트래킹이 고안된 이유](#백트래킹이-고안된-이유)
    - [코드 구현 예시 (N-Queens 문제)](#코드-구현-예시-n-queens-문제)
    - [상태 복원](#상태-복원)

## 백트래킹 (Backtracking)

백트래킹은 조합 최적화 문제를 해결하기 위한 알고리즘 기법으로,
가능한 모든 해결책을 체계적으로 탐색하면서 불필요한 탐색 경로를 조기에 차단하는 방식입니다.

"시행착오"를 통해 문제를 해결하는 방법으로, 복잡한 문제를 효율적으로 해결할 수 있게 해줍니다.

백트래킹은 결정 트리를 깊이 우선 탐색(DFS)하는 방식으로 동작하며, 특정 조건을 만족하지 않는 경로는 더 이상 탐색하지 않고 이전 단계로 돌아가(backtrack) 다른 경로를 탐색합니다.

주요 원리:
- 점진적 해 구성: 부분 해를 단계적으로 구성
- 제약 조건 검사: 각 단계에서 해의 유효성 검사
- 가지치기(Pruning): 유망하지 않은 경로 제거
- 되돌아가기(Backtracking): 이전 단계로 돌아가 다른 선택 탐색

### 백트래킹이란 단어의 의미

"Backtrack"은 원래 "되돌아가다" 또는 "역추적하다"라는 의미를 가진 일반적인 영어 단어입니다.
- "Back"(뒤로)는 이전 상태로 돌아가는 것을 의미합니다.
- "Track"(추적)은 해결책을 찾아가는 과정을 나타냅니다.
- 합쳐서 "Backtrack"은 "해결책을 찾아가다가 막히면 뒤로 돌아가 다시 시도한다"는 의미를 갖게 됩니다.
이는 보통 자신의 발자취를 따라 돌아가는 행위를 묘사할 때 사용됩니다.

[컴퓨터 과학에서 퇴각검색(backtracking)](https://ko.wikipedia.org/wiki/%ED%87%B4%EA%B0%81%EA%B2%80%EC%83%89)이라는 용어는 1950년대 후반에 처음 사용되기 시작했다고 합니다.
특히, 미국의 수학자이자 컴퓨터 과학자인 D.H. Lehmer가 1958년에 이 개념을 소개했다고 알려져 있습니다.

퇴각검색(backtracking)은 문제 해결 알고리즘의 한 유형을 설명하는 데 사용됩니다.
이 알고리즘은 *가능한 해결책을 점진적으로 만들어가다가, 현재의 부분 해결책이 유망하지 않다고 판단되면 이전 상태로 "되돌아가" (backtrack) 다른 대안을 시도*합니다.
즉, "시도하고, 실패하면 되돌아가 다시 시도"합니다.

백트래킹은 두 가지 측면을 갖습니다:
- 가지치기 (Pruning): 더 이상 유망하지 않은 경로를 포기하고 이전 상태로 돌아가는 것
- 상태 복원 (State Restoration): 이전 상태로 돌아갈 때 모든 변경사항을 되돌리는 것

가령 미로에서 막다른 길에 도달하면 이전 갈림길로 되돌아가 다른 경로를 시도하는 것과 유사합니다.
체스와 같은 게임의 전략에서도 유사한 개념이 사용되었습니다.
특정 수를 두었다가 불리하다고 판단되면 이전 상태로 돌아가 다른 수를 고려하는 방식입니다.

## 백트래킹의 동작 원리

1. 해 공간 트리 구성:
   문제의 모든 가능한 해를 트리 형태로 구조화합니다.

2. 깊이 우선 탐색(DFS):
   트리를 DFS 방식으로 탐색하며 해를 구성합니다.

3. 제약 조건 검사:
   각 노드에서 현재까지의 부분 해가 제약 조건을 만족하는지 검사합니다.

4. 가지치기:
   제약 조건을 위반하는 경우, 해당 경로의 탐색을 중단하고 다른 경로로 전환합니다.

5. 백트래킹:
   더 이상 탐색할 경로가 없으면 이전 단계로 돌아가 다른 선택을 탐색합니다.

ASCII 다이어그램으로 백트래킹 과정을 시각화해보겠습니다:

```plaintext
        Root
    /    |     \
   A     B      C
  / \   / \    / \
 D   E F   G  H   I
    /
   J

탐색 순서:
    Root -> A -> D (제약 조건 위반) -> E로 backtrack
            A -> E -> J (해 발견 또는 제약 조건 위반) -> E로 backtrack
            A -> E (더 이상 자식 없음) -> A로 backtrack
            A (더 이상 자식 없음) -> Root로 backtrack
    Root -> B -> F ...
```

이 다이어그램에서:
- 각 노드는 선택 가능한 옵션을 나타냅니다.
- 탐색은 깊이 우선으로 진행됩니다.
- D에서 제약 조건 위반 시, E로 백트래킹합니다.
- J에서 해를 찾거나 제약 조건 위반 시, E로 백트래킹합니다.
- E에서 더 이상 탐색할 자식이 없으면 A로 백트래킹합니다.

## 백트래킹의 사용 사례

1. N-Queens 문제는 N x N 체스판에 N개의 퀸을 서로 공격할 수 없게 배치하는 문제입니다.

    ```plaintext
    . Q . .
    . . . Q
    Q . . .
    . . Q .
    ```

2. 스도쿠 풀이는 9x9 그리드를 규칙에 맞게 숫자로 채우는 문제입니다.

    ```plaintext
    5 3 . | . 7 . | . . .
    6 . . | 1 9 5 | . . .
    . 9 8 | . . . | . 6 .
    ------+-------+------
    8 . . | . 6 . | . . 3
    4 . . | 8 . 3 | . . 1
    7 . . | . 2 . | . . 6
    ------+-------+------
    . 6 . | . . . | 2 8 .
    . . . | 4 1 9 | . . 5
    . . . | . 8 . | . 7 9
    ```

3. 부분 집합의 합은 주어진 집합에서 특정 합을 만족하는 부분 집합 찾는 문제입니다.

    ```plaintext
    집합: {1, 2, 3, 4, 5}
    목표 합: 7

    해: {2, 5}, {1, 2, 4}, {3, 4}
    ```

4. 그래프 색칠하기는 인접한 노드가 다른 색을 갖도록 그래프의 노드 색칠하는 문제입니다.

    ```plaintext
        A---B
       / \   \
      C---D---E

    A: 빨강, B: 파랑, C: 파랑, D: 초록, E: 빨강
    ```

5. 미로 찾기는 시작점에서 도착점까지의 경로 찾는 문제입니다.

    ```plaintext
    S # . . .
    . # . # .
    . . . # .
    # # . . .
    # # . # E

    S: 시작, E: 도착, #: 벽, .: 이동 가능
    ```

## 백트래킹이 고안된 이유

1. 완전 탐색의 비효율성 극복:
    - 모든 가능한 경우를 무차별적으로 탐색하는 것은 대부분의 실제 문제에서 비현실적입니다.
    - 백트래킹은 불필요한 탐색을 줄여 효율성을 크게 향상시킵니다.

2. 복잡한 제약 조건 처리:
    - 많은 실제 문제는 복잡한 제약 조건을 가지고 있습니다.
    - 백트래킹은 이러한 제약 조건을 효과적으로 처리할 수 있는 유연한 방법을 제공합니다.

3. 최적화 문제 해결:
    - 많은 최적화 문제는 가능한 모든 해를 탐색해야 합니다.
    - 백트래킹은 이러한 탐색을 체계적이고 효율적으로 수행할 수 있게 해줍니다.

4. 휴리스틱 적용 가능성:
    - 백트래킹 알고리즘에 문제 특화 휴리스틱을 쉽게 통합할 수 있습니다.
    - 이를 통해 더욱 효율적인 탐색이 가능합니다.

## 코드 구현 예시 (N-Queens 문제)

```java
public class NQueens {
    private int N;
    private int[][] board;

    public NQueens(int N) {
        this.N = N;
        this.board = new int[N][N];
    }

    /**
     * N-Queens 문제를 해결하는 메인 메서드
     *
     * @return 해결책을 찾으면 true, 그렇지 않으면 false
     */
    public boolean solve() {
        return solveNQueens(0);
    }

    /**
     * 백트래킹을 사용하여 N-Queens 문제를 재귀적으로 해결
     *
     * @param col 현재 처리 중인 열
     * @return 해결책을 찾으면 true, 그렇지 않으면 false
     */
    private boolean solveNQueens(int col) {
        // 기저 조건: 모든 열에 퀸을 배치했다면 해결책 찾음
        if (col >= N) {
            return true;
        }

        // 현재 열의 각 행에 퀸 배치 시도
        for (int row = 0; row < N; row++) {
            // 현재 위치가 안전한지 확인
            if (isSafe(row, col)) {
                // 퀸 배치
                board[row][col] = 1;

                // 재귀적으로 다음 열에 퀸 배치 시도
                if (solveNQueens(col + 1)) {
                    return true;
                }

                // 백트래킹: 현재 배치가 해결책으로 이어지지 않으면 퀸 제거
                board[row][col] = 0;
            }
        }

        // 현재 열에서 안전한 위치를 찾지 못함
        return false;
    }

    /**
     * 주어진 위치에 퀸을 배치할 수 있는지 확인
     *
     * @param row 확인할 행
     * @param col 확인할 열
     * @return 안전하면 true, 그렇지 않으면 false
     */
    private boolean isSafe(int row, int col) {
        // 같은 행에 퀸이 있는지 확인
        for (int i = 0; i < col; i++) {
            if (board[row][i] == 1) {
                return false;
            }
        }

        // 왼쪽 위 대각선 확인
        for (int i = row, j = col; i >= 0 && j >= 0; i--, j--) {
            if (board[i][j] == 1) {
                return false;
            }
        }

        // 왼쪽 아래 대각선 확인
        for (int i = row, j = col; i < N && j >= 0; i++, j--) {
            if (board[i][j] == 1) {
                return false;
            }
        }

        return true;
    }

    /**
     * 현재 체스판 상태를 출력
     */
    public void printSolution() {
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                System.out.print(board[i][j] == 1 ? "Q " : ". ");
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        NQueens nQueens = new NQueens(4);
        if (nQueens.solve()) {
            System.out.println("해결책 찾음:");
            nQueens.printSolution();
        } else {
            System.out.println("해결책 없음");
        }
    }
}
```

이 코드에서:
- `solveNQueens` 메서드가 백트래킹의 핵심입니다.
- `isSafe` 메서드는 제약 조건을 검사합니다.
- 퀸을 배치하고 (`board[row][col] = 1`), 다음 열로 진행합니다.
- 해결책을 찾지 못하면 퀸을 제거하고 (`board[row][col] = 0`) 다른 위치를 시도합니다.

이 예시는 백트래킹의 주요 특성인 점진적 해 구성, 제약 조건 검사, 가지치기, 그리고 되돌아가기를 모두 보여줍니다.

## 상태 복원

백트래킹의 두 가지 측면:
1. 조건에 해당하지 않으면 빠르게 리턴하는 것 (가지치기, pruning)
2. 탐색 후 상태를 원래대로 되돌리는 것 (상태 복원)

"조건에 해당하지 않으면 빠르게 리턴하는 것"은 백트래킹의 한 측면인 가지치기(pruning)에 해당합니다. 이는 불필요한 탐색을 줄이는 최적화 기법입니다.

```java
function generateNumbers(현재_조합, 남은_숫자들, 사용된_숫자들):
    if 현재_조합이 비어있지 않음:
        소수인지 확인하고 결과에 추가

    for i = 0 to 남은_숫자들의 길이 - 1:
        if 사용된_숫자들[i] == false:
            사용된_숫자들[i] = true
            generateNumbers(현재_조합 + 남은_숫자들[i], 남은_숫자들, 사용된_숫자들)
            사용된_숫자들[i] = false  // 백트래킹
```

반면 코드에서 보이는 `사용된_숫자들[i] = false`는 백트래킹의 두 번째 측면인 '상태 복원'에 해당합니다. 이 과정을 통해 다음과 같은 이점을 얻을 수 있습니다:

1. **상태 재사용**: 동일한 배열을 재사용하여 메모리를 절약합니다.
2. **탐색 공간 확장**: 모든 가능한 조합을 탐색할 수 있게 합니다.

예를 들어, "123"이라는 입력이 있다고 가정했을 때, 백트래킹의 동작 방식은 다음과 같습니다.
(`*`는 선택했음을 나타냅니다.)

```plaintext
Step 1:
     *
    "123"
    [T, F, F]

    조합: ("1")

Step 2:
     **
    "123"
    [T, T, F]

    조합: ("1", "12")

Step 3:
     ***
    "123"
    [T, T, T]

    조합: ("1", "12", "123")

Step 4: 백트래킹으로 "3" 선택 해제
     **
    "123"
    [T, T, F]

    이제 "12" 다음에 다른 선택을 할 수 있습니다.
    하지만 이제 다른 숫자가 없으므로 return 합니다.

    조합: ("1", "12", "123")

Step 5: 백트래킹으로 "2" 선택 해제
     *
    "123"
    [T, F, F]

    조합: ("1", "12", "123")

    이제 "1" 다음에 다른 선택을 할 수 있습니다.
    "3"이 있으므로 "3"을 선택합니다.

Step 6:
     * *
    "123"
    [T, F, T]

    조합: ("1", "12", "123", "13") // 추가된 숫자 없음

Step 7: 백트래킹으로 "3" 선택 해제
     *
    "123"
    [T, F, F]

    조합: ("1", "12", "123", "13") // 추가된 숫자 없음

    이제 "1" 다음에 다른 선택을 할 수 있습니다.
    하지만 이제 다른 숫자가 없으므로 return 합니다.

Step 8: 백트래킹으로 "1" 선택 해제

    "123"
    [F, F, F]

    조합: ("1", "12", "123", "13") // 추가된 숫자 없음

    "1" 노드를 시작으로 하는 DFS가 완료됐습니다.
    다음 단계에서 "2" 노드를 시작점으로 하는 DFS를 시작합니다.

Step 9:
      *
    "123"
    [F, T, F]

    조합: ("1", "12", "123", "13", "2")

Step 10:
      **
    "123"
    [F, T, T]

    조합: ("1", "12", "123", "13", "2", "23")

Step 11: 백트래킹으로 "3" 선택 해제
      *
    "123"
    [F, T, F]

    조합: ("1", "12", "123", "13", "2", "23") // 추가된 숫자 없음

    이제 "2" 다음에 다른 선택을 할 수 있습니다.
    하지만 이제 다른 숫자가 없으므로 return 합니다.

Step 12: 백트래킹으로 "2" 선택 해제

    "123"
    [F, F, F]

    조합: ("1", "12", "123", "13", "2", "23") // 추가된 숫자 없음

    "2" 노드를 시작으로 하는 DFS가 완료됐습니다.
    다음 단계에서 "3" 노드를 시작점으로 하는 DFS를 시작합니다.

Step 13:
       *
    "123"
    [F, F, T]

    조합: ("1", "12", "123", "13", "2", "23", "3")

Step 14: 백트래킹으로 "3" 선택 해제

    "123"
    [F, F, F]

    조합: ("1", "12", "123", "13", "2", "23", "3")

    "3" 노드를 시작으로 하는 DFS가 완료됐습니다.
    시작점으로 삼을 노드가 없으므로 종료합니다.

완료
```

여기서 트래킹은 '상태 복원'을 통해 모든 가능한 조합을 효율적으로 탐색하는 데 사용되고 있습니다.
