# DFS

- [DFS](#dfs)
    - [DFS?](#dfs-1)
    - [동작 방식](#동작-방식)
    - [특징](#특징)
        - [DFS 사용이 적합한 문제](#dfs-사용이-적합한-문제)
    - [장점](#장점)
    - [공간 복잡도: `O(V)`](#공간-복잡도-ov)
    - [시간 복잡도: `O(V + E)`](#시간-복잡도-ov--e)
    - [함수의 콜 스택](#함수의-콜-스택)
    - [구현](#구현)
    - [예제](#예제)
        - [기본 예제](#기본-예제)

## DFS?

Depth First Search, 말 그대로 **깊이**를 우선 탐색하는 알고리즘입니다.

*노드와 엣지로 구성된 그래프나 트리를 탐색*하기 위한 알고리즘 중 하나로, DFS는 그래프의 *모든 노드를 방문*하고자 할 때 사용합니다.

기본적인 탐색 방식은 다음과 같습니다:
- 시작 노드에서 출발하여 갈 수 있는 경로가 있는 노드까지 최대한 깊게 들어가며 탐색을 진행
- 경로가 더 이상 없거나 목표 노드에 도달하면 리턴하여 다른 경로를 탐색
- 이 과정을 모든 노드를 방문할 때까지 반복

## 동작 방식

```java
/**
 * @param 그래프 탐색할 그래프 구조
 * @param 시작_노드 탐색을 시작할 노드
 */
function DFS(그래프, 시작_노드):
    방문_기록 = set()
    DFS_재귀(그래프, 시작_노드, 방문_기록)

/**
 * @param 그래프 탐색할 그래프 구조
 * @param 현재_노드 현재 탐색 중인 노드
 * @param 방문_기록 이미 방문한 노드들의 집합
 */
function DFS_재귀(그래프, 현재_노드, 방문_기록):
    if 현재_노드 not in 방문_기록:
        print(현재_노드)  // 노드 방문
        방문_기록.add(현재_노드)

        for 이웃_노드 in 그래프[현재_노드]:
            DFS_재귀(그래프, 이웃_노드, 방문_기록)

// 실행
그래프 = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': ['G'],
    'F': [],
    'G': []
}
DFS(그래프, 'A')
```

```plaintext
Init:    A
        / \
       B   C
      / \   \
     D   E   F
        /
       G

Step 1:   A*
         / \
        B   C
       / \   \
      D   E   F
         /
        G
     (방문: A)

Step 2:   A*
         / \
        B*  C
       / \   \
      D   E   F
         /
        G
     (방문: A,B)


Step 3:   A*
         / \
        B*  C
       / \   \
      D*  E   F
         /
        G
    (방문: A,B,D)
    D가 마지막 노드이므로 return하여 다시 B로 돌아갑니다.

Step 4:   A*
         / \
        B*  C
       / \   \
      D*  E*  F
         /
        G
    (방문: A,B,D,E)

Step 5:   A*
         / \
        B*  C
       / \   \
      D*  E*  F
         /
        G*
  (방문: A,B,D,E,G)
  G가 마지막 노드이므로 return하여 다시 E로 돌아갑니다.
  E는 방문 동작이 끝났으므로 return하여 다시 B로 돌아갑니다.
  B는 방문 동작이 끝났으므로 return하여 다시 A로 돌아갑니다.


Step 6:   A*
         / \
        B*  C*
       / \   \
      D*  E*  F
         /
        G*
  (방문: A,B,D,E,G,C)

Step 8:   A*
         / \
        B*  C*
       / \   \
      D*  E*  F*
         /
        G*
  (방문: A,B,D,E,G,C,F)
  F가 마지막 노드이므로 return하여 다시 C로 돌아갑니다.
  C는 방문 동작이 끝났으므로 return하여 다시 A로 돌아갑니다.
  모든 탐색이 끝납니다.
```

## 특징

- *한 경로를 끝까지 탐색*한 후 다른 경로로 이동합니다.

- *모든 가능한 경로를 탐색*합니다.
    탐색 공간이 넓고, 가능한 모든 경로를 고려해야 하는 문제에 적합합니다.

- 사이클이 없는 그래프(예: 트리)에서 효율적히며, 사이클이 있는 경우 추가적인 로직이 필요합니다.

- 메모리 효율적입니다.
    현재 경로의 노드들만 기억하면 되므로 일반적으로 BFS보다 메모리 사용이 적습니다.

- [백트래킹](./backtracking.md)을 사용하여 막힌 경로에서 이전 분기점으로 쉽게 돌아갈 수 있습니다.

- DFS는 모든 레벨의 노드를 탐색하기 때문에, 해가 존재한다면 반드시 찾을 수 있습니다.

    단, 문제의 조건이나 구현 방법에 따라 DFS는 해를 찾지 못할 수도 있습니다.

    DFS가 깊이를 우선으로 탐색하다 보니, 어떤 조건을 만족하지 못하는 경로로 빠질 가능성이 있기 때문입니다.

- 그래프의 깊이가 무한한 경우 탐색이 종료되지 않을 수 있습니다.

- 재귀 또는 스택을 사용하여 구현할 수 있습니다. 재귀도 결국 시스템 콜 스택 활용이므로, 결국 스택을 통해 구현됩니다.

### DFS 사용이 적합한 문제

1. 경로 탐색 문제:
    - 특징: 시작점에서 목표점까지의 경로를 찾는 문제
    - 예: 미로 찾기, 게임의 상태 공간 탐색, 단어 찾기 퍼즐 등

    깊이 우선으로 탐색하므로 목표에 빠르게 도달할 가능성이 높습니다.

    ```java
    /**
    - @param 현재_노드 탐색 중인 현재 위치
    - @param 목표_노드 찾으려는 최종 목표 위치
    - @param 방문_기록 이미 탐색한 노드를 기록하는 집합으로 무한 루프를 방지
    - @param 현재_경로 시작 노드부터 현재 노드까지의 경로
    - @return 목표 노드에 도달하는 경로 또는 경로가 없을 경우 None
    */
    function DFS_경로찾기(현재_노드, 목표_노드, 방문_기록, 현재_경로):
        // 목표에 도달했는지 확인
        if 현재_노드 == 목표_노드:
            return 현재_경로

        // 현재 노드를 방문 기록에 추가
        방문_기록.add(현재_노드)

        // 현재 노드의 모든 이웃 노드를 탐색
        for 이웃_노드 in 현재_노드.이웃_목록:
            // 아직 방문하지 않은 이웃 노드에 대해서만 탐색 진행
            if 이웃_노드 not in 방문_기록:
                // 현재 경로에 이웃 노드를 추가한 새_경로 생성
                새_경로 = 현재_경로 + [이웃_노드]

                // 재귀적으로 다음 노드 탐색
                결과 = DFS_경로찾기(이웃_노드, 목표_노드, 방문_기록, 새_경로)

                // 목표를 찾았다면 결과 반환
                if 결과 is not None:
                    return 결과

        // 백트래킹: 현재 노드에서 목표를 찾지 못했으므로 이전 단계로 돌아감
        return None  // 경로를 찾지 못함
    ```

    [백트래킹](./backtracking.md)을 통해 막힌 경로에서 쉽게 되돌아갈 수 있습니다.
    DFS 코드를 보면 특정 노드에서 시작하여 깊이 우선으로 탐색을 진행합니다.
    만약 현재 경로에서 목표를 찾지 못하면 (`결과 is not None`이 아닌 경우), 함수는 `None`을 반환합니다.

    이 `return None` 반환이 백트래킹의 핵심입니다.
    이는 "이 경로에서는 목표를 찾지 못했으니, 이전 단계로 돌아가서 다른 경로를 탐색하라"는 의미입니다.
    함수 호출이 재귀적으로 이전 단계로 돌아가면서, 다음 이웃 노드를 탐색하게 됩니다.

2. 사이클 탐지:
    - 특징: 깊이 우선으로 탐색하며 이미 방문한 노드를 다시 만나면 사이클을 감지할 수 있습니다.
    - 예: 그래프 내 사이클 찾기

3. 위상 정렬:
    - 특징: 방향 그래프에서 노드들의 선행 순서를 정하는 문제, 노드 간의 의존성을 고려한 정렬에 유용합니다.
    - 예: 작업 스케줄링, 의존성 있는 빌드 시스템

    ```java
    /**
     * @param 그래프 정렬할 노드들과 그들의 의존성 관계를 나타내는 그래프
     * @return 위상 정렬된 노드들의 리스트
     */
    function 위상정렬(그래프):
        방문_기록 = set()
        정렬_결과 = []

        for 노드 in 그래프:
            if 노드 not in 방문_기록:
                DFS_위상정렬(노드, 그래프, 방문_기록, 정렬_결과)

        return reverse(정렬_결과)

    /**
     * @param 현재_노드 현재 탐색 중인 노드
     * @param 그래프 전체 그래프 구조
     * @param 방문_기록 이미 방문한 노드들의 집합
     * @param 정렬_결과 위상 정렬 결과를 저장할 리스트
     */
    function DFS_위상정렬(현재_노드, 그래프, 방문_기록, 정렬_결과):
        방문_기록.add(현재_노드)

        for 이웃_노드 in 그래프[현재_노드]:
            if 이웃_노드 not in 방문_기록:
                DFS_위상정렬(이웃_노드, 그래프, 방문_기록, 정렬_결과)

        정렬_결과.append(현재_노드)
    ```

4. 조합 최적화 문제
    - 특징: 모든 가능한 조합을 생성, 가능한 모든 조합 중 최적의 해를 찾는 데 유용합니다.
    - 예: 부분집합 생성, N-Queens 문제, 배낭 문제

    ```java
    /**
     * @param n 체스판의 크기와 퀸의 수
     * @return 가능한 모든 N-Queens 해결책의 수
     */
    function N_Queens(n):
        체스판 = [0] * n
        return DFS_N_Queens(체스판, 0, n)

    /**
     * @param 체스판 현재 퀸들의 배치 상태
     * @param 현재_행 현재 퀸을 배치하려는 행
     * @param n 체스판의 크기
     * @return 현재 상태에서 가능한 해결책의 수
     */
    function DFS_N_Queens(체스판, 현재_행, n):
        if 현재_행 == n:
            return 1  // 하나의 해결책을 찾음

        해결책_수 = 0
        for 열 in range(n):
            if 안전한_위치(체스판, 현재_행, 열):
                체스판[현재_행] = 열
                해결책_수 += DFS_N_Queens(체스판, 현재_행 + 1, n)

        return 해결책_수

    /**
     * @param 체스판 현재 퀸들의 배치 상태
     * @param 행 확인하려는 위치의 행
     * @param 열 확인하려는 위치의 열
     * @return 해당 위치가 안전한지 여부
     */
    function 안전한_위치(체스판, 행, 열):
        for i in range(행):
            if 체스판[i] == 열 or abs(체스판[i] - 열) == 행 - i:
                return false
        return true
    ```

    특히 백트래킹을 쉽게 구현할 수 있어 유망하지 않은 경로를 빠르게 포기할 수 있습니다.
    즉, 불필요한 탐색을 줄일 수 있습니다.

    또한 깊은 곳에 있는 해를 빠르게 찾을 수 있어, 조합 문제에서 유리합니다.

5. 그래프의 연결 요소 찾기
    - 특징: 그래프 내의 연결된 부분 그래프들을 식별하는 문제
    - 예: 소셜 네트워크의 커뮤니티 탐지

    ```java
    /**
     * @param 그래프 연결 요소를 찾을 그래프
     * @return 발견된 연결 요소들의 리스트
     */
    function 연결요소찾기(그래프):
        방문_기록 = set()
        연결_요소들 = []

        for 노드 in 그래프:
            if 노드 not in 방문_기록:
                현재_요소 = []
                DFS_연결요소(노드, 그래프, 방문_기록, 현재_요소)
                연결_요소들.append(현재_요소)

        return 연결_요소들

    /**
     * @param 현재_노드 현재 탐색 중인 노드
     * @param 그래프 전체 그래프 구조
     * @param 방문_기록 이미 방문한 노드들의 집합
     * @param 현재_요소 현재 구성 중인 연결 요소
     */
    function DFS_연결요소(현재_노드, 그래프, 방문_기록, 현재_요소):
        방문_기록.add(현재_노드)
        현재_요소.append(현재_노드)

        for 이웃_노드 in 그래프[현재_노드]:
            if 이웃_노드 not in 방문_기록:
                DFS_연결요소(이웃_노드, 그래프, 방문_기록, 현재_요소)
    ```

## 장점

- 구현이 상대적으로 간단합니다.
- 공간 복잡도가 BFS보다 일반적으로 좋습니다.
- 사이클을 찾거나, 경로의 존재 유무, 연결성 등을 체크하기 좋습니다.

## 공간 복잡도: `O(V)`

일반적으로 `O(V)`의 공간 복잡도(V = 그래프의 노드 수)를 갖습니다.
단, 그래프의 형태와 탐색의 순서에 따라 다를 수 있습니다.

재귀 함수 호출이나 명시적인 스택을 사용하므로 그래프의 깊이에 따라 공간이 필요합니다.

## 시간 복잡도: `O(V + E)`

모든 노드와 엣지를 한 번씩 방문하므로, `O(V + E)`입니다.
- `V` = 노드 수
- `E` = 엣지(간선) 수

## 함수의 콜 스택

DFS를 구현할 때 재귀적으로 함수를 호출하게 됩니다.
시스템의 콜 스택을 활용하여 그래프 깊이 들어갔다 나오는 방식으로 구현합니다.

이 때문에 별도의 스택 자료구조를 사용하지 않아도 되지만, 그래프가 너무 깊어지면 스택 오버플로우가 발생할 위험이 있습니다.

## 구현

- 기본적으로 DFS의 특성상, 재귀 호출을 통해 탐색을 진행하고 결과를 반환한다
    - 가령 "탐색을 시작한 상태부터 목표 상태까지 도달하는 최단 경로"를 반환해야 한다

## 예제

### 기본 예제

```go
package main

import "fmt"

// DFS
// - `graph`: 전체 그래프
// - `visited`: 이미 방문한 노드를 체크하기 위한 map
// - `node`: 시작 노드
func DFS(graph map[string][]string, visited map[string]bool, node string) {
    if visited[node] {
        return
    }
    fmt.Println(node)
    visited[node] = true
    for _, n := range graph[node] {
        DFS(graph, visited, n)
    }
}

func main() {
    graph := make(map[string][]string)
    graph["A"] = []string{"B", "C"}
    graph["B"] = []string{"D", "E"}
    graph["C"] = []string{"F"}
    graph["D"] = []string{}
    graph["E"] = []string{"F"}
    graph["F"] = []string{}

    visited := make(map[string]bool)
    DFS(graph, visited, "A")
}
```
