# 미로 탈출 명령어

- [미로 탈출 명령어](#미로-탈출-명령어)
    - [문제 설명](#문제-설명)
    - [제한사항](#제한사항)
    - [입출력의 예](#입출력의-예)
    - [입출력의 예 설명](#입출력의-예-설명)
        - [2번째 케이스](#2번째-케이스)
        - [3번째 케이스](#3번째-케이스)
    - [문제 해결](#문제-해결)
        - [By BFS](#by-bfs)
        - [By DFS](#by-dfs)

## 문제 설명

`n` x `m` 격자 미로가 주어집니다. 당신은 미로의 (`x`, `y`)에서 출발해 (`r`, `c`)로 이동해서 탈출해야 합니다.

단, 미로를 탈출하는 조건이 세 가지 있습니다.

1. 격자의 바깥으로는 나갈 수 없습니다.
2. (x, y)에서 (r, c)까지 이동하는 거리가 총 k여야 합니다. 이때, (x, y)와 (r, c)격자를 포함해, 같은 격자를 두 번 이상 방문해도 됩니다.
3. 미로에서 탈출한 경로를 문자열로 나타냈을 때, 문자열이 사전 순으로 가장 빠른 경로로 탈출해야 합니다.

이동 경로는 다음과 같이 문자열로 바꿀 수 있습니다.

- `l`: 왼쪽으로 한 칸 이동
- `r`: 오른쪽으로 한 칸 이동
- `u`: 위쪽으로 한 칸 이동
- `d`: 아래쪽으로 한 칸 이동

예를 들어, 왼쪽으로 한 칸, 위로 한 칸, 왼쪽으로 한 칸 움직였다면, 문자열 "lul"로 나타낼 수 있습니다.

미로에서는 인접한 상, 하, 좌, 우 격자로 한 칸씩 이동할 수 있습니다.

예를 들어 다음과 같이 3 x 4 격자가 있다고 가정해 보겠습니다.

```mathematica
  1 2 3 4
1 . . . .
2 . . S .
3 E . . .
```

- 미로의 좌측 상단은 (1, 1)이고 우측 하단은 (3, 4)입니다.
- `.`은 빈 공간,
- `S`는 출발 지점,
- `E`는 탈출 지점입니다.

탈출까지 이동해야 하는 거리 `k`가 5라면 다음과 같은 경로로 탈출할 수 있습니다.

1. lldud
2. ulldd
3. rdlll
4. dllrl
5. dllud

이때 dllrl보다 사전 순으로 빠른 경로로 탈출할 수는 없습니다.

다음과 같은 값들이 매개변수로 주어집니다.
- 격자의 크기를 뜻하는 정수 `n`, `m`,
- 출발 위치를 뜻하는 정수 `x`, `y`,
- 탈출 지점을 뜻하는 정수 `r`, `c`,
- 탈출까지 이동해야 하는 거리를 뜻하는 정수 `k`

이때, 미로를 탈출하기 위한 경로를 return 하도록 solution 함수를 완성해주세요. 단, 위 조건대로 미로를 탈출할 수 없는 경우 `"impossible"`을 return 해야 합니다.

```go
func solution(n int, m int, x int, y int, r int, c int, k int) string {
    return ""
}
```

## 제한사항

- 2 ≤ `n` (= 미로의 세로 길이) ≤ 50
- 2 ≤ `m` (= 미로의 가로 길이) ≤ 50
- 1 ≤ `x` ≤ `n`
- 1 ≤ `y` ≤ `m`
- 1 ≤ `r` ≤ `n`
- 1 ≤ `c` ≤ `m`
- (`x`, `y`) ≠ (`r`, `c`)
- 1 ≤ `k` ≤ 2,500

## 입출력의 예

```text
n    m    x    y    r    c    k    result
3    4    2    3    3    1    5    "dllrl"
2    2    1    1    2    2    2    "dr"
3    3    1    2    3    3    4    "impossible"
```

## 입출력의 예 설명

### 2번째 케이스

```text
n    m    x    y    r    c    k    result
2    2    1    1    2    2    2    "dr"
```

미로의 크기는 2 x 2입니다. 출발 지점은 (1, 1)이고, 탈출 지점은 (2, 2)입니다.

빈 공간은 `.`, 출발 지점을 `S`, 탈출 지점을 `E`로 나타내면 다음과 같습니다.

```mathematica
S.
.E
```

미로의 좌측 상단은 (1, 1)이고 우측 하단은 (2, 2)입니다.

탈출까지 이동해야 하는 거리 `k`가 2이므로 다음과 같은 경로로 탈출할 수 있습니다.

1. rd
2. dr

`"dr"`이 사전 순으로 가장 빠른 경로입니다. 따라서 `"dr"`을 return 해야 합니다.

### 3번째 케이스

```text
n    m    x    y    r    c    k    result
3    3    1    2    3    3    4    "impossible"
```

미로의 크기는 3 x 3입니다. 출발 지점은 (1, 2)이고, 탈출 지점은 (3, 3)입니다.

빈 공간은 `.`, 출발 지점을 `S`, 탈출 지점을 `E`로 나타내면 다음과 같습니다.

```mathematica
.S.
...
..E
```

미로의 좌측 상단은 (1, 1)이고 우측 하단은 (3, 3)입니다.

탈출까지 이동해야 하는 거리 `k`가 4입니다. 이때, 이동 거리가 4이면서, `S`에서 `E`까지 이동할 수 있는 경로는 존재하지 않습니다.

따라서 `"impossible"`을 return 해야 합니다.

## 문제 해결

- [길이 k가 정해진 이상 사전순으로 최적을 만들기 위해선 각 순간에 d l r u 순으로 가능한지 불가능한지만 판단해서 최적으로 계속 가주기만 하면 된다](https://ps.mjstudio.net/kakao-coding-test#6-%EB%AF%B8%EB%A1%9C-%ED%83%88%EC%B6%9C-%EB%AA%85%EB%A0%B9%EC%96%B4-lv3-152-min-ac)

### By BFS

1. 초기화
    - 우선순위 큐(Priority Queue)를 만들어서 탐색할 노드들을 저장한다.
    - 이 우선순위 큐에는 출발 지점과 빈 문자열("")을 넣는다. 빈 문자열은 지금까지의 이동 경로를 나타낸다.
    - 우선순위 큐를 사용하여 사전 순으로 가장 빠른 경로를 먼저 고려
2. BFS 탐색
    - 우선순위 큐에서 노드를 하나 꺼내고, 그 노드에서 갈 수 있는 모든 방향(상하좌우)에 대해 다음 노드와 경로를 업데이트하여 다시 큐에 넣는다.
    - 이때, 이미 방문한 상태(위치와 남은 이동 횟수)가 더 좋은 경로로 방문되었다면 그 경로는 무시한다.
3. 탈출 조건 확인
    - 큐에서 노드를 하나 꺼낼 때, 그 노드의 위치가 목적지 (r, c)이고 남은 이동 횟수가 0이면 현재까지의 경로를 반환한다.
4. 불가능한 경우
    - 큐가 빌 때까지 목적지에 도달하지 못하면 "impossible"을 반환한다.

### By DFS

- 스택을 사용해 가능한 모든 경로를 탐색하고, 목적지에 도달할 때까지 반복
- 가지치기를 통해 불필요한 경로는 빠르게 제거한다. 이를 위해 `맨해튼 거리`를 활용하여 불가능한 경로를 빠르게 찾아내고 제거한다

```py
def solution(n, m, x, y, r, c, k): 
    stack = [(x, y, [])]
    result = 'impossible'
    
    while stack:
        x_pos, y_pos, path = stack.pop()
        if len(path) == k and (x_pos, y_pos) == (r, c):
            result = ''.join(path)
            break
        remain, shortest_path = k - len(path), abs(x_pos - r) + abs(y_pos - c)
        if remain < shortest_path or remain % 2 != shortest_path % 2:
            continue
        
        if x_pos > 1:
            stack.append((x_pos - 1, y_pos, path + ['u']))
        if y_pos < m:
            stack.append((x_pos, y_pos + 1, path + ['r']))
        if y_pos > 1:
            stack.append((x_pos, y_pos - 1, path + ['l']))
        if x_pos < n:
            stack.append((x_pos + 1, y_pos, path + ['d']))

    return result
```
