# concurrency and parallelism

- [concurrency and parallelism](#concurrency-and-parallelism)
    - [동시성이란?](#동시성이란)
        - [동시성의 목적](#동시성의-목적)
    - [병렬성이란?](#병렬성이란)
    - [비동기 프로그래밍이란?](#비동기-프로그래밍이란)
        - [비동기 실행 모델](#비동기-실행-모델)
        - [`async`/`await`](#asyncawait)
            - [`async`](#async)
            - [`await`](#await)
            - [`then`](#then)
            - [`await` 사용](#await-사용)
    - [동시성과 병렬성](#동시성과-병렬성)
        - [파일을 복사하는 프로그램](#파일을-복사하는-프로그램)
        - [사용자 입력을 처리하는 프로그램](#사용자-입력을-처리하는-프로그램)
        - [웹 서버에서 데이터를 가져오는 프로그램](#웹-서버에서-데이터를-가져오는-프로그램)
    - [비동기 프로그래밍과 동시성(concurrency), 병렬성(parallelism)](#비동기-프로그래밍과-동시성concurrency-병렬성parallelism)
        - [동시성과 비동기 프로그래밍](#동시성과-비동기-프로그래밍)
        - [병렬성과 비동기 프로그래밍](#병렬성과-비동기-프로그래밍)
        - [동시성과 병렬성의 결합](#동시성과-병렬성의-결합)

## 동시성이란?

- 동시성은 여러 작업이 **논리적으로 동시에 발생하는 것처럼, 번갈아가며 실행되는 것**을 의미한다. 이는 멀티태스킹 환경에서 작업들이 *공유 자원*에 대한 접근을 조율하면서 실행된다.
    - `mutex`
    - `세마포어`
    - `컨디션 변수` 등
- 동시성은 여러 작업이 시간을 공유하며 진행되는 것. 여러 작업이 번갈아가며 실행되는 방식을 말하며, 이는 스레드가 블로킹되는 것을 포함할 수도 있고 포함하지 않을 수도 있다. 예를 들어,
    - `I/O 작업`을 기다리는 동안 스레드가 블로킹될 수 있다
    - `이벤트 루프`를 사용하는 경우 스레드는 블로킹되지 않는다
- 멀티태스킹 환경에서 작업들이 번갈아가며 실행되어, *동시에 진행되는 것처럼 보이는 것*
- 동시성은 *작업들이 리소스를 공유하며 시간적으로 중첩되어 실행되는 것*을 말한다

동시성은 단일 프로세서 환경에서도 유용하며, 실제로 대부분의 동시성 모델은 단일 프로세서에서의 작업 스케줄링을 기반으로 한다. 동시에 진행되는 것처럼 보이는 작업들은 사실 시간상으로 미세하게 나누어져 실행되며, 이는 멀티태스킹 운영 시스템에서 매우 흔히 볼 수 있는 현상이다.

> 멀티태스킹은 운영 시스템의 스케줄러가 각 프로세스에 CPU 시간을 할당하고, 이를 효율적으로 관리하여 여러 작업이 동시에 실행되는 것처럼 보이도록 하는 방식으로 동작한다.

### 동시성의 목적

- 자원을 효율적으로 활용
- 시스템의 반응성을 높이는 것

## 병렬성이란?

병렬성은 여러 처리 과정이 **실제로 동시에 실행되는 것**을 말한다.
이는 여러 CPU 코어를 사용하여 다른 작업을 동시에 실행함으로써 달성된다.
병렬성의 주된 목적은 계산 속도를 높이는 것이며, 크게 계산 집약적인 작업에 유용하다.

## 비동기 프로그래밍이란?

비동기 프로그래밍은 프로그램의 주 실행 흐름을 막지 않고, 백그라운드에서 작업을 수행할 수 있도록 한다.
이는 I/O 작업, 네트워크 요청 등의 블로킹(Blocking) 작업을 처리할 때 특히 유용하다.
비동기 프로그래밍에서는 `async/await`, `Promise`와 같은 패턴을 사용하여 복잡한 비동기 로직을 보다 쉽게 관리할 수 있다.

작업이 완료될 때까지 기다리는 동안 다른 작업을 수행할 수 있도록 한다 -> 반응성을 높인다

### 비동기 실행 모델

1. 실행 컨텍스트의 분리
    - 비동기 함수(예: `async` 함수)에서 `await` 키워드를 만나면, 해당 함수의 실행 컨텍스트(현재 실행 위치, 지역 변수의 상태 등)가 저장된다.
    - 이를 통해 함수의 나머지 부분의 실행을 나중에 재개할 수 있다
2. 이벤트 루프와 작업 큐
    - `await` 이후, 제어권은 이벤트 루프로 넘어간다
    - 이벤트 루프는 작업 큐에 있는 다른 작업(이벤트 핸들링, 다른 비동기 작업 등)을 계속해서 처리한다
    - 이때, 원래의 비동기 작업은 완료될 때까지 대기 상태에 있으며, 스레드는 블로킹되지 않고 다른 작업을 계속 처리한다
3. 비동기 작업의 완료와 재개
    - 비동기 작업이 완료되면, 해당 작업의 결과와 함께 이벤트 루프에 의해 다시 처리 대기열에 추가된다
    - 이벤트 루프는 나중에 이 작업을 잡아 실행 컨텍스트를 복원하고, `await` 이후의 코드를 계속 실행한다

이때 스레드의 상태는

- 블로킹되지 않는 스레드:
    - `await`가 사용되는 동안 원래의 스레드는 블로킹되지 않는다. 즉, 여전히 이벤트 루프는 동작한다.
    - 따라서 이 스레드는 이벤트 루프 또는 비동기 실행기에 의해 다른 준비된 작업을 처리한다. 이를 통해 CPU는 유휴 상태에 머무르지 않고 효율적으로 활용됩니다.
- 함수의 일시 중지
    - `await`에 의해 중지된 함수는 그 상태가 유지되며, 나머지 부분은 비동기 작업의 완료 후에 실행된다
    - 이 과정에서 원래의 스레드는 다른 작업을 처리하므로, 프로그램의 전체적인 실행은 멈추지 않는다

### `async`/`await`

- `async`/`await` 패턴은 I/O 작업 같은 비동기적 작업을 시작하고, 비동기 작업이 완료되는 동안 프로그램의 실행을 중단하지 않고 다른 작업을 계속 수행할 수 있도록 한다.
- `async`/`await`는 동시성(concurrency)에 기반한다
    - 작업을 병렬로 수행하는 것이 아니라, 작업을 비동기적으로 관리하여 효율적으로 리소스를 활용하는 방식
    - 비동기 프로그래밍의 핵심은 I/O 작업이나 시간이 많이 걸리는 작업을 백그라운드에서 실행하고, 이 작업들이 완료되는 것을 기다리는 동안 다른 작업을 수행할 수 있도록 하는 것
- 일반적으로 스레드를 블로킹하지 않는다. 작업이 완료될 때까지 기다리는 동안 실행기(executor)나 이벤트 루프가 다른 작업을 수행할 수 있도록 한다

#### `async`

- `async` 키워드를 사용한 함수는 비동기적으로 실행되며, 작업의 결과를 나중에 제공하는 `Future` 또는 `Promise` 등 유사한 객체를 반환.

#### `await`

- `Future` 또는 `Promise` 등이 완료될 때까지 현재 *함수의 실행을 일시 중지*하지만, 이때 전체 스레드를 블로킹하지는 않는다. 즉, 이벤트 루프는 여전히 동작한다.
    - `await`를 만나면, 현재 함수의 실행 상태(컨텍스트)가 저장된다. 이 컨텍스트에는 함수의 지역 변수, 실행 포인터 등이 포함된다.
    - 실행 컨텍스트가 저장된 후, 제어권은 `이벤트 루프` 또는 `비동기 실행기`(executor)로 넘어간다. 이때 현재 스레드는 블로킹되지 않으며, 이벤트 루프는 다른 준비된 작업(다른 `Future`나 이벤트 처리 등)을 실행할 수 있다
    - 비동기 작업(`Future` 또는 `Promise`)이 완료되면, 이벤트 루프 또는 실행기는 해당 작업의 완료를 감지하고 저장했던 실행 컨텍스트를 복원하여 함수의 실행을 재개한다
- 작업(`Future`)이 완료되면, `await` 키워드를 사용하여 실행을 재개하고 결과를 반환한다

#### `then`

- 비동기 처리의 연속성: `then`은 Promise 또는 Future에 대한 콜백을 연결한다. 비동기 작업이 완료되면 `then`에 제공된 콜백 함수가 실행된다.
- 체이닝: `then`을 사용하면 여러 비동기 작업을 체인 형태로 연결할 수 있다. 각 `then`은 이전 작업의 결과를 다음 단계로 전달한다.

    ```javascript
    doSomethingAsync()
        .then(result => doAnotherThingAsync(result))
        .then(finalResult => console.log(finalResult))
        .catch(error => console.error(error));
    ```

#### `await` 사용

- `await`는 비동기 작업의 결과가 나올 때까지 함수의 실행을 "일시 중지" 시킨다. 이를 통해 비동기 작업이 마치 동기적으로 작동하는 것처럼 코드를 작성할 수 있게 한다.
- 이 **함수 실행의 일시 중지는 해당 함수의 실행 문맥에서만 적용**되며, **프로그램의 다른 부분은 계속 실행**된다. 이벤트 루프가 다른 이벤트나 작업을 처리할 수 있게 해주어 프로그램이 멈추지 않도록 한다.
- `await`는 코드를 동기적으로 보이게 하지만, 실제로는 비동기 작업을 처리하며, 프로그램의 나머지 부분이 블록되지 않도록 한다

    ```javascript
    async function doTasks() {
        try {
            let result = await doSomethingAsync();
            let finalResult = await doAnotherThingAsync(result);
            console.log(finalResult);
        } catch (error) {
            console.error(error);
        }
    }
    ```

## 동시성과 병렬성

동시성과 병렬성은 모두 여러 작업을 동시에 수행하는 것과 관련이 있지만, 차이점이 있다.

동시성은 여러 작업이 번갈아가며 실행되어 동시에 처리되는 것처럼 보이게 하는 것을 의미하므로, 반드시 동시에 수행되는 것은 아니다.
병렬성은 여러 작업이 동시에 수행되는 것을 의미하며, 실제로 동시에 수행된다.

동시성은 프로그램이 여러 작업을 동시에 처리할 수 있도록 구조화하는 방법이다. 이는 주로 단일 프로세서에서 여러 작업을 번갈아가며 처리하여, 모든 작업이 동시에 진행되는 것처럼 보이게 한다. 동시성은 작업들 사이의 상호작용을 관리하고, 자원 접근 충돌을 방지하는 메커니즘을 포함한다. 이를 통해 시스템의 반응성과 자원 활용도를 높일 수 있다.

병렬성은 여러 작업이 물리적으로 동시에 수행되는 것을 의미한다. 이는 멀티코어 또는 멀티프로세서 시스템에서 각 작업을 동시에 다른 프로세서나 코어에서 실행함으로써 달성된다. 병렬성을 통해 프로그램의 실행 시간을 단축시키고, 계산 집약적인 작업을 더 빠르게 처리할 수 있다. 병렬성의 핵심은 작업을 여러 부분으로 나누고, 각 부분을 동시에 실행하여 전체 작업을 더 빠르게 완료하는 것이다.

동시성과 병렬성은 모두 프로그램의 성능을 향상시키는 데 사용할 수 있는 강력한 도구지만, 동시성과 병렬성을 효과적으로 사용하려면 동시성과 병렬성의 차이점을 이해하는 것이 중요하다.

### 파일을 복사하는 프로그램

파일을 복사하는 프로그램은 일반적으로 두 가지 작업을 수행한다.
1. 파일을 읽는 것
2. 파일을 쓰는 것

- **동시성 활용**: 파일을 읽는 작업과 파일을 쓰는 작업을 동시성을 사용하여 번갈아가며 수행한다.
    - 예를 들어,
        - 파일을 읽는 작업이 진행되는 동안 읽은 데이터를 메모리에 임시 저장
        - 이 데이터를 파일에 쓰는 작업은 읽기 작업이 일시 중지될 때 실행
    - 이 방식은 단일 코어 CPU에서도 효율적으로 작업을 수행할 수 있게 해준다

- **병렬성 활용**: 파일을 읽는 작업과 파일을 쓰는 작업을 병렬성을 사용하여 동시에 다른 프로세서 또는 코어에서 수행한다.
    - 예를 들어,
        - 멀티코어 시스템에서 한 코어가 파일을 읽는 동안
        - 다른 코어는 이미 읽은 데이터를 파일에 쓰는 작업을 동시에 수행
    - 이 방식은 작업의 처리 시간을 크게 단축시킬 수 있다.

### 사용자 입력을 처리하는 프로그램

사용자 입력을 처리하는 프로그램은 일반적으로 두 가지 작업을 수행한다.
1. 사용자 입력을 읽는 것
2. 사용자 입력을 처리하는 것

- **동시성 활용**: 사용자 입력을 읽는 작업과 입력을 처리하는 작업을 동시성을 통해 효율적으로 관리한다.
    - 예를 들어,
        - 사용자 입력을 받는 동안 입력 처리 로직은 대기 상태에 있으며,
        - 입력이 완료되면 입력 처리 로직이 실행
    - 이는 사용자 입력이 발생하는 동안 시스템이 다른 작업을 수행할 수 있도록 하여 반응성을 개선합니다.

- **병렬성 활용**: 사용자 입력을 처리하는 프로그램에서 병렬성을 활용하여, 여러 사용자의 입력을 동시에 처리할 수 있다.
    - 예를 들어, 게임 서버에서 여러 플레이어의 입력을 받는 경우,
        - 각 플레이어의 입력을 별도의 스레드나 프로세스에서 병렬로 처리
        - 모든 플레이어의 입력을 신속하게 처리하고 게임의 상태를 업데이트할 수 있음
    - 이는 특히 멀티플레이어 게임이나 대규모 인터랙티브 애플리케이션에서 사용자 경험을 크게 향상시킬 수 있다.

### 웹 서버에서 데이터를 가져오는 프로그램

웹 서버에서 데이터를 가져오는 프로그램은 일반적으로 두 가지 작업을 수행한다.
1. 웹 서버에 요청을 보내는 것
2. 웹 서버의 응답을 처리하는 것

- **동시성 활용**: 웹 서버에 요청을 보내는 작업과 응답을 처리하는 작업을 동시성을 통해 효율적으로 관리한다.
    - 예를 들어,여러 웹 서버에 데이터 요청을 보낼 때,
        - 각 요청은 독립적으로 처리
        - 요청 중 하나가 완료되면 해당 응답을 처리하는 로직 실행
    - 이는 네트워크 지연 시간 동안 다른 요청을 처리할 수 있게 하여 전체적인 효율성을 높인다.

- **병렬성 활용**: 웹 서버에서 대량의 데이터를 가져오는 작업에서 병렬성을 활용하여, 여러 데이터 요청을 동시에 수행한다.
    - 예를 들어,
        - 대용량의 데이터를 여러 부분으로 나눈다
        - 각 부분을 별도의 스레드에서 동시에 요청하고 처리함으로써 전체 데이터를 더 빠르게 가져올 수 있다
    - 이 방식은 데이터 처리 시간을 크게 단축시킬 수 있다.

## 비동기 프로그래밍과 동시성(concurrency), 병렬성(parallelism)

### 동시성과 비동기 프로그래밍

동시성은 다수의 작업이 시간상으로 겹쳐서, 번갈아 가면서 실행될 수 있도록 하는 개념이다.
- 싱글 코어 또는 멀티 코어 환경 모두에서 구현될 수 있으며,
- 중요한 점은 여러 작업이 서로 독립적으로 진행되면서도, 특정 시점에는 한 작업이 다른 작업의 완료를 기다리거나, 결과에 의존할 수 있다는 것

비동기 프로그래밍에서 동시성은 주로 *이벤트 루프*나 *콜백 메커니즘*을 통해 구현된다.
예를 들어, JavaScript에서는 `Promise`나 `async/await` 구문을 사용하여 비동기 작업을 처리하고, *이벤트 루프*를 통해 이러한 **비동기 작업들이 동시에 처리**될 수 있도록 한다.
여기서 핵심은 프로그램이 비동기 작업의 완료를 기다리는 동안 멈추지 않고, 다른 작업을 계속 수행할 수 있다는 점이다.

### 병렬성과 비동기 프로그래밍

병렬성은 여러 작업이 물리적으로 동시에 실행되는 것을 의미한다.
- 멀티 코어 프로세서를 활용하여, 동일한 시간에 여러 작업이 실제로 수행될 수 있게 한다
- 병렬 처리는 계산이 많이 필요한 작업에 특히 유용하며, 프로그램의 실행 시간을 대폭 줄일 수 있다.

비동기 프로그래밍에서 병렬성은 여러 비동기 작업을 동시에 시작하고, 이러한 작업들이 각각 독립적으로, 그리고 동시에 수행될 수 있도록 할 때 활용된다.
예를 들어, Python의 `asyncio` 라이브러리나 JavaScript의 `Promise.all` 메소드를 사용하여 여러 비동기 작업을 병렬로 실행할 수 있다. 이 경우, 각 비동기 작업은 서로 다른 CPU 코어에서 실행될 수 있으며, 이는 전체 작업의 완료 시간을 단축시키는 데 기여한다.

### 동시성과 병렬성의 결합

비동기 프로그래밍에서 동시성과 병렬성은 서로 보완적으로 작용할 수 있습니다. 동시성은 프로그램이 여러 작업을 효율적으로 관리하고 조정할 수 있게 해주며, 병렬성은 이러한 작업들을 실제로 동시에 실행하여 성능을 개선합니다. 따라서, 비동기 프로그래밍은 동시성을 통해 응답성을 유지하면서도, 병렬성을 통해 더 빠른 실행 속도를 달성할 수 있습니다.

이러한 관계를 통해, 비동기 프로그래밍은 높은 응답성과 함께, 계산 집약적인 작업의 효율적인 수행을 가능하게 합니다. 이는 모던 소프트웨어 개발에서 매우 중요한 요소이며, 동시성과 병렬성을 적절히 활용하는 것이 성공적인 비동기 프로그래밍의 핵심입니다.

동시성(concurrency)은 여러 작업이 번갈아가며 실행되는 것을 의미
병렬성(parallelism)은 여러 작업이 물리적으로 동시에 수행되는 것을 의미

비동기 메서드는 **동시성과 관련**이 있으며, 동시 또는 병렬 작업과도 연관될 수 있다.
비동기 메서드를 사용함으로써, 프로그램은 I/O 작업이나 네트워크 요청과 같은 시간 소모적인 작업을 기다리는 동안 다른 작업을 계속 진행할 수 있다.
이는 동시성 프로그래밍의 핵심 원칙인 **작업들이 리소스를 공유하며 시간적으로 중첩되어 실행되는 것**에 해당한다.

예를 들어 데이터베이스에서 데이터를 가져오는 데 시간이 걸릴 수 있지만 데이터를 기다리는 UI를 차단하고 싶지는 않을 것이다.

비동기 호출은 원격 시스템에 요청을 보낸 후, 콜백 함수를 참조하여 요청의 결과를 나중에 처리할 준비를 한다.
요청이 원격 시스템에 도달하는 즉시, 실행 제어권은 다시 원래의 코드로 반환된다.
이후 원격 시스템에서 처리가 완료되고 결과가 준비되면, 지정된 콜백 함수가 호출된다.
이러한 방식으로, 애플리케이션은 요청의 처리와 독립적으로 계속해서 다른 작업을 수행할 수 있다.

```rs
// 동시성의 예시
use tokio::time::{sleep, Duration};

// `perform_task` 함수는 비동기적으로 실행된다
async fn perform_task(id: u32) {
    println!("Task {} started", id);
    sleep(Duration::from_secs(2)).await;
    println!("Task {} completed", id);
}

#[tokio::main]
async fn main() {
    // main 함수에서 각각의 태스크가 순차적으로 시작
    let task1 = perform_task(1);
    let task2 = perform_task(2);
    let task3 = perform_task(3);

    // await를 사용하여 각 태스크의 완료를 기다린다
    // 태스크들이 서로 독립적으로 실행되지만, 하나의 태스크가 완료된 후 다음 태스크가 시작된다
    task1.await;
    task2.await;
    task3.await;
}
```

```rs
// 병렬성의 예시
use tokio::time::{sleep, Duration};
use futures::future::join_all;

async fn perform_task(id: u32) {
    println!("Task {} started", id);
    sleep(Duration::from_secs(2)).await; // 스레드를 블로킹하지 않고, 대신 비동기적으로 지정된 시간 동안 기다린다
    println!("Task {} completed", id);
}

#[tokio::main]
async fn main() {
    let tasks = vec![
        perform_task(1),
        perform_task(2),
        perform_task(3),
    ];

    // `join_all` 함수는 
    // 1. 여러 비동기 작업들이 거의 동시에 시작되게 하고
    // 2. 모든 작업이 완료될 때까지 기다리도록 한다
    // 각 태스크가 별도의 비동기적 컨텍스트에서 동시에 실행되므로, 태스크들이 서로를 방해하지 않고 동시에 완료될 수 있다
    join_all(tasks).await;
}
```
