/*
 * 프로그램은 특정 메모리 주소에 적재되어 실행될 것을 전제로 하는 메모리 이미지(memory image)입니다.
 * C 컴파일러(예를 들어 gcc 등)는 소스 파일(`.c`, `.S`)을 컴파일하여 각 파일에 대한
 * 독립적인 오브젝트 파일(.o)들을 생성합니다.
 *
 * 각 오브젝트 파일은 .text(코드), .data(초기화된 데이터) 등 여러 섹션(section)으로 나뉘어 있지만,
 * 아직 최종 메모리 주소가 확정되지 않은 상태입니다.
 * 그리고 다른 파일에 정의된 함수나 변수(심볼)를 참조하는 부분은 비어 있습니다.
 *
 * 컴파일 결과는 이런 입력 섹션(input section)의 모음입니다.
 * 각 `*.o` 파일에 .text, .text.startup, .rodata, .data, .bss 같은 이름으로 쪼개져 들어가 있습니다.
 *
 * 이 스크립트는 `SECTIONS { ... }` 규칙에 따라 입력 섹션(input section)들을 출력 섹션(output section)으로 모으고,
 * 최종 ELF에 프로그램 헤더(PT_LOAD 세그먼트)를 만듭니다.
 * 그리고 로더는 프로그램 헤더 단위로 메모리에 적재합니다.
 *
 * - kernel.ld: DRAM 시작(virt 보드) 0x80000000에서 실행합니다.
 * - `-bios none` M‑mode에서 직접 부팅하는 xv6‑riscv 미니 커널을 링크하는 용도로 사용됩니다.
 *
 * 이 링크 스크립트는 흩어져 있는 오브젝트 파일들(*.o)을 모아서 운영체제가 될 하나의 실행 가능한 ELF 파일로 만듭니다.
 * 이 스크립트는 링커에게 다음 사항들을 지시합니다.
 * - 메모리 배치: 각 코드와 데이터 섹션을 메모리의 어떤 주소에, 어떤 순서로 배치할 것인지?
 * - 진입점: 부팅 후 CPU가 가장 먼저 실행해야 할 명령어는 어디에 있는지?
 * - 심볼 정의: 커널 실행에 필요한 특정 메모리 주소(예를 들어, 커널 이미지의 끝)를 어떻게 코드에서 참조할 수 있게 할 것인지?
 *
 * 부팅 직후 메모리 배치는 다음과 같습니다.
 *
 * 0x8000_0000  +---------------------------+ <=== BASE (= .)
 *              |         .text (RX)        |
 *              |  entry, trap, scheduler   |
 *              +---------------------------+ <=== page aligned(4K)
 *              |        .rodata (R)        |
 *              |      문자열/const 테이블      |
 *              +---------------------------+ <=== page aligned(4K)
 *              |         .data (RW)        |
 *              |      초기화된 전역/정적 변수    |
 *              +---------------------------+ <=== edata (= BSS 시작)
 *              |        .bss (RW, zero)   |
 *              |       zero-init 전역/정적   |
 *              +---------------------------+ <=== end (= 커널 이미지 끝)
 *              |        여유(힙/스택 등)      |
 *              |     커널 스택, 페이지 프레임    |
 *              +---------------------------+
 */

/*
 * 출력 ELF의 `e_machine`을 RISC‑V(EM_RISCV)로 지정합니다.
 * 툴체인이 riscv64-unknown-elf-ld라면 중복 지정이지만,
 * 타깃이 뒤섞인 오브젝트가 우연히 들어오는 사고를 막을 수 있습니다.
 * 아키텍처가 일치하지 않으면 링크 에러를 내거나, 최소한 경고가 발생합니다.
 */
OUTPUT_ARCH(riscv)

/*
 * ELF 헤더의 `e_entry`에 _entry 심볼의 주소를 기록합니다.
 * 로더가 점프할 최초 PC로 쓰이며, QEMU `-kernel` 로더도 이 엔트리를 참고합니다.
 * 따라서 entry.S의 라벨 이름과 이 심볼 이름이 반드시 일치해야 합니다.
 * - 프로그램 진입점을 entry.S에서 정의한 라벨 _entry 심볼로 지정합니다.
 * - 부트 시 CPU가 처음 실행할 위치입니다.
 */
ENTRY(_entry)

/*
 * virt 머신의 DRAM이 시작하는 물리 주소입니다.
 * `-bios none`이면 QEMU가 커널 ELF의 PT_LOAD를 그 주소들로 메모리에 싣고, CPU는 ENTRY로 점프합니다.
 * 이 경우 VMA(Virtual Memory Address, 가상 메모리 주소)=LMA(Load Memory Address, 실제 메모리 주소)가 됩니다.
 * - 링크 주소 시작점을 0x80000000으로 지정합니다.
 * - QEMU RISC-V virt 머신의 DRAM 시작 주소입니다.
 *
 * Note:
 * `-bios default`(OpenSBI)의 경우 OpenSBI 자체가 0x8000_0000 부근을 점유합니다.
 * 해당 옵션을 사용할 경우 이 스크립트를 그대로 사용한다면 OpenSBI 영역과 커널의 PT_LOAD가 겹치게 됩니다.
 * 그러면 "Some ROM regions are overlapping" 같은 충돌이 발생할 수 있습니다.
 */
BASE = 0x80000000;

/*
 * 링커는 입력 섹션들을 패턴으로 매칭해 순서대로 출력 섹션에 쌓습니다.
 *
 * 순서는 .text -> .rodata -> .data -> .sdata -> edata -> .sbss -> .bss -> end 가 일반적입니다.
 *
 * - 코드는 실행 권한이 필요하므로 실행 전용 영역을 앞에 둡니다.
 * - 상수는 읽기 전용이므로 코드 다음에 읽기 전용으로 둡니다.
 * - 초기값이 있는 전역은 파일에서 복사해 와야 하므로 읽기/쓰기 영역의 앞쪽에 둡니다.
 * - 초기값이 0인 전역은 파일에 굳이 담을 필요가 없으니 그 뒤를 제로로 채울 메모리 구간으로 남깁니다.
 * - 작은 전역 sdata/.sbss의 경우 gp±2048 바이트 묶음 내에서 한 번의 load/store로 접근할 수 있도록 .data와 .bss 사이에 끼워 넣습니다.
 */
SECTIONS {
    /*
     * - `.`(location counter)는 지금 배치 중인 출력 위치를 가리키는 링커의 내부 포인터입니다.
     * - `. = BASE`로 시작 주소를 설정하고, 섹션을 하나 놓을 때마다 그만큼 전진합니다.
     * - 즉, 이제부터 배치되는 모든 섹션은 이 주소부터 시작하여 차곡차곡 쌓이게 됩니다.
     */
    . = BASE;

    /*
     * - 코드 영역으로 모든 .text* 섹션을 모아서 배치합니다.
     *
     * ALIGN(N)는 "현재 위치(`.`)를 N의 배수로 올림한 값"을 반환합니다.
     * 출력 섹션 헤더의 시작 주소가 그 경계에서 출발하도록 `.`를 당깁니다.
     * 예를 들어, `.`가 0x80001234라면, ALIGN(0x1000) 뒤의 섹션은 0x80002000에서 시작합니다.
     *
     * RISC-V ‘virt’ 머신에서 페이지 크기는 4KB입니다.
     *
     * ALIGN(4K)는 현재 위치(`.`)를 4KB 경계(4096바이트 배수)로 맞추라는 뜻입니다.
     * 즉, 현재 위치(`.`) 다음 4KB 경계로 올림(round up)합니다.
     *
     * 이렇게 하면 성격이 다른 섹션들을 페이지 경계에 맞출 수 있고,
     * 나중에 페이지 테이블 권한을 페이지 단위로 깔끔하게 나눌 수 있습니다.
     * - .text(코드) -> RX
     * - .rodata(읽기 전용 데이터) -> R
     * - .data(쓰기 가능한 데이터), .bss(초기화되지 않은 전역/정적 변수 집합) -> RW
     *
     * 커널처럼 자체 페이징을 켜는 코드에서 매우 중요하다고 합니다.
     */
    .text : ALIGN(4K) {
        /*
         * - `*(패턴)`은 모든 오브젝트 파일에서 해당 섹션 이름과 매치되는 부분들을 전부 모아 넣으라는 의미입니다.
         * - `.text.*`는 `.text.startup`, `.text.main` 등 세부 섹션들을 모두 포함합니다.
         */
        *(.text .text.*)
    }

    /*
     * - const로 선언된 상수, 문자열 리터럴 등 읽기 전용(read only) 데이터
     */
    .rodata : ALIGN(4K) {
        *(.rodata .rodata.*)
    }

    /*
     * - 초기화된 전역, 정적 변수
     * - 가령 `int x = 10;`과 같이 초기값이 있는 전역 변수나 `static` 변수가 저장됩니다.
     */
    .data : ALIGN(4K) {
        *(.data .data.*)
    }

    /*
     * 초기값이 있는 작은 전역
     */
    .sdata : ALIGN(16) {
        /*
         * .sdata 시작 + 0x800 (±2048 창의 중앙값)으로 "gp 기준점"
         */
        PROVIDE(__global_pointer$ = . + 0x800);
        *(.sdata .sdata.* .gnu.linkonce.s.*)
    }

    /*
     * .sbss를 16바이트로 정렬하므로 edata도 그 정렬과 동일한 경계로 맞춥니다.(edata == .sbss 시작)
     */
    . = ALIGN(16);
    /*
     * edata는 초기화된 RW의 끝 = 제로화 시작점입니다.
     * 즉, 초기화된 쓰기 가능한 전역의 끝, 제로화 대상(BSS, 즉 .sbss, .bss, COMMON)의 시작입니다.
     * 따라서 .data와 .sdata가 끝난 직후에 한 번만 정의합니다.
     *
     * .data와 .sdata는 초기값이 파일에 들어있는 전역입니다.
     * 로더가 파일에서 메모리로 복사합니다.
     *
     * .sbss와 .bss는 초기값 0(파일에는 공간 없음)이므로 실행 시 제로화해야 합니다.
     *
     * .bss 섹션이 시작되기 직전, 즉 앞서 정의한 .data 섹션이 끝나는 지점의 주소를 edata라는 심볼로 정의합니다.
     * `edata=.`를 .bss의 시작 시점에 찍어 두면 "초기화된 데이터의 끝(= .data의 끝)"이 됩니다.
     *
     * 커널의 초기화 코드(start.c 등)에서는 `extern char edata[];`와 같이
     * 이 심볼을 C 변수처럼 참조할 수 있습니다.
     *
     * 커널의 초기화 코드(start.c 등)에서 `for(p = edata; p < end; p++) *p = 0;`가
     * 정확히 `.sbss ∪ .bss`만 지웁니다.(BSS 제로화)
     */
    PROVIDE(edata = .); /* start.c의 extern char edata[]; */

    /*
     * 초기값이 0인 작은 전역
     */
    .sbss (NOLOAD) : ALIGN(16) {
        *(.sbss .sbss.* .gnu.linkonce.sb.*)
        *(.scommon)
    }

    /*
     * - BSS란 Block Started by Symbol
     * - 초기화되지 않은 전역 변수, 또는 0으로 초기화된 전역 변수(`static int y;`), 그리고 정적 변수들의 집합
     * - ELF 파일에는 내용이 들어가지 않아서 공간을 차지하지 않습니다.
     *   단지 어느 정도의 메모리가 필요하다는 크기 정보만 기록하고,
     *   커널(또는 로더)이 직접 해당 메모리 영역을 확보하고 0으로 채워줘야 합니다.
     *   이제 `PROVIDE(end = .);` 심볼을 정의합니다.
     * - COMMON 심볼을 포함합니다.
     */
    .bss (NOLOAD) : ALIGN(4K) {
        /*
         * - COMMON은 고전 C의 공용(common) 기호를 흡수합니다.
         */
        *(.bss .bss.* COMMON)
        /*
         * .bss와 COMMON 섹션 배치가 모두 끝난 후의 주소,
         * 즉 커널 이미지의 최종 끝 지점을 end라는 심볼로 정의합니다.
         *
         * `extern char end[];`와 같이 이 심볼을 C 변수처럼 참조할 수 있습니다.
         *
         * .bss의 끝이므로 커널 이미지의 끝을 가리키는 포인터로 유용합니다.
         * 메모리 할당 초기화, 커널 심볼 테이블 고정 배치 등에 사용합니다.
         */
        PROVIDE(end = .); /* start.c의 extern char end[]; */
        /* 커널 이미지 끝 */
    }
}
