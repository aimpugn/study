/*
 * 프로그램은 특정 메모리 주소에 적재되어 실행될 것을 전제로 하는 메모리 이미지(memory image)입니다.
 *
 * C 컴파일러(예를 들어 gcc 등)는 소스 파일(`.c`, `.S`)을 컴파일하여 각 파일에 대한
 * 독립적인 오브젝트 파일(.o)들을 생성합니다.
 *
 * 컴파일 결과는 여러 입력 섹션(input section)의 모음입니다.
 * 각 오브젝트 파일은 .text, .text.startup, .rodata(read only data), .data, .bss 등의
 * 여러 섹션(section)으로 나뉘어 있지만, 아직 최종 메모리 주소가 확정되지 않은 상태입니다.
 *
 * 오브젝트 파일(.o)과 ELF(Executable and Linkable Format)는 인스트럭션들을 .text 섹션에 모아서
 * 저장해 두는 그릇입니다.
 * 링커는 이 인스트럭션들 묶음이 메모리 어디에 올라갈지를 정하고, QEMU는 그 주소대로 메모리에 올립니다.
 * CPU는 그 주소에서 인스트럭션을 하나씩 읽어서 실행합니다.
 *
 * 그리고 다른 파일에 정의된 함수나 변수(심볼)를 참조하는 부분은 비어 있습니다.
 * 이 스크립트는 BASE를 DRAM 시작(virt 보드) 0x80000000으로 두고, ENTRY를 _entry로 지정합니다.
 * 그리고 다음과 같은 메모리 레이아웃을 갖게 됩니다.
 * ```
 * .text -> .rodata -> .data -> .sdata -> __bss_start__ -> .sbss/.bss -> __bss_end__
 * ```
 *
 * 이 스크립트는 `SECTIONS { ... }` 규칙에 따라 입력 섹션(input section)들을 출력 섹션(output section)으로 모으고,
 * 최종 ELF에 프로그램 헤더(PT_LOAD 세그먼트)를 만듭니다.
 *
 * > PT_LOAD 프로그램 헤더는 ELF 파일 내의 적재 가능한(loadable) **세그먼트(Segment)**를 정의하며,
 * > 운영체제(OS) 로더가 프로그램을 메모리에 올릴 때 사용되는 가장 중요한 헤더 유형 중 하나입니다.
 * >
 * > 주요 기능 및 역할은 다음과 같습니다.
 * > - 메모리 매핑 지시: OS 로더는 PT_LOAD 헤더에 포함된 정보를 바탕으로 파일의 어느 부분이
 * >                 프로그램의 가상 주소 공간(Virtual Address Space) 어디에 위치해야 하는지 파악합니다.
 * >
 * > - 세그먼트 정의: 실행 파일은 여러 개의 PT_LOAD 세그먼트를 가질 수 있으며, 일반적으로 읽기 전용 명령(코드)과
 * >              데이터가 포함된 "텍스트(text)" 세그먼트, 쓰기 가능한 초기화된/초기화되지 않은 데이터가 포함된
 * >              "데이터(data)" 세그먼트로 구성됩니다.
 * >
 * > - 파일 크기와 메모리 크기:
 * >   - p_filesz 필드는 파일 내에서 해당 세그먼트가 차지하는 크기를 나타냅니다.
 * >   - p_memsz 필드는 메모리 내에서 해당 세그먼트가 차지할 크기를 나타냅니다.
 * >   - p_memsz가 p_filesz보다 큰 경우, 추가 바이트(일반적으로 .bss 섹션과 같은 초기화되지 않은 데이터)는
 * >     메모리에서 0 값으로 채워집니다.
 * >
 * > - 메모리 접근 권한 설정: 각 PT_LOAD 세그먼트는 읽기, 쓰기, 실행과 같은
 * >                     특정 메모리 접근 권한(p_flags 필드)을 가집니다.
 * >                     이는 OS가 메모리 보호 메커니즘을 설정하는 데 사용됩니다.
 * >
 * > - 링커와 커널의 역할: 커널(OS 로더)은 프로그램 실행 시 섹션 정보에는 관심이 없으며
 * >                  오직 PT_LOAD 세그먼트 정보만을 처리하여 메모리에 적재합니다.
 *
 * 그리고 로더는 프로그램 헤더 단위로 메모리에 적재합니다.
 * 현재 프로젝트처럼 `-bios none -kernel` 옵션을 사용하는 경우에는 OS 로더가 아니라
 * QEMU가 직접 커널 ELF의 PT_LOAD를 그 주소들로 메모리에 로드합니다.
 * 즉, `-bios none`은 M‑mode에서 직접 부팅하는 xv6‑riscv 미니 커널을 링크하는 용도로 사용됩니다.
 *
 * 이 시점에서 CPU 입장에서는 아무것도 모르며, CPU는 단지 "초기 PC를 ELF의 ENTRY 심볼 주소(여기서는 `_entry`로
 * 지정한 `.text`의 시작 부분)로 맞추고, 이 주소부터 RISC-V 인스트럭션을 fetch해서 실행하라"라는 명령만 받습니다.
 *
 * > 인스트럭션?
 * >
 * > 고정 길이 32비트 혹은 16비트(압축 명령)의 비트 패턴입니다.
 * > 이 비트 패턴 안에는 '어떤 연산을 할 것인지(opcode)', '어떤 레지스터를 읽고 쓸 것인지(register index)',
 * > '얼마만큼 더하거나 점프할 것인지(immediate)'가 인코딩되어 있습니다.
 * >
 * > 예를 들어, `sb a0, 0(a1)`은 'a1 레지스터에 들어 있는 주소에, a0의 하위 8비트를 store byte 하라'는 명령이고,
 * > CPU는 이 명령을 보고 다음과 같은 파이프라인을 거칩니다.
 * > 1. PC에서 인스트럭션을 fetch하고,
 * > 2. decode 단계에서 '이건 store byte다'를 알아내고,
 * > 3. execute 단계에서 주소를 계산하고,
 * > 4. memory 단계에서 그 주소에 바이트를 쓰고,
 * > 5. write-back 단계에서는 다시 레지스터를 갱신하지 않음
 *
 * 즉, QEMU는 "하드웨어를 흉내 내는 프로그램"이고,
 * kernel.ld는 "그 하드웨어 맵에 맞춰서 ELF를 어떻게 배치할지 알려 주는 설계도"입니다.
 * 둘은 서로 약속된 주소(0x8000_0000, 0x1000_0000 등)를 통해 연결되고, 그 결과 RISC-V CPU는
 * DRAM의 0x8000_0000에서 인스트럭션을 하나씩 읽어 실행하기 시작합니다.
 *
 * 이 링크 스크립트는 흩어져 있는 오브젝트 파일들(*.o)을 모아서 운영체제가 될 하나의 실행 가능한 ELF 파일로 만듭니다.
 * 이 스크립트는 링커에게 다음 사항들을 지시합니다.
 * - 메모리 배치: 각 코드와 데이터 섹션을 메모리의 어떤 주소에, 어떤 순서로 배치할 것인지?
 * - 진입점: 부팅 후 CPU가 가장 먼저 실행해야 할 명령어는 어디에 있는지?
 * - 심볼 정의: 커널 실행에 필요한 특정 메모리 주소(예를 들어, 커널 이미지의 끝)를 어떻게 코드에서 참조할 수 있게 할 것인지?
 *
 * 부팅 직후 메모리 배치는 다음과 같습니다.
 *
 * 0x8000_0000  +---------------------------+ <=== BASE (= .)
 *              |         .text (RX)        |
 *              |  entry, trap, scheduler   |
 *              +---------------------------+ <=== page aligned(4K)
 *              |        .rodata (R)        |
 *              |      문자열/const 테이블      |
 *              +---------------------------+ <=== page aligned(4K)
 *              |         .data (RW)        |
 *              |      초기화된 전역/정적 변수    |
 *              +---------------------------+ <=== edata (= BSS 시작)
 *              |        .bss (RW, zero)   |
 *              |       zero-init 전역/정적   |
 *              +---------------------------+ <=== end (= 커널 이미지 끝)
 *              |        여유(힙/스택 등)      |
 *              |     커널 스택, 페이지 프레임    |
 *              +---------------------------+
 *
 * `sdata`, `.sbss` 등도 있는데, 실제 코드는 small data 세그먼트를 더 쪼개서 사용합니다.
 */

/*
 * 출력 ELF의 `e_machine`을 RISC‑V(EM_RISCV)로 지정합니다.
 *
 * 툴체인이 riscv64-unknown-elf-ld라면 중복 지정이지만,
 * 타깃이 뒤섞인 오브젝트가 우연히 들어오는 사고를 막을 수 있습니다.
 * 아키텍처가 일치하지 않으면 링크 에러를 내거나, 최소한 경고가 발생합니다.
 */
OUTPUT_ARCH(riscv)

/*
 * 프로그램 진입점(부트 시 CPU가 처음 실행할 위치) ELF 헤더의 `e_entry`를
 * `entry.S`에서 정의한 라벨 `_entry` 심볼로 지정합니다.
 *
 * `ENTRY(_entry)`라는 한 줄이 커널 파일 안에서 "내가 부팅할 때 첫 번째로 실행하고 싶은 기계어 주소는 여기"라고
 * 찍어 두는 역할을 하는 것이고, QEMU는 거기에 PC를 맞춥니다.
 *
 * 실제 objdump를 보면:
 *
 * 0000000080000000 <_entry>:
 *    80000000:   00001197                auipc   gp,0x1
 *    80000004:   97018193                addi    gp,gp,-1680 # 80000970 <__global_pointer$>
 *    80000008:   f14022f3                csrr    t0,mhartid
 *    8000000c:   00001117                auipc   sp,0x1
 *    80000010:   ff410113                addi    sp,sp,-12 # 80001000 <stack0>
 *    80000014:   6305                    lui     t1,0x1
 *    80000016:   00128393                addi    t2,t0,1
 *    8000001a:   02730333                mul     t1,t1,t2
 *    8000001e:   911a                    add     sp,sp,t1
 *    80000020:   8216                    mv      tp,t0
 *    80000022:   00029963                bnez    t0,80000034 <park_secondary>
 *
 * QEMU `-kernel`은 이 `e_entry`를 읽어서 PC에 그대로 넣습니다.
 *
 * 로더가 점프할 최초 PC로 쓰이며, QEMU `-kernel` 로더도 이 엔트리를 참고합니다.
 * 따라서 **`entry.S`의 라벨 이름과 이 심볼 이름이 반드시 일치**해야 합니다.
 */
ENTRY(_entry)

/*
 * QEMU RISC-V virt 머신의 DRAM이 시작하는 물리 주소입니다.
 * 링크 주소 시작점을 0x80000000으로 지정합니다.
 *
 * examples/virt.dts 파일을 보면 다음과 같은 내용을 확인할 수 있습니다:
 *
 * memory@80000000 {
 *     device_type = "memory";
 *     reg = <0x00 0x80000000 0x00 0x8000000>;
 * };
 *
 * `-bios none -kernel`이면 QEMU가 커널 ELF의 PT_LOAD를 그 주소들로 메모리에 싣고, CPU는 ENTRY로 점프합니다.
 * 이 경우 VMA(Virtual Memory Address, 가상 메모리 주소)=LMA(Load Memory Address, 실제 메모리 주소)가 됩니다.
 *
 * Note:
 * `-bios default`(OpenSBI)의 경우 OpenSBI 자체가 0x8000_0000 부근을 점유합니다.
 * 해당 옵션을 사용할 경우 이 스크립트를 그대로 사용한다면 OpenSBI 영역과 커널의 PT_LOAD가 겹치게 됩니다.
 * 그러면 "Some ROM regions are overlapping" 같은 충돌이 발생할 수 있습니다.
 */
BASE = 0x80000000;

/*
 * 링커는 입력 섹션들을 패턴으로 매칭해 순서대로 출력 섹션에 쌓습니다.
 *
 * 순서는 .text -> .rodata -> .data -> .sdata -> edata -> .sbss -> .bss -> end 가 일반적입니다.
 *
 * - 코드는 실행 권한이 필요하므로 실행 전용 영역을 앞에 둡니다.
 * - 상수는 읽기 전용이므로 코드 다음에 읽기 전용으로 둡니다.
 * - 초기값이 있는 전역은 파일에서 복사해 와야 하므로 읽기/쓰기 영역의 앞쪽에 둡니다.
 * - 초기값이 0인 전역은 파일에 굳이 담을 필요가 없으니 그 뒤를 제로로 채울 메모리 구간으로 남깁니다.
 * - 작은 전역 sdata/.sbss의 경우 gp±2048 바이트 묶음 내에서 한 번의 load/store로 접근할 수 있도록 .data와 .bss 사이에 끼워 넣습니다.
 */
SECTIONS {
    /*
     * - `.`(location counter)는 지금 배치 중인 출력 위치를 가리키는 링커의 내부 포인터입니다.
    *  - `.`를 시작 주소(0x80000000)로 설정하고, .text 출력 섹션의 시작 주소를 4KB 경계에 올립니다.
     * - 섹션을 하나 놓을 때마다 그만큼 전진합니다.
     * - 즉, 이제부터 배치되는 모든 섹션은 이 주소부터 시작하여 차곡차곡 쌓이게 됩니다.
     */
    . = BASE;

    /*
     * - 코드 영역으로 모든 .text* 섹션을 모아서 배치합니다.
     *
     * ALIGN(N)는 "현재 위치(`.`)를 N의 배수로 올림한 값"을 반환합니다.
     * 출력 섹션 헤더의 시작 주소가 그 경계에서 출발하도록 `.`를 당깁니다.
     * 예를 들어, `.`가 0x80001234라면, ALIGN(0x1000) 뒤의 섹션은 0x80002000에서 시작합니다.
     *
     * RISC-V ‘virt’ 머신에서 페이지 크기는 4KB입니다.
     *
     * ALIGN(4K)는 현재 위치(`.`)를 4KB 경계(4096바이트 배수)로 맞추라는 뜻입니다.
     * 즉, 현재 위치(`.`) 다음 4KB 경계로 올림(round up)합니다.
     *
     * 이렇게 하면 성격이 다른 섹션들을 페이지 경계에 맞출 수 있고,
     * 나중에 페이지 테이블 권한을 페이지 단위로 깔끔하게 나눌 수 있습니다.
     * - .text(코드) -> RX
     * - .rodata(읽기 전용 데이터) -> R
     * - .data(쓰기 가능한 데이터), .bss(초기화되지 않은 전역/정적 변수 집합) -> RW
     *
     * 커널처럼 자체 페이징을 켜는 코드에서 매우 중요하다고 합니다.
     */
    .text : ALIGN(4K) {
        /*
         * - `*(패턴)`은 모든 오브젝트 파일에서 해당 섹션 이름과 매치되는 부분들을 전부 모아 넣으라는 의미입니다.
         * - `.text.*`는 `.text.startup`, `.text.main` 등 세부 섹션들을 모두 포함합니다.
         */
        *(.text .text.*)
    }

    /*
     * - const로 선언된 상수, 문자열 리터럴 등 읽기 전용(read only) 데이터
     * - 여기서 `.rodata.*`를 다 모으고 있어서, 문자열 리터럴("HELLO ..." 등)도 여기로 들어갑니다.
     */
    .rodata : ALIGN(4K) {
        *(.rodata .rodata.*)
    }

    /*
     * 초기값이 0이 아닌 전역/정적 변수들이 들어가는 섹션입니다.
     *
     * - 초기화된 전역, 정적 변수 등 **초기값 있는 전역/정적이 모두** 들어갑니다.
     * - 가령 `int x = 10;`과 같이 초기값이 있는 전역 변수나 `static` 변수가 저장됩니다.
     * - 이 값들을 **그대로 디스크에 저장**해야 하므로, 실행 파일 안에서 실제 바이트들을 차지합니다.
     *
     * 초기값이 0인 섹션(`.bss`)은 별도로 존재합니다.
     *
     * 이렇게 `.data`(initialized data)와 `.bss`(uninitialized/zero-initialized) 섹션으로 나누는
     * 이유는 '실행 파일 크기'와 '로딩 시간'을 줄이기 위해서라고 합니다.​
     *
     * 만약 모든 전역/정적 변수를 `.data`에 넣는다면, 0으로 초기화되는 변수들까지 모두 0 바이트들을 디스크에 써야 합니다.
     * 이렇게 되면 수백 KB에서 수 MB의 '0 패딩'이 그대로 파일 크기와 I/O 시간으로 이어집니다.​
     *
     * 0으로 초기화되어야 하는 `.bss` 섹션이 별도로 존재한다면,
     * 실행 파일에는 ".bss 섹션의 크기 = N 바이트" 같은 정보만 들어가고 N개의 0 바이트는 전혀 저장되지 않으므로,
     * 파일이 훨씬 작아지고 디스크→메모리로 읽어야 할 양도 줄어듭니다.​
     */
    .data : ALIGN(4K) {
        *(.data .data.*)
    }

    /*
     * 초기값이 있는 작은 전역
     *
     * - RISC‑V psABI에서 **gp(x3)**는 "작은 전역(small data)"을 위한 기준 포인터로 쓰입니다.
     * - 관례적으로 `__global_pointer$`를 `.sdata`의 시작에서 +0x800 바이트 지점에 두고,
     *   그 ±2048 범위에 `.sdata`/`.sbss` 전역들을 배치합니다.
     *
     * 사실상 TLS도 안 쓰고, small data 최적화를 적극 활용하는 코드도 아니지만 설정해둡니다.
     */
    .sdata : ALIGN(16) {
        /*
         * .sdata 시작 + 0x800 (±2048 창의 중앙값)으로 "gp 기준점"
         */
        PROVIDE(__global_pointer$ = . + 0x800);
        *(.sdata .sdata.* .gnu.linkonce.s.*)
    }

    /*
     * .sdata 끝을 16바이트 경계로 맞춥니다.
     *
     * 이제부터 `start.c`와 직접 맞물리는 핵심입니다.
     *
     * .sbss를 16바이트로 정렬하므로 edata도 그 정렬과 동일한 경계로 맞춥니다.(edata == .sbss 시작)
     */
    . = ALIGN(16);

    /*
     * `edata`는 '초기화된 쓰기 가능한(RW) 전역의 끝'이자 '제로화 대상(BSS, 즉 .sbss, .bss, COMMON)의 시작점'입니다.
     *
     * `.data`와 `.sdata`가 끝난 직후에 한 번만 정의합니다.
     * `.data`와 `.sdata`는 초기값이 파일에 들어있는 전역이고, 로더가 파일에서 메모리로 복사합니다.
     *
     * .sbss와 .bss는 초기값 0(파일에는 공간 없음)이므로 실행 시 제로화해야 합니다.
     *
     * .bss 섹션이 시작되기 직전, 즉 앞서 정의한 .data 섹션이 끝나는 지점의 주소를 edata라는 심볼로 정의합니다.
     * `edata=.`를 .bss의 시작 시점에 찍어 두면 "초기화된 데이터의 끝(= .data의 끝)"이 됩니다.
     *
     * 즉,
     * `edata`
     * = `.sdata` 끝
     * = BSS(즉 `.sbss`, `.bss`, `COMMON`)의 시작점
     *
     * 커널의 초기화 코드(start.c 등)에서는 `extern char edata[];`와 같이
     * 이 심볼을 C 변수처럼 참조할 수 있습니다.
     *
     * 메모리에서 `[edata, end)` 구간이 `.sbss` + `.bss` + `COMMON` 전체이고,
     * 커널의 초기화 코드(`start.c` 등)에서 이 구간을 0으로 채우고 있습니다.(BSS 제로화)
     *
     * ```c
     * extern char edata[], end[];
     *
     * void start(void) {
     *     for (char *p = edata; p < end; p++) {
     *         *p = 0;
     *     }
     *
     *     main();
     *     ...
     * }
     * ```
     */
    /* PROVIDE(edata = .); start.c의 extern char edata[]; */
    /* 아래와 같이 이름을 변경해서 사용할 수도 있습니다. */
    PROVIDE(__bss_start__ = .); /* start.c의 extern char __bss_start__[]; */

    /*
     * `.bss`와 `.sbss`는 실행 파일 안에서는 실제 데이터 바이트를 넣지 않고
     * "이만큼 크기의 메모리를 0으로 비워 달라"는 길이 정보만 기록해 두는 섹션입니다.
     * 그래서 파일 용량은 늘리지 않지만 프로세스가 시작될 때 로더/런타임이 그 범위를 0으로 메우도록 약속된 영역입니다
     */
    .sbss (NOLOAD) : ALIGN(16) {
        *(.sbss .sbss.* .gnu.linkonce.sb.*)
        *(.scommon)
    }

    /*
     * BSS(Block Started by Symbol)는 아주 오래된 어셈블러에서
     * "이름(symbol) 하나로 블록 크기만 지정하는 영역"을 의미하던 디렉티브에서 유래했습니다.
     *
     * 현대 실행 파일(ELF, COFF 등)에서 .bss는 "정적으로 할당되지만, 처음 값이 모두 0으로 간주되는
     * 전역/정적 변수들(`static int y;`)"이 모이는 섹션입니다.
     *
     * C 언어의 규칙상, 전역 변수나 정적 변수(정적 저장 기간을 가진 객체)는 초기화를 하지 않아도
     * 모두 0으로 초기화된 것처럼 동작해야 합니다.​
     *
     * 실행 파일 포맷 차원에서는 이 초기값을 파일에다 '0,0,0,0, ...' 같은 바이트로 써 둘 필요가 없으므로,
     * "어디서부터 어디까지 BSS이고, 런타임에 0으로 메워 달라"는 식으로 길이만 기록해 두는 구조를 만듭니다.
     *
     * ELF 같은 실행 파일 포맷에서 `.bss` 섹션은 `SHT_NOBITS` 타입으로 표시되어,
     * 파일 안에 실제 데이터가 없고 길이만 기록된 섹션으로 정의됩니다.
     *
     * 디스크/플래시 같은 저장장치에는 BSS 내용이 실제 바이트로 존재하지 않고, 오직 '크기 정보'만 존재하게 됩니다.
     *
     * - 초기화되지 않은 전역 변수, 또는 0으로 초기화된 전역 변수, 그리고 정적 변수들의 집합
     * - ELF 파일에는 내용이 들어가지 않아서 공간을 차지하지 않습니다.
     *   단지 어느 정도의 메모리가 필요하다는 크기 정보만 기록하고,
     *   커널(또는 로더)이 직접 해당 메모리 영역을 확보하고 0으로 채워줘야 합니다.
     *   이제 `PROVIDE(end = .);` 심볼을 정의합니다.
     * - COMMON 심볼을 포함합니다.
     */
    .bss (NOLOAD) : ALIGN(4K) {
        /*
         * - COMMON은 고전 C의 공용(common) 기호를 흡수합니다.
         */
        *(.bss .bss.* COMMON)
        /*
         * .bss와 COMMON 섹션 배치가 모두 끝난 후의 주소,
         * 즉 커널 이미지의 최종 끝 지점을 end라는 심볼로 정의합니다.
         *
         * `extern char end[];`와 같이 이 심볼을 C 변수처럼 참조할 수 있습니다.
         *
         * .bss의 끝이므로 커널 이미지의 끝을 가리키는 포인터로 유용합니다.
         * 메모리 할당 초기화, 커널 심볼 테이블 고정 배치 등에 사용합니다.
         */
        /* 아래와 같이 이름을 변경해서 사용할 수도 있습니다. */
        /* PROVIDE(end = .); start.c의 extern char end[]; */
        PROVIDE(__bss_end__ = .); /* start.c의 extern char __bss_end__[]; */
        /* 커널 이미지 끝 */
    }
}
