extern void main(void);
extern char edata[], end[]; // kernel.ld가 제공

#define MAXCPU 10

// 전역 char 배열은 1바이트 정렬이 기본이므로 시작 주소가 16의 배수라고 보장할 수 없습니다.
// 현재 sp(stack pointer)는 다음과 같습니다.
// la      sp, stack0
// li      t1, 4096     // 4096
// addi    t2, t0, 1    // hartid + 1
// mul     t1, t1, t2   // 4096 * (hartid + 1)
// add     sp, sp, t1   // &stack0 + (4096 * (hartid + 1))
//
// `sp = &stack0 + 4096 * (hartid + 1);`라고 볼 수 있습니다.
//
// 이떄 `&stack0`가 16의 배수여야, sp도 16의 배수가 되고, 이미 4096은 16의 배수이빈다.
// 따라서 시작만 메모리 주소가 16의 배수가 되도록 정렬(align)하면,
// 각 코어 청크도 자동으로 16베수 정렬이 됩니다.
//
// 이를 위해 변수 자체의 시작 주소를 16바이트 경계에 강제로 맞춥니다.
//
// - S = addr(stack0) = 16의 배수   (aligned(16))
// - C = 4096         = 16의 배수
// - i = hartid       = 0,1,2,...
//
// sp(i) = S + (C * (i + 1)) 라고 할 때, `sp(i) % 16 == 0`는 항상 참이 됩니다.
__attribute__((aligned(16)))
// 한 코어(CPU, hart)마다 4KB짜리 스택을 잘라 쓰기 위해 큰 버퍼(4KB × MAXCPU)를 만들고,
// 그 버퍼의 시작 주소를 16바이트 경계에 맞춰 함수 호출 규약을 지킵니다.
// 코어(=hart)마다 스택이 따로 필요한데, 부팅 초기에 malloc 같은 것도 없으므로
// 전역 배열을 크게 확보해서 잘라서 사용합니다.
char stack0[(256 * 16) * MAXCPU];

// entry.S jumps here in machine mode on stack0.
void start(void) {
    // 값을 지정해주지 않은 전역 변수, 또는 static 변수는 프로그램 시작 시 반드시 0의 값을 가져야 합니다.
    // 일반적으로 프로그램을 실행할 경우, 영체제(OS)의 프로그램 로더가 개발자 대신 이 약속을 지켜줍니다.
    //
    // 가령 로더는 실행 파일(.exe, a.out)을 읽어 메모리에 올리고,
    // C 코드가 시작되기 전에 필요한 모든 환경(BSS 영역을 0으로 채우는 것 포함)을 준비해 줍니다.
    //
    // `-bios none` 경우 펌웨어가 로드되지 않으므로 펌웨어나 런타임이 BSS 초기화를 대신해주지 않습니다.
    // 이렇게 되면 운영체제 커널의 경우에는 커널을 도와줄 상위의 프로그램이 없습니다.
    // 따라서 BSS 영역(전역/정적 영역)을 0으로 채우는 것 역시 직접 처리해줘야 하며,
    // 이때 링커 스크립트가 노출하는 섹션 심볼을 이용합니다.
    //
    // 'edata'부터 'end'까지 한 칸(char *p)씩 이동하며 *p를 0으로 초기화합니다.
    for (char *p = edata; p < end; p++) {
        *p = 0;
    }

    main();

    // main 끝나면 대기
    for(;;) __asm__ volatile("wfi");
}
