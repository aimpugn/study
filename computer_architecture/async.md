# Async

## 비동기 프로그래밍(Asynchronous Programming)

비동기 프로그래밍은 작업이 시작된 후 완료될 때까지 기다리지 않고 다음 작업을 진행할 수 있게 하는 프로그래밍 방식입니다.

```plaintext
[Start Task]
     |
[Submit to Executor]
     |
[Continue Execution]
     |
[Task Completion (Callback/Future)]
     |
[Handle Result]
```

## 특징

- 논블로킹 작업: 작업의 완료를 기다리지 않고 즉시 반환합니다.
- 콜백 또는 `Future` 사용: 작업의 완료 시점을 알리기 위해 콜백 함수나 `Future` 객체를 사용합니다.
- 동시성 및 병렬성 지원: 시스템 자원을 효율적으로 사용하여 동시에 여러 작업을 처리합니다.
- 응답성 향상: 긴 작업으로 인해 메인 스레드가 블록되지 않아 UI나 서버의 응답성을 높입니다.
- 자원 효율성: 스레드 풀이나 이벤트 루프를 사용하여 스레드 수를 최소화하면서 많은 작업을 처리합니다.
- 스케일링 가능성: 대규모 네트워크 애플리케이션에서 많은 연결을 효율적으로 관리합니다.

## 비동기 프로그래밍의 요소

비동기 프로그래밍은 여러 요소들의 협력을 통해 구현됩니다.

### 하드웨어 요소

- CPU 코어와 병렬 처리

    CPU 코어는 컴퓨터에서 명령을 실행하는 기본 단위입니다. 즉, 컴퓨터 프로세서 내에서 독립적으로 명령어를 읽고, 해석하고, 실행할 수 있는 물리적 처리 단위입니다. 각 코어는 자체적으로 산술 논리 장치(ALU), 제어 장치, 레지스터 세트를 포함하고 있습니다.

    현대의 CPU는 여러 개의 코어를 포함하고 있으며, 각 코어는 독립적으로 명령어를 실행할 수 있어, 진정한 의미의 병렬 처리가 가능합니다.

    여러 코어에서 동시에 작업을 실행(Parallel Processing)하여 전체 성능을 향상시킵니다.

- 하이퍼스레딩(Hyper-Threading) 또는 동시 멀티스레딩(Simultaneous Multi-Threading, SMT):

    인텔(Intel)의 프로세서 기술로, 하나의 물리적 코어를 두 개의 논리적 코어처럼 동작하게 합니다. CPU 자원의 유휴 시간을 줄여 처리 효율을 높입니다.

    ```plaintext
      물리적 코어 1      물리적 코어 2
       |     |          |     |
    논리 1   논리 2     논리 3   논리 4
    ```

    코어 내부의 일부 하드웨어 자원(예: 레지스터 세트)을 복제하여 두 개의 실행 컨텍스트를 지원합니다. 캐시, 실행 유닛 등의 자원은 공유됩니다.

    ```plaintext
    물리적 코어
    |-- 논리적 코어 1
    |   |-- 레지스터 세트 1
    |   `-- 명령어 포인터 1
    |-- 논리적 코어 2
    |   |-- 레지스터 세트 2
    |   `-- 명령어 포인터 2
    |-- 공유 자원
        |-- 캐시
        |-- 실행 유닛
        `-- 파이프라인 스테이지
    ```

    단일 코어의 자원 활용도를 높이지만, 실제로는 자원을 공유하므로 완전한 병렬 처리는 아닙니다. 물리적 코어 두 개를 사용하는 것보다 성능 향상이 적습니다.

- 멀티스레딩:

    여러 실행 스레드를 동시에 또는 의사 동시적으로(pseudo-concurrently) 처리하는 기술을 말합니다.

    - 하나의 프로세스 내에서 여러 스레드(Thread)가 병행적으로 작업을 수행하는 방식입니다. CPU의 여러 코어를 활용하여 병렬 처리를 수행하고, 응답성을 향상시킵니다.
    - 스레드(Thread)는 프로세스 내에서 독립적으로 실행되는 가장 작은 실행 단위입니다.

### 운영체제 요소

- 프로세스(Process)는 실행 중인 프로그램의 인스턴스이며, 독립적인 메모리 공간을 가집니다.
- 운영체제의 커널은 스케줄러를 통해 스레드에게 CPU 시간을 분배합니다.
- CPU가 한 스레드에서 다른 스레드로 전환할 때 컨텍스트 스위칭(Context Switching)이 발생하며, 오버헤드가 있습니다.
- 블로킹 I/O는 I/O 작업이 완료될 때까지 스레드가 대기 상태에 놓입니다.
- 논블로킹 I/O는 I/O 작업이 즉시 반환되며, 작업의 완료 여부는 나중에 확인합니다.
- I/O 멀티플렉싱:
    하나의 스레드에서 여러 I/O 이벤트를 감시하고 처리할 수 있게 하는 메커니즘입니다.
    - `select`
    - `poll`
    - `epoll`(Linux)
    - `kqueue`(BSD)
    - `IOCP`(Windows)
- 이벤트 루프(Event Loop):
    이벤트가 발생할 때까지 대기하고, 이벤트가 발생하면 해당 이벤트를 처리하는 프로그래밍 구조입니다.
    이벤트 루프는 I/O 멀티플렉싱을 활용하여 효율적으로 여러 I/O 작업을 관리합니다.

- 동기화 프리미티브
    - 뮤텍스(Mutex)는 상호 배제를 통해 여러 스레드가 동시에 공유 자원에 접근하는 것을 방지합니다.
    - 세마포어(Semaphore)는 카운터를 사용하여 제한된 자원에 대한 접근을 관리합니다.
    - 컨디션 변수(Condition Variable)는 스레드 간의 통신을 위해 사용되며, 특정 조건이 충족될 때까지 스레드를 대기시킵니다.

### 언어 런타임 요소

- OS 스레드 사용 모델:
    - 언어의 런타임이 OS의 스레드를 직접 사용하여 동시성을 구현합니다. (예: Java)
- 그린 스레드(Green Thread):
    - 언어 런타임이나 가상 머신에서 관리하는 가상 스레드입니다.
    - OS 스레드보다 생성 및 컨텍스트 스위칭 비용이 낮습니다.
- 동시성 프리미티브
    - 고루틴(Goroutine)은 Go 언어에서 사용하는 경량 스레드로, Go 런타임이 관리합니다.
    - `async`/`await`는 비동기 함수의 선언과 호출을 위한 문법입니다.
    - `Future`/`Promise`는 비동기 작업의 결과를 나타내는 객체로, 완료 시점에 결과를 제공합니다.

- 메모리 관리
    - 가비지 컬렉션(Garbage Collection)은 사용되지 않는 메모리를 자동으로 해제하여 메모리 누수를 방지합니다. (예: Java, Go)
    - 반면 Rust는 소유권 시스템(Ownership System)을 활용하여 컴파일 타임에 메모리 안전성을 보장합니다.

- 이벤트 루프 및 실행기(Executor)
    - 이벤트 루프:
        - 언어 런타임에서 비동기 작업의 완료를 감시하고 처리합니다.
    - 실행기(Executor):
        - 비동기 작업을 스케줄링하고 실행하는 구성 요소입니다.

### 언어 수준의 기능

- `async`/`await`
    - `async` 키워드는 함수를 비동기적으로 선언합니다.
    - `await` 키워드는 비동기 작업의 완료를 기다립니다.

- 콜백 메커니즘
    - 콜백 함수는 비동기 작업이 완료되었을 때 호출되는 함수입니다.
    - 람다 표현식은 익명 함수를 간결하게 작성할 수 있게 해줍니다.

- 동시성 구조체
    - 채널(Channel)은 스레드나 고루틴 간에 데이터를 안전하게 교환하는 구조체입니다. (예: Go, Rust)
    - 뮤텍스(Mutex) 및 락(Lock)는 공유 자원에 대한 동시 접근을 제어합니다.

## 예제

### Java

```java
CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {
    // 긴 계산 작업
    return 42;
});

future.thenApply(result -> result * 2)
      .thenAccept(finalResult -> System.out.println("Result: " + finalResult));

// 출력: Result: 84
```
