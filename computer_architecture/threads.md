# Thread

- [Thread](#thread)
    - [일반 스레드 (Software Thread)](#일반-스레드-software-thread)
    - [하이퍼스레딩, 하드웨어 스레드](#하이퍼스레딩-하드웨어-스레드)
        - [하이퍼스레딩의 작동 원리](#하이퍼스레딩의-작동-원리)
        - [실제 동시성과의 차이](#실제-동시성과의-차이)
        - [예시](#예시)
    - [고루틴, 그린 스레드, 일반 스레드의 차이점](#고루틴-그린-스레드-일반-스레드의-차이점)
        - [1. 고루틴 (Goroutine)](#1-고루틴-goroutine)
        - [2. 그린 스레드 (Green Thread)](#2-그린-스레드-green-thread)
        - [3. 일반 스레드 (Native Thread)](#3-일반-스레드-native-thread)
        - [차이점 요약](#차이점-요약)
        - [실제 예시](#실제-예시)
    - [멀티태스킹 운영체제와 GC `ParallelGCThreads` 설정](#멀티태스킹-운영체제와-gc-parallelgcthreads-설정)
        - [컨텍스트 스위칭 비용](#컨텍스트-스위칭-비용)
        - [자원 경합](#자원-경합)
        - [가비지 컬렉션 최적화](#가비지-컬렉션-최적화)
        - [스레드와 코어의 관계](#스레드와-코어의-관계)

## 일반 스레드 (Software Thread)

일반 스레드는 운영체제가 관리하는 프로그램 실행의 단위다.
프로그램이나 프로세스 내에서 동시에 여러 작업을 수행하기 위해 생성되며, 각 스레드는 자체 스택을 가지고 있지만, 힙 영역과 같은 다른 자원은 프로세스 내에서 공유한다.

## 하이퍼스레딩, 하드웨어 스레드

하이퍼스레딩(`Hyper-Threading` by intel) 또는 동시 다중 스레딩(`Simultaneous Multithreading`, `SMT`)이라고도 한다.

`하드웨어 스레드`는 CPU의 물리적인 구성 요소로, *CPU가 동시에 수행할 수 있는 명령어 스트림의 수*를 의미한다.
일부 CPU에서 제공하는 기능으로, *하나의 물리적 코어가 두 개의 독립적인 하드웨어 스레드로 작동*한다
하지만, *CPU 자원을 공유하면서 빠르게 전환*되는 방식이므로, 이는 진정한 물리적 코어의 동시성과는 다른 개념이다.

따라서 실제로 두 개의 독립적인 스레드가 완전히 동시에 처리되는 것은 아니지만, 하나의 물리적 코어가 두 개의 하드웨어 스레드로 나뉘어 효율적으로 작업을 처리할 수 있다. 하이퍼스레딩을 사용하면, 예를 들어 물리적으로 4개의 코어를 가진 CPU가 8개의 스레드를 동시에 처리할 수 있게 된다.

### 하이퍼스레딩의 작동 원리

- 동시성의 환상
    - 하이퍼스레딩 기술은 하나의 물리적 코어 내에서 두 개의 스레드가 번갈아 가면서 실행되도록 한다.
    - 코어는 *두 스레드 간에 빠르게 전환함으로써, 동시에 작업을 수행하는 것처럼* 보이게 한다.
- 자원 공유
    - 두 하드웨어 스레드는 CPU의 일부 자원(예: 캐시, 실행 유닛)을 공유한다
    - 이것은 물리적 코어의 효율성을 증가시키고, CPU 자원의 활용도를 개선한다

### 실제 동시성과의 차이

- 진정한 동시성은 아니다
    - 하이퍼스레딩은 두 개의 스레드가 완전히 동시에 실행되는 것이 아니라, *CPU 자원을 공유하면서 빠르게 전환되는 방식*이다.
    - 따라서, 두 개의 스레드가 독립적인 코어에서 동시에 실행되는 것만큼 효율적이지는 않을 수 있다.
- 최적화된 작업 부하
    - 특정 유형의 작업 부하에서는 하이퍼스레딩이 성능을 크게 향상시킬 수 있다.
    - 예를 들어, 한 스레드가 대기 중일 때(예: I/O 작업으로 인해) 다른 스레드가 CPU 자원을 활용할 수 있다

### 예시

하이퍼스레딩이 활성화된 코어가 하나 있고, 1000개의 소프트웨어 스레드가 있는 경우, CPU는 이러한 스레드를 두 개의 하드웨어 스레드로 나누어 효율적으로 처리한다.
그러나 실제로 각 하드웨어 스레드가 500개의 소프트웨어 스레드를 동시에 처리하는 것은 아니며, 이는 운영체제의 스레드 스케줄러에 의해 결정된다.

## 고루틴, 그린 스레드, 일반 스레드의 차이점

이 차이점을 이해하는 것은 비동기 프로그래밍과 멀티스레딩의 성능과 효율성을 제대로 이해하는 데 중요합니다.

### 1. 고루틴 (Goroutine)

고루틴은 Go 언어에서 제공하는 경량 스레드입니다.
고루틴은 다음과 같은 특징을 가지고 있습니다:

- **경량성**:

    고루틴은 스레드보다 훨씬 적은 메모리를 사용합니다.
    초기 메모리 스택 크기가 매우 작으며, 필요에 따라 동적으로 크기가 조정됩니다.

- **멀티플렉싱**:

    고루틴은 *Go 런타임에 의해 관리*되며, *하나의 운영 체제(OS) 스레드에서 다수의 고루틴이 실행*됩니다.
    Go 런타임은 고루틴을 적절히 스케줄링하여 효율적으로 실행합니다.

- **쉬운 생성 및 관리**:

    고루틴은 매우 쉽게 생성할 수 있으며, Go 런타임이 대부분의 관리를 대신해줍니다.

### 2. 그린 스레드 (Green Thread)

그린 스레드는 사용자 공간에서 구현된 가상 스레드입니다.
OS 커널의 직접적인 지원 없이 스레드를 구현하며, 다양한 프로그래밍 언어나 런타임에서 사용될 수 있습니다:

- **사용자 공간 스케줄링**

    그린 스레드는 사용자 공간에서 스케줄링되고 관리되며, *OS 커널의 스케줄러와는 독립적*입니다.

- **고루틴과 유사성**

    고루틴과 마찬가지로 그린 스레드는 경량이며, 다수의 그린 스레드가 하나의 OS 스레드에서 실행될 수 있습니다.

- **이식성**

    OS의 제약을 덜 받으므로 다양한 플랫폼에서 유사한 방식으로 동작할 수 있습니다.

### 3. 일반 스레드 (Native Thread)

일반 스레드는 OS 커널에 의해 관리되는 스레드로, 다음과 같은 특징을 가지고 있습니다:

- **OS 레벨 스케줄링**

    *일반 스레드는 OS 커널의 스케줄러에 의해 관리*됩니다.
    각 스레드는 *커널에 의해 직접 스케줄링되고 관리*됩니다.

- **상대적으로 무거움**

    일반 스레드는 고루틴이나 그린 스레드에 비해 생성, 컨텍스트 스위칭, 관리 비용이 더 큽니다.

- **병렬성**

    여러 CPU 코어에서 병렬로 실행될 수 있어 높은 성능을 낼 수 있습니다.

### 차이점 요약

1. **경량성**:
   - 고루틴과 그린 스레드는 경량 스레드로, 메모리 사용량과 생성 비용이 낮습니다.
   - 일반 스레드는 더 많은 메모리를 사용하고, 생성 및 관리 비용이 높습니다.

2. **스케줄링**:
   - 고루틴과 그린 스레드는 사용자 공간에서 스케줄링되며, 멀티플렉싱을 통해 하나의 OS 스레드에서 다수의 경량 스레드를 실행합니다.
   - 일반 스레드는 OS 커널에 의해 스케줄링되고, 각 스레드는 독립적으로 관리됩니다.

3. **성능**:
   - 고루틴과 그린 스레드는 많은 수의 스레드를 생성할 때 성능 이점이 큽니다.
   - 일반 스레드는 높은 병렬 처리 성능을 제공하지만, 많은 수의 스레드를 관리할 때 오버헤드가 큽니다.

### 실제 예시

고루틴 예제 (Go 언어):

```go
package main

import (
    "fmt"
    "time"
)

func printNumbers() {
    for i := 1; i <= 5; i++ {
        time.Sleep(1 * time.Second)
        fmt.Println(i)
    }
}

func main() {
    go printNumbers() // 고루틴 생성
    time.Sleep(6 * time.Second)
    fmt.Println("Done")
}
```

그린 스레드 예제 (Java, 녹색 스레드는 자바의 오래된 구현 방식으로 현재는 일반 스레드를 사용합니다):

```java
public class GreenThreadExample extends Thread {
    public void run() {
        for (int i = 1; i <= 5; i++) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(i);
        }
    }

    public static void main(String[] args) {
        GreenThreadExample t1 = new GreenThreadExample();
        t1.start(); // 그린 스레드 생성 (예전 JVM에서 지원)
        System.out.println("Done");
    }
}
```

일반 스레드 예제 (Python):

```python
import threading
import time

def print_numbers():
    for i in range(1, 6):
        time.sleep(1)
        print(i)

t1 = threading.Thread(target=print_numbers)
t1.start() # 일반 스레드 생성
t1.join()
print("Done")
```

이와 같이, 각기 다른 스레드 모델은 각각의 사용 사례에 따라 적절하게 선택되어야 합니다. 고루틴과 그린 스레드는 경량성과 효율성 측면에서 장점이 있으며, 일반 스레드는 높은 병렬 처리 성능을 제공할 수 있습니다.

## 멀티태스킹 운영체제와 GC `ParallelGCThreads` 설정

맥북과 같은 멀티태스킹 운영체제에서 실행되는 수천 개의 스레드와 `ParallelGCThreads` 설정 간의 관계

### 컨텍스트 스위칭 비용

운영체제는 여러 프로세스와 스레드 간에 CPU 시간을 할당한다.
스레드 수가 코어 수를 초과하면, 운영체제는 컨텍스트 스위칭(Context Switching)을 자주 수행해야 한다.
컨텍스트 스위칭은 CPU가 한 작업에서 다른 작업으로 전환하는 과정에서 발생하는 오버헤드.
이 오버헤드가 많아지면 시스템 성능이 저하될 수 있다

### 자원 경합

하드웨어 코어 수보다 많은 스레드가 동시에 실행되면 자원 경합(Resource Contention)이 발생할 수 있다.
이는 특히 CPU 및 메모리 자원에 대한 경합이 심할 수 있으며, 이로 인해 시스템의 전반적인 성능이 저하될 수 있다.

### 가비지 컬렉션 최적화

`ParallelGCThreads`는 가비지 컬렉션 작업에 사용될 병렬 스레드의 수를 지정한다.
이 값이 너무 높으면 GC 작업 동안 시스템의 다른 프로세스나 애플리케이션에 필요한 자원을 과도하게 점유할 수 있으며, GC의 효율성이 저하될 수 있다.

### 스레드와 코어의 관계

하드웨어 코어 하나당 동시에 하나의 스레드만 실행할 수 있다.
따라서 코어 수를 초과하는 스레드는 대기 상태에 있거나 시간을 분할하여 실행된다.
`ParallelGCThreads`를 너무 높게 설정하면 이론적으로는 더 빠른 처리가 가능해 보일 수 있지만,
실제로는 컨텍스트 스위칭과 자원 경합으로 인해 GC 작업의 효율성이 저하될 수 있다.
