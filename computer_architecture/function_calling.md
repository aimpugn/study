# Function Calling

- [Function Calling](#function-calling)
    - [Function Calling Convention](#function-calling-convention)
    - [함수 호출 규약의 주요 구성 요소](#함수-호출-규약의-주요-구성-요소)
    - [함수 프롤로그](#함수-프롤로그)
        - [함수 프롤로그 주요 단계](#함수-프롤로그-주요-단계)
        - [레지스터 보존](#레지스터-보존)
        - [스택 정렬](#스택-정렬)
        - [함수 프롤로그 최적화](#함수-프롤로그-최적화)
        - [예외 처리](#예외-처리)
        - [기타](#기타)
    - [함수 에필로그](#함수-에필로그)
        - [전형적인 함수 에필로그 단계](#전형적인-함수-에필로그-단계)
        - [함수 에필로그 최적화](#함수-에필로그-최적화)
        - [예외 처리 및 보안 고려사항](#예외-처리-및-보안-고려사항)
    - [기타](#기타-1)

## Function Calling Convention

함수 호출 규약이란 어떻게 함수([서브루틴](https://ko.wikipedia.org/wiki/%ED%95%A8%EC%88%98_(%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)))가 그들의 호출자(caller)로부터 변수를 받고, 어떻게 결과를 반환하는지에 대한 규약입니다.

함수 호출 시 일어나는 행동에 대한 규칙을 의미하며 *함수 인자들에 대해 어떤 순서로 스택에 쌓을 것인지*, *인자를 레지스터로 이용할 것인지* 그리고 *함수 종료 후 스택을 누가 정리할 것인지* 등에 대해 정해놓은 규칙입니다.

프로그래밍 언어마다 각기 다른 호출 규약을 사용하며 플랫폼(CPU 아키텍처 + 운영 체제)별로도 각기 다른 호츌 규약을 사용합니다.

- **ARM** 경우
    - r0-r3 레지스터를 통해 처음 4개의 인자 전달
    - 스택을 통해 추가 인자 전달
    - lr (링크 레지스터)를 사용하여 반환 주소 저장

- **RISC-V** 경우
    - a0-a7 레지스터를 통해 처음 8개의 인자 전달
    - 스택을 통해 추가 인자 전달
    - ra 레지스터를 사용하여 반환 주소 저장

단일 프로그래밍 언어를 사용하는 프로그램일지라도 여러 개의 호출 규약을 사용할 수도 있고, 코드 최적화를 위해 컴파일러가 선택하거나 프로그래머가 지정하는 경우도 있습니다.

## 함수 호출 규약의 주요 구성 요소

1. **함수 프롤로그 (Function Prologue)**
    - 함수 시작 시 실행되는 코드
    - 스택 프레임 설정, 레지스터 저장 등

2. **매개변수 전달 방식**
    - x86-64에서의 레지스터 사용 순서: rdi, rsi, rdx, rcx, r8, r9
    - 추가 매개변수는 스택을 통해 전달

3. **함수 본문 (Function Body)**
    - 실제 함수의 로직 수행

4. **함수 에필로그 (Function Epilogue)**
    - 함수 종료 시 실행되는 코드
    - 스택 프레임 정리, 저장된 레지스터 복원, 반환 값 설정 등
    - 마지막에 호출자로 제어 반환(함수 반환)

5. **스택 프레임 구조**
    - 지역 변수, 저장된 레지스터, 반환 주소 등을 포함

이 전체 과정을 "함수 실행 주기(Function Execution Cycle)" 또는 "함수 호출 메커니즘(Function Call Mechanism)"이라고 합니다.

## 함수 프롤로그

함수 프롤로그(Function Prologue)는 함수 실행의 초기 단계에서 수행되는 일련의 명령어 세트입니다.
함수 프롤로그의 역할은 *함수의 실행 환경을 설정*하고 *이전 함수의 컨텍스트를 보존*하는 것입니다.
더 구체적으로는 다음과 같은 작업들을 수행합니다:
1. **스택 프레임 설정**: 새로운 함수의 지역 변수와 매개변수를 위한 메모리 공간을 할당합니다.
2. **이전 함수의 컨텍스트 보존**: 호출자 함수로 안전하게 돌아갈 수 있도록 현재 상태를 저장합니다.
3. **레지스터 상태 보존**: 필요한 경우 사용할 레지스터의 현재 값을 저장합니다.
4. **스택 정렬**: 일부 아키텍처에서는 성능 최적화를 위해 스택을 특정 경계에 맞춰 정렬합니다.

### 함수 프롤로그 주요 단계

1. **스택 포인터 조정**
2. **베이스 포인터 저장**
3. **새 베이스 포인터 설정**
4. **필요한 레지스터 저장**
5. **지역 변수를 위한 스택 공간 할당**

x86-64 아키텍처에서의 전형적인 프롤로그:

```assembly
function_name:
    push    rbp             ; 이전 베이스 포인터 저장
    mov     rbp, rsp        ; 새 베이스 포인터 설정
    sub     rsp, 32         ; 32 바이트의 스택 공간 할당 (지역 변수용)
    push    rbx             ; 호출자가 저장해야 하는 레지스터 보존
    push    r12
    push    r13
```

1. `push rbp`

    현재의 베이스 포인터(`rbp`)를 스택에 저장합니다.
    이는 이전 함수의 스택 프레임을 가리키는 포인터를 보존하는 것입니다.

    스택 포인터(`rsp`)는 자동으로 8바이트 감소합니다.

    이후 함수 에필로그에서 `pop rbp` 통해 이전 베이스 포인터 복원하는 데 사용됩니다.

2. `mov rbp, rsp`

    현재의 스택 포인터(`rsp`) 값을 새로운 베이스 포인터(`rbp`)로 설정합니다.
    이로써 새 함수의 스택 프레임 시작점이 정의됩니다.

3. `sub rsp, 32`

    스택 포인터를 32바이트 낮춰 지역 변수를 위한 공간을 할당합니다.
    할당되는 크기는 함수의 필요에 따라 다를 수 있습니다.

4. `push rbx`, `push r12`, `push r13`

    호출된 함수가 보존해야 하는 레지스터(callee-saved registers)의 현재 값을 스택에 저장합니다. callee-saved registers는 함수 실행 중 사용될 수 있으므로, 피호출자(callee)가 책임지고 원래 값을 보존해야 하는 레지스터를 의미합니다.

    **호출된 함수가 보존해야 하는 레지스터(callee-saved registers)**:
    - 이 레지스터들은 피호출자(callee)가 사용하기 전에 저장하고, 함수 종료 전에 복원해야 합니다.
    - 호출자(caller)는 이 레지스터들의 값이 함수 호출 전후로 변경되지 않을 것이라고 기대할 수 있습니다.

    ```assembly
    function_name:
        push    rbx             ; 피호출자가 저장하는 레지스터
        push    r12
        push    r13
        ; ... 함수 본문 ...
        pop     r13             ; 함수 종료 전 복원
        pop     r12
        pop     rbx
        ret
    ```

    여기서  `rbx`, `r12`, `r13`가 callee-saved registers입니다.
    함수(`function_name`)가 이 레지스터들을 사용하려면, 먼저 그 값을 저장하고 함수 종료 전에 복원해야 합니다.

### 레지스터 보존

```assembly
push rbx        ; 피호출자 저장 레지스터 보존
; ... 함수 본문 ...
pop rbx         ; 피호출자 저장 레지스터 복원
```

레지스터는 두 가지 범주로 나뉩니다:

1. **호출자 저장(Caller-saved) 레지스터**:

    함수 호출 전에 호출자가 보존해야 하는 레지스터입니다.
    피호출자가 자유롭게 사용할 수 있습니다.

    x86-64에서는 `rax`, `rcx`, `rdx`, `r8`-`r11` 등이 해당됩니다.

2. **피호출자 저장(Callee-saved) 레지스터**:

    함수 내에서 사용할 경우 피호출자 함수가 보존하고 복원해야 하는 레지스터입니다.
    호출자는 값이 보존될 것이라고 기대할 수 있습니다.

    x86-64에서는 `rbx`, `rbp`, `rsp`, `r12`-`r15` 등이 해당됩니다.

### 스택 정렬

x86-64 System V ABI 같은 일부 시스템에서는 함수 호출 시 스택을 16바이트 경계에 맞춰 정렬할 것을 요구합니다.
이 정렬은 성능 최적화와 특정 명령어 세트(예: `SIMD`)의 요구사항을 만족시키기 위함입니다.

예를 들어, `and rsp, -16` 명령어를 사용하여 스택 포인터를 16바이트 경계로 정렬할 수 있습니다.

```assembly
and rsp, -16    ; 스택 포인터를 16바이트 경계로 정렬
```

### 함수 프롤로그 최적화

컴파일러는 상황에 따라 함수 프롤로그를 최적화할 수 있습니다.

예를 들어, 지역 변수가 없고 다른 함수를 호출하지 않는 짧은 함수(leaf function)의 경우 프롤로그와 에필로그를 완전히 생략할 수 있습니다. 이를 통해 함수 호출 오버헤드를 줄일 수 있습니다.

또한, 컴파일러는 호출된 함수가 사용하는 레지스터 중, 호출자에게 영향을 미치지 않는 레지스터를 식별하여 불필요한 저장/복원 작업을 생략할 수 있습니다.

### 예외 처리

예외 처리 메커니즘이 있는 언어(예: C++)에서는 함수가 종료될 때 스택을 정리하는 과정이 중요합니다. 이러한 예외 처리 메커니즘은 *함수 호출 규약에 추가적인 요구사항을 부과*할 수 있습니다:

1. **스택 언와인딩(Stack Unwinding)**: 예외 발생 시 스택을 정리하고 적절한 예외 핸들러를 찾는 과정
2. **예외 정보 테이블**: 컴파일러는 예외 처리를 위한 추가 정보를 생성할 수 있습니다.

예를 들어, C++에서는 예외 처리를 위해 추가적인 테이블과 런타임 지원이 필요합니다.

```cpp
try {
    // 예외가 발생할 수 있는 코드
} catch (const std::exception& e) {
    // 예외 처리
}
```

이러한 구조는 컴파일러에 의해 특별한 함수 호출 시퀀스와 예외 테이블로 변환됩니다.

### 기타

- **레드존(Red Zone)**

    AMD64 시스템에서는 인터럽트가 발생하지 않는다는 전제 하에 함수 호출 없이도 128바이트의 "레드존"을 추가 스택 공간으로 사용할 수 있습니다.
    레드존을 사용하면 작은 데이터의 저장 및 조작을 위해 스택 포인터를 조정할 필요가 없으므로, 함수 호출 성능을 높일 수 있습니다.

    이 경우 작은 함수에서는 `sub rsp, X` 명령어를 생략할 수 있습니다.

    그러나, 인터럽트가 발생하면 레드존은 유효하지 않기 때문에 이 점을 고려하여 사용해야 합니다.

- **보안 고려사항**

    일부 컴파일러는 버퍼 오버플로우 공격을 방지하기 위해 추가적인 보안 체크를 프롤로그에 포함시킬 수 있습니다.

    대표적인 예로 Stack Canary가 있으며, 이는 함수 프롤로그에서 스택에 특정한 값(카나리 값)을 저장하고, 함수 에필로그에서 이 값을 확인하여 스택이 오염되었는지 여부를 판단하는 기법입니다.

## 함수 에필로그

함수 에필로그(Function Epilogue)는 함수 실행의 마지막 단계에서 수행되는 일련의 명령어 세트로, 함수가 종료될 때 실행됩니다.
이 과정에서는 함수의 실행 환경을 정리하고 호출자에게 제어를 반환합니다.

### 전형적인 함수 에필로그 단계

1. **반환 값 설정** (해당되는 경우): 함수가 반환 값을 갖는다면, 이 값을 반환할 준비를 합니다.
2. **저장된 레지스터 복원**: 프롤로그에서 저장된 레지스터 값을 복원합니다.
3. **스택 프레임 제거**: 함수 실행을 위해 생성된 스택 프레임을 제거합니다.
4. **이전 베이스 포인터 복원**: 프롤로그에서 저장한 이전 베이스 포인터를 복원합니다.
5. **반환 주소로 점프**: 반환 주소로 점프하여 호출자에게 제어를 반환합니다.

x86-64 아키텍처에서의 전형적인 에필로그:

```assembly
; 함수 에필로그
    mov     rax, [rbp-8]    ; 반환 값 설정 (예시)
    pop     r13             ; 저장된 레지스터 복원
    pop     r12
    pop     rbx
    mov     rsp, rbp        ; 스택 포인터 복원
    pop     rbp             ; 이전 베이스 포인터 복원
    ret                     ; 호출자로 반환
```

1. **`mov rax, [rbp-8]`**:

    반환 값은 일반적으로 특정 레지스터를 통해 처리됩니다:
    - x86-64에서는 주로 `rax` 레지스터를 사용하여 정수 또는 포인터 값을 반환합니다.
    - 부동 소수점 값의 경우 `xmm0` 레지스터를 사용합니다.
    - 큰 구조체의 경우, 호출자가 제공한 메모리 영역에 값을 복사하고 그 주소를 반환할 수 있습니다.

    위의 예제에서는 `rbp-8` 위치에 있는 값을 `rax` 레지스터로 이동시켜 반환 값을 설정합니다.
    이는 함수가 반환 값을 설정할 때 사용하는 방법입니다.

2. **`pop r13`**, **`pop r12`**, **`pop rbx`**:

    함수 프롤로그에서 저장했던 레지스터 `r13`, `r12`, `rbx`의 값을 스택에서 복원합니다.
    이들은 함수가 끝나기 전에 원래 값으로 복구되어야 하는 callee-saved 레지스터들입니다.

3. **`mov rsp, rbp`**:

    `mov rsp, rbp` 명령어로 *스택 포인터를 복원*합니다.
    즉, 스택 포인터(`rsp`)를 이전의 베이스 포인터(`rbp`) 값으로 복원하여, 스택 프레임을 정리합니다.
    이 명령어는 함수 호출 시 할당했던 스택 공간을 반환하는 효과가 있습니다.

4. **`pop rbp`**:

    `pop rbp`로 *베이스 포인터를 복원*합니다.
    즉, 이전 함수의 베이스 포인터 값을 스택에서 복원하여, `rbp`를 원래 값으로 되돌립니다.
    이는 함수 호출 전에 저장된 베이스 포인터를 복원하는 과정입니다.

5. **`ret`**:

    호출자에게 제어를 반환합니다.
    이 명령어는 스택에서 반환 주소를 꺼내어 해당 주소로 제어를 이동시킵니다.

### 함수 에필로그 최적화

함수 에필로그는 간단한 경우 최적화될 수 있습니다.

예를 들어, 간단한 리턴 값을 가지는 함수에서는 `mov` 명령어를 사용하지 않고도 리턴 값 설정이 가능할 수 있으며, 이를 통해 추가적인 성능 향상을 기대할 수 있습니다.

또한, 호출자-피호출자 간의 인터페이스가 명확하다면 불필요한 복원 작업을 생략하여 성능을 더욱 최적화할 수 있습니다.

그리고 함수의 마지막 작업이 다른 함수를 호출하는 것일 때, 현재 함수의 스택 프레임을 재사용하여 새로운 함수 호출을 최적화할 수 있습니다.(Tail Call Optimization)

```assembly
jmp other_function  ; 'call' 대신 'jmp' 사용
```

### 예외 처리 및 보안 고려사항

언어별로 함수 에필로그에 포함되는 예외 처리 코드가 다를 수 있습니다.

예를 들어, C++에서는 예외 처리 지원을 위해 스택 언와인딩 코드를 포함할 수 있습니다.

또한, 보안 관점에서 함수 종료 시점에 스택 오염을 탐지하기 위한 추가적인 코드가 포함될 수 있습니다.

Address Space Layout Randomization (ASLR)을 사용하여 프로그램의 중요한 데이터 영역의 주소를 무작위화하여 공격을 어렵게 만들 수 있습니다.

구조화된 예외 처리(SEH)는 Windows에서 사용되는 예외 처리 메커니즘으로, 하드웨어 및 소프트웨어 예외를 모두 처리할 수 있습니다.

## 기타

- [호출 규약](https://ko.wikipedia.org/wiki/%ED%98%B8%EC%B6%9C_%EA%B7%9C%EC%95%BD)
- [[컴퓨터 구조] 함수 호출 규약](https://narakit.tistory.com/145)
