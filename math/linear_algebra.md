# Linear algebra

## 선형대수

## 벡터 공간 (Vector Spaces)

- 부분 공간 (Subspaces)
- 선형 독립과 기저 (Linear Independence and Bases)
- 차원 (Dimension)

### 벡터

수학적으로 *'크기'와 '방향'을 가진 '양'을 나타내는 객체*입니다.
코딩에서 일반적으로 배열이나 슬라이스로 표현됩니다.

```go
// 벡터의 예
vector := []int{1, 0, 1, 1}
```

메시지 벡터 (Message Vector)란 전송하려는 원본 데이터를 이진수로 표현한 벡터입니다.

```go
message := []int{1, 0, 1, 1}  // 4비트 메시지 벡터
```

## 선형 변환 (Linear Transformations)

- 행렬 표현 (Matrix Representation)
- 핵과 치역 (Kernel and Range)

### 행렬

생성 행렬(Generator Matrix)을 코드로 나타내면 다음과 같습니다.

```go
// 메시지 벡터를 코드워드로 변환하는 데 사용되는 행렬입니다.
// 행렬의 각 행은 기본 코드워드를 나타냅니다.
G := [][]int{
    {1, 1, 1, 0, 0, 0, 0},
    {1, 0, 0, 1, 1, 0, 0},
    {0, 1, 0, 1, 0, 1, 0},
    {1, 1, 0, 1, 0, 0, 1},
}
```

### 선형 코드와 벡터 공간 이론

선형 코드는 주로 "벡터 공간"과 "선형 변환" 부분에 속합니다.
특히 "부분 공간"과 "행렬 표현"이 중요한 역할을 합니다.

#### 선형 코드

선형 코드는 *벡터 공간의 부분 공간인 코드*입니다.
여기서 벡터는 비트 문자열을 나타냅니다.

선형 코드는 오류 정정 코드의 한 종류로, 벡터 공간의 부분 공간으로 정의됩니다.
주요 개념은 다음과 같습니다:

1. 메시지를 비트 문자열(벡터)로 표현합니다.
2. 이 벡터들의 집합이 벡터 공간을 형성합니다.
3. 선형 코드는 이 벡터 공간의 선형 부분 공간입니다.
4. 선형 연산(덧셈, 스칼라 곱)이 코드워드에 대해 닫혀있습니다.

선형 코드는 생성 행렬 G를 사용하여 정의할 수 있습니다.
모든 코드워드는 메시지 벡터와 G의 곱으로 생성됩니다.

#### 선형 코드의 조건

코드 C가 선형이기 위한 조건은 다음과 같습니다:

1. 덧셈에 대해 닫혀 있어야 합니다

    만약 c1과 c2가 C의 원소라면, c1 + c2도 C의 원소여야 합니다.

2. 스칼라 곱에 대해 닫혀 있어야 합니다

    만약 c가 C의 원소이고 a가 스칼라(이 경우 0 또는 1)라면, ac도 C의 원소여야 합니다.

> 코드 C? 가능한 모든 코드워드의 집합을 의미합니다.
>
> 예를 들어, (7,4) Hamming 코드에서 C는 7비트 길이의 모든 유효한 코드워드의 집합입니다.
> 이 집합은 2^4 = 16개의 원소를 가집니다 (4비트 메시지를 7비트 코드워드로 변환하므로).

이러한 조건이 정립된 이유:

1. 수학적 일관성: 이 조건들은 벡터 공간의 정의와 일치합니다. 선형 코드를 벡터 공간의 부분 공간으로 볼 수 있게 해줍니다.
2. 실용성: 이 조건들을 만족하는 코드는 효율적으로 구현하고 분석할 수 있습니다.
3. 구조적 특성: 이 조건들은 코드에 수학적 구조를 부여하여, 그 성질을 체계적으로 연구할 수 있게 합니다.
4. 오류 정정 능력: 선형성은 오류 패턴을 쉽게 식별하고 정정할 수 있게 해줍니다.
5. 일반화 가능성: 이 조건들은 다양한 유형의 코드(예: 순환 코드, Reed-Solomon 코드 등)에 적용될 수 있는 일반적인 프레임워크를 제공합니다.

이 조건들은 수학적 엄밀성, 실용성, 그리고 통신 시스템의 요구사항을 모두 만족시키는 방식으로 정립되었습니다.
이는 순수 수학의 개념을 실제 공학 문제에 적용한 훌륭한 예시입니다.

이 조건들이 선형성의 정의가 된 배경을 이해하기 위해서는 선형대수학과 벡터 공간의 개념 발전 과정을 살펴봐야 합니다.

- 역사적 배경:
    19세기 말~20세기 초에 선형대수학이 체계화되었습니다.
    그리고 벡터 공간의 개념은 19세기 말과 20세기 초에 걸쳐 점진적으로 발전했습니다.
    이는 기하학, 대수학, 선형 방정식 시스템 등 *여러 수학 분야의 공통점을 추상화하는 과정*에서 나왔습니다.
    Giuseppe Peano, David Hilbert 등의 수학자들이 벡터 공간의 공리를 정립했습니다.

- 벡터 공간의 정의:
    수학자들은 벡터 공간을 정의할 때 다음과 같은 성질을 가져야 한다고 결정했습니다(수학의 정의와 공리 확립):
    - 벡터의 덧셈에 대해 닫혀 있어야 함
    - 스칼라 곱에 대해 닫혀 있어야 함
    - 결합법칙, 교환법칙, 분배법칙 등이 성립해야 함

    이러한 정의와 공리의 확립은 단순히 "결정하면 법칙이 되는" 것이 아닙니다.
    이는 오랜 시간에 걸친 관찰, 추상화, 검증, 합의의 결과입니다.
    이 정의가 널리 받아들여진 이유는 그것이 수학적으로 일관되고, 다양한 상황에 유용하게 적용될 수 있으며, 많은 중요한 정리들을 이끌어낼 수 있기 때문입니다.

    이러한 과정은 수학의 다른 영역에서도 유사하게 적용됩니다.
    수학적 정의와 공리는 단순한 규칙이 아니라, 현실 세계의 패턴을 추상화하고 일반화하여 강력한 도구로 만드는 과정의 결과입니다.

    **왜 이런 성질들이 선택되었는지**:

    - 직관적 이해:
        이 성질들은 우리가 '벡터'라고 생각하는 것의 기본적인 특성을 반영합니다.

        예를 들어, 두 힘(물리적 벡터)을 더하면 또 다른 힘이 되어야 합니다(덧셈에 대한 닫힘).

    - 유용성:
        이 성질들은 많은 수학적, 물리적 문제를 해결하는 데 유용함이 입증되었습니다.

        예를 들어, 선형 방정식 시스템을 해결할 때 이 성질들이 핵심적인 역할을 합니다.

    - 일반화:
        이 성질들은 다양한 수학적 구조(실수 벡터, 함수 공간, 다항식 등)에 공통적으로 적용될 수 있습니다.

    **어떻게 결정되었나**:

    - 관찰과 패턴 인식:
        수학자들은 여러 분야에서 유사한 패턴을 발견했습니다.

        예를 들어, 기하학적 벡터, 함수, 다항식 등이 유사한 규칙을 따르는 것을 관찰했습니다.

    - 추상화:
        이러한 공통점을 추출하여 더 일반적인 구조를 정의했습니다.

    - 검증과 정제:
        제안된 정의를 다양한 상황에 적용해보고, 필요에 따라 수정했습니다.
        여러 수학자들의 토론과 검증을 거쳤습니다.

    **공리적 접근**:

    수학에서 *공리*는 *더 이상의 증명 없이 참으로 받아들이는 기본 가정*입니다.
    벡터 공간의 성질들은 이러한 공리적 접근의 결과입니다.

    **합의와 표준화**:

    수학 커뮤니티 내에서의 광범위한 사용과 합의를 통해 이 정의가 표준화되었습니다.

    **지속적인 발전**:

    이 정의는 고정불변이 아니라, 필요에 따라 확장되거나 수정될 수 있습니다.

    예를 들어, 무한차원 벡터 공간을 다루기 위해 추가적인 조건이 도입되었습니다.

- 선형성의 정의:
    선형성은 '직선적인' 또는 '비례하는' 성질을 나타냅니다.
    수학적으로 이는 덧셈과 스칼라 곱에 대한 불변성으로 표현됩니다.

- 코딩 이론에의 적용:
    1940년대 후반, Claude Shannon과 Richard Hamming이 정보 이론과 오류 정정 코드의 기초를 세웠습니다.
    그들은 선형대수학의 개념을 통신 시스템에 적용했습니다.

- 선형 코드의 장점:
    - 인코딩과 디코딩이 효율적입니다 (행렬 연산으로 가능).
    - 오류 검출과 정정이 수학적으로 잘 정의됩니다.
    - 코드의 성질(예: 최소 거리)을 쉽게 분석할 수 있습니다.

선형성 증명은 다음과 같습니다.
- 덧셈에 대한 닫힘:
    - 두 코드워드 `c1 = G * m1`과 `c2 = G * m2`의 합은 다음과 같습니다:

        `c1 + c2 = G * m1 + G * m2 = G * (m1 + m2)`

    - 이는 다른 메시지 `(m1 + m2)`에 대한 유효한 코드워드입니다.

- 스칼라 곱에 대한 닫힘:
    - 코드워드 `c = G * m`에 대해 스칼라 `a`를 곱하면:

        `a * c = a * (G * m) = G * (a * m)`

    - 이는 다른 메시지 `(a * m)`에 대한 유효한 코드워드입니다.

#### 선형 코드 예제

간단한 예로 '(7,4) Hamming 코드'를 Golang으로 구현해보겠습니다.
이 코드는 4비트 메시지를 7비트 코드워드로 인코딩합니다.
- "4"는 원본 메시지의 비트 수를 나타냅니다.
- "7"은 인코딩된 코드워드의 비트 수를 나타냅니다.

이 예제는 '(7,4) Hamming' 코드'가 선형 코드임을 보여줍니다. 왜냐하면:
1. 모든 코드워드가 생성 행렬을 통해 생성됩니다.
2. 코드워드들의 합이 다른 유효한 코드워드가 됩니다.
3. 메시지의 선형 결합(덧셈)이 코드워드의 선형 결합과 일치합니다.

이러한 선형성 덕분에, 선형 코드는 효율적인 인코딩과 디코딩이 가능하며, 오류 검출 및 정정에 유용하게 사용됩니다.

```go
package main

import (
    "fmt"
)

// 생성 행렬
var G = [][]int{
    {1, 1, 1, 0, 0, 0, 0},
    {1, 0, 0, 1, 1, 0, 0},
    {0, 1, 0, 1, 0, 1, 0},
    {1, 1, 0, 1, 0, 0, 1},
}

// encode 함수는 특정 목적(메시지를 코드워드로 변환)을 나타냅니다.
// `생성 행렬 G`를 사용하여 `메시지 벡터`를 `코드워드`로 변환(인코딩)합니다. 
// 즉, 비트 메시지를 7비트 코드워드로 변환합니다.
// 이는 선형 변환을 구현한 것입니다.
func encode(message []int) []int {
    return multiply(message, G)
}

// multiply 함수는 일반적인 행렬 곱셈을 나타냅니다.
// '메시지 벡터와 G의 곱'은 메시지 벡터를 생성 행렬(G)과 곱하여 코드워드를 생성하는 과정입니다.
// 수학적으로는 행렬 곱셈이지만, 코드에서는 각 원소의 곱의 합으로 구현됩니다.
func multiply(message []int, G [][]int) []int {
    result := make([]int, len(G[0]))
    for i := 0; i < len(G); i++ {
        for j := 0; j < len(G[0]); j++ {
            // F₂ (2원소 체):
            // 이는 0과 1만을 원소로 가지는 수학적 구조입니다. 
            // 덧셈과 곱셈은 모듈로 2 연산으로 정의됩니다.
            result[j] += message[i] * G[i][j]
            // 모든 연산은 F₂ 위에서 수행됩니다 (모듈로 2 연산 사용).
            result[j] %= 2
        }
    }
    return result
}

// addCodewords 함수는 두 코드워드의 합을 계산합니다 (벡터 덧셈).
// 이 함수의 결과도 유효한 코드워드가 됩니다 (덧셈에 대한 닫힘 속성).
// 
// 두 코드워드 `c1 = G * m1`과 `c2 = G * m2`의 합은 다음과 같습니다:
// 
//     `c1 + c2 = G * m1 + G * m2 = G * (m1 + m2)`
func addCodewords(a, b []int) []int {
    result := make([]int, len(a))
    for i := range a {
        result[i] = (a[i] + b[i]) % 2
    }
    return result
}

// 메인 함수에서 다음을 확인합니다:
// - 두 개의 서로 다른 메시지를 인코딩합니다.
// - 인코딩된 코드워드들을 더합니다.
// - 원래 메시지들의 합을 인코딩한 결과와 비교합니다.
// - 두 결과가 같다면, 이는 코드의 선형성을 증명합니다.
func main() {
    // 메시지 벡터
    message1 := []int{1, 0, 1, 1}
    message2 := []int{1, 1, 0, 0}

    // 벡터 공간: 
    //     코드워드는 7비트 이진 벡터입니다. 
    //     이는 F₂⁷ (2원소 체 위의 7차원 벡터 공간)의 부분 공간을 형성합니다.
    //
    //     - F₂ (2원소 체): 
    //         이는 0과 1만을 원소로 가지는 수학적 구조입니다. 덧셈과 곱셈은 모듈로 2 연산으로 정의됩니다.
    //  
    //             result[j] += message[i] * G[i][j]
    //             result[j] %= 2  // 모듈로 2 연산
    //
    //     - F₂⁷ (7차원 벡터 공간):
    //         F₂를 기반으로 한 7차원 벡터 공간입니다.
    //         즉, 7개의 0 또는 1로 구성된 모든 가능한 벡터의 집합입니다.
    //         총 2⁷ = 128개의 가능한 벡터가 있습니다. 
    //         예를 들면:
    //          
    //             [0,0,0,0,0,0,0]
    //             [0,0,0,0,0,0,1]
    //             [0,0,0,0,0,1,0]
    //             ...
    //             [1,1,1,1,1,1,1]
    //
    //         모든 코드워드는 F₂⁷ 전체 공간(128개 벡터)의 원소입니다.
    // 
    //     - 부분 공간:
    //         (7,4) Hamming 코드의 모든 유효한 코드워드는 F₂⁷의 부분 집합입니다. 
    //         이 부분 집합이 벡터 공간의 성질을 만족하기 때문에 부분 공간이라고 합니다.
    //
    //         코드 예제에서 생성 가능한 모든 코드워드의 집합이 이 부분 공간입니다. 
    //         총 2⁴ = 16개의 코드워드가 있습니다 (4비트 메시지를 7비트 코드워드로 변환하므로).
    //
    //         원본 메시지는 4비트입니다.
    //         4비트로 표현할 수 있는 모든 가능한 조합의 수는 2⁴ = 16입니다.
    //         이는 0000부터 1111까지의 모든 이진수 조합을 의미합니다.
    //
    //         인코딩 과정은 각 4비트 메시지를 유일한 7비트 코드워드로 변환합니다.
    //         즉, 서로 다른 메시지는 서로 다른 코드워드로 인코딩됩니다.
    //
    //         따라서, 가능한 모든 메시지(16개)에 대해 각각 하나의 코드워드가 생성되므로,
    //         결과적으로 16개의 유효한 코드워드가 존재하게 됩니다.
    // 
    // codeword1, codeword2 결과는 메시지 벡터를 인코딩한 결과로,
    // 0과 1로만 구성된 7개의 원소를 가진 이진 벡터입니다.
    // 원본 메시지(4개의 원소를 가진 이진 벡터)보다 길며, 오류 검출/정정을 위한 추가 정보를 포함합니다.
    // 
    //     codeword := []int{1, 0, 1, 1, 0, 1, 0}
    codeword1 := encode(message1)
    codeword2 := encode(message2)

    fmt.Printf("메시지1: %v, 코드워드1: %v\n", message1, codeword1)
    fmt.Printf("메시지2: %v, 코드워드2: %v\n", message2, codeword2)

    // 코드워드 덧셈 (선형성 검증)
    sumCodewords := addCodewords(codeword1, codeword2)
    fmt.Printf("코드워드 합: %v\n", sumCodewords)

    // 메시지 합을 인코딩
    messageSum := []int{0, 1, 1, 1}  // 1011 + 1100 = 0111 (mod 2)
    codewordSum := encode(messageSum)
    fmt.Printf("메시지 합의 코드워드: %v\n", codewordSum)

    // 선형성 확인
    fmt.Printf("선형성 만족: %v\n", equal(sumCodewords, codewordSum))
}

func equal(a, b []int) bool {
    if len(a) != len(b) {
        return false
    }
    for i := range a {
        if a[i] != b[i] {
            return false
        }
    }
    return true
}
```

이 코드는 다음과 같은 선형 코드의 특성을 보여줍니다:

1. **벡터 표현**: 각 메시지와 코드워드는 비트 벡터로 표현됩니다.
2. **선형 인코딩**: `encode` 함수는 메시지 벡터와 생성 행렬의 선형 결합을 통해 코드워드를 생성합니다. 이는 벡터 공간에서의 선형 변환에 해당합니다.
3. **덧셈의 닫힘**: `addCodewords` 함수는 두 코드워드의 벡터 덧셈을 수행합니다. 이 연산의 결과도 유효한 코드워드입니다.
4. **선형성**: 두 메시지의 합을 인코딩한 결과와 각 메시지를 인코딩한 후 더한 결과가 같음을 보여줍니다. 이는 인코딩 함수의 선형성을 증명합니다.

이 예제는 선형 코드가 어떻게 벡터 공간의 성질을 만족하는지 보여줍니다:

- 코드워드들은 벡터 덧셈에 대해 닫혀 있습니다.
- 영 벡터(모두 0인 코드워드)가 존재합니다.
- 각 코드워드는 그 자신의 가법 역원을 가집니다 (모듈로 2 연산에서 각 원소의 역은 그 자신).

이러한 성질들 덕분에 선형 코드는 효율적인 인코딩과 디코딩이 가능하며, 오류 검출 및 정정에 유용하게 사용됩니다.

#### 선형 코드와 연계된 분야들

선형 코드는 선형대수학을 기반으로 하지만, 다음과 같은 분야에서도 중요하게 다뤄집니다:

a. 정보이론 (Information Theory)
    - 오류 정정 부호 (Error-Correcting Codes)
    - 채널 코딩 (Channel Coding)

b. 암호학 (Cryptography)
    - 공개키 암호 시스템 (Public-Key Cryptosystems)
    - 비밀 공유 (Secret Sharing)

c. 부호이론 (Coding Theory)
    - 선형 부호 (Linear Codes)
    - 순환 부호 (Cyclic Codes)
    - 리드-솔로몬 부호 (Reed-Solomon Codes)

d. 이산수학 (Discrete Mathematics)
    - 유한체 이론 (Finite Field Theory)
    - 조합론 (Combinatorics)

따라서, 선형 코드와 벡터 공간 이론의 관계는 주로 선형대수학의 "벡터 공간"과 "선형 변환" 부분에 속하지만, 이 개념은 정보이론, 암호학, 부호이론 등의 분야에서 광범위하게 응용됩니다. 특히 부호이론에서는 "선형 부호"라는 별도의 카테고리로 다뤄지며, 이는 선형대수학의 원리를 통신 시스템과 데이터 저장 시스템에 적용한 것입니다.

## 내적 공간 (Inner Product Spaces)

- 정규 직교 기저 (Orthonormal Bases)
- 그램-슈미트 과정 (Gram-Schmidt Process)
