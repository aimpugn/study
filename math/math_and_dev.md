# Math and dev

- [Math and dev](#math-and-dev)
    - [개요](#개요)
    - [이산 수학 (Discrete Mathematics)](#이산-수학-discrete-mathematics)
        - [다른 과목과의 연관성](#다른-과목과의-연관성)
        - [실무와의 연관 관계](#실무와의-연관-관계)
    - [행렬 (Matrices)](#행렬-matrices)
        - [다른 과목과의 연관성](#다른-과목과의-연관성-1)
        - [실무와의 연관 관계](#실무와의-연관-관계-1)
    - [선형대수학 (Linear Algebra)](#선형대수학-linear-algebra)
        - [다른 과목과의 연관성](#다른-과목과의-연관성-2)
        - [실무와의 연관 관계](#실무와의-연관-관계-2)
    - [확률론과 통계학 (Probability Theory and Statistics)](#확률론과-통계학-probability-theory-and-statistics)
        - [다른 과목과의 연관성](#다른-과목과의-연관성-3)
        - [실무와의 연관 관계](#실무와의-연관-관계-3)
    - [수치해석 (Numerical Analysis)](#수치해석-numerical-analysis)
        - [다른 과목과의 연관성](#다른-과목과의-연관성-4)
        - [실무와의 연관 관계](#실무와의-연관-관계-4)
    - [최적화 이론 (Optimization Theory)](#최적화-이론-optimization-theory)
        - [다른 과목과의 연관성](#다른-과목과의-연관성-5)
        - [실무와의 연관 관계](#실무와의-연관-관계-5)
    - [정보이론 (Information Theory)](#정보이론-information-theory)
        - [다른 과목과의 연관성](#다른-과목과의-연관성-6)
        - [실무와의 연관 관계](#실무와의-연관-관계-6)
    - [복잡도 이론 (Complexity Theory)](#복잡도-이론-complexity-theory)
        - [다른 과목과의 연관성](#다른-과목과의-연관성-7)
        - [실무와의 연관 관계](#실무와의-연관-관계-7)

## 개요

개발 경력이 쌓일수록 더 복잡하고 고도화된 시스템을 다루게 되며, 이때 깊이 있는 수학적 지식이 필요해집니다.

- 알고리즘 최적화: 복잡한 알고리즘의 시간/공간 복잡도를 분석하고 최적화하는 데 수학적 기초가 필요합니다.
- 대규모 시스템 설계: 분산 시스템, 데이터베이스 등의 설계에 그래프 이론, 확률론 등이 활용됩니다.
- 머신러닝/AI: 선형대수학, 확률론, 최적화 이론 등이 핵심 기반이 됩니다.
- 컴퓨터 그래픽스: 선형대수학, 기하학이 3D 렌더링, 애니메이션에 필수적입니다.
- 암호학: 정수론, 대수학이 현대 암호 시스템의 기초입니다.
- 성능 분석: 확률론, 통계학이 시스템 성능 예측과 분석에 사용됩니다.

이때 필요한 수학적 지식들을 커버하는 과목들은 다음과 같습니다.

- 이산 수학 (Discrete Mathematics)
- 행렬 (Matrices)
- 선형대수학 (Linear Algebra)
- 확률론과 통계학 (Probability Theory and Statistics)
- 수치해석 (Numerical Analysis)
- 최적화 이론 (Optimization Theory)
- 정보이론 (Information Theory)
- 복잡도 이론 (Complexity Theory)

이 과목들은 서로 밀접하게 연관되어 있으며, 실제 개발 과정에서 종종 함께 적용됩니다.

이러한 수학적 기초는 단순히 특정 알고리즘이나 기술을 구현하는 것을 넘어서, 다음과 같은 도움을 제공합니다.

1. 문제를 더 깊이 이해하고 효율적인 해결책을 설계하는 데 도움을 줍니다.
2. 새로운 기술과 알고리즘을 쉽게 학습하고 적용할 수 있는 기반을 제공합니다.
3. 수학적 기초를 바탕으로 더 복잡한 문제를 해결하고, 효율적이고 혁신적인 솔루션을 설계할 수 있게 됩니다.
4. 새로운 접근 방식을 창조하고, 기존 시스템의 한계를 극복하는 데 필수적입니다.
5. 빠르게 변화하는 기술 환경에서 새로운 개념을 빠르게 이해하고 적용할 수 있는 기반을 제공합니다.

## 이산 수학 (Discrete Mathematics)

이산 수학은 컴퓨터 과학의 기초를 제공합니다.
논리와 증명 기법은 알고리즘의 정확성을 증명하는 데 사용되며, 그래프 이론은 네트워크 분석과 데이터 구조 설계에 적용됩니다.
이산 수학의 일부 주제(예: 그래프 이론)는 행렬을 사용하여 표현될 수 있으며, 선형대수학의 기법을 활용하여 분석될 수 있습니다.

- 집합론: 집합의 개념, 연산, 관계
- 논리: 명제 논리, 술어 논리
- 증명 기법: 직접 증명, 귀납법, 모순법
- 조합론: 순열, 조합, 생성함수
- 그래프 이론: 그래프의 기본 개념, 트리, 네트워크
- 정수론: 소수, 합동, 암호학 기초
- 재귀: 재귀 관계, 점화식

### 다른 과목과의 연관성

이산 수학은 여러 수학 및 컴퓨터 과학 분야와 밀접한 관련이 있습니다.
다른 과목과의 연관성을 자세히 설명하겠습니다:

1. 선형대수학:
   - 그래프 이론의 인접 행렬 표현은 선형대수학의 행렬 개념을 활용합니다.
   - 벡터 공간 이론은 이산 구조를 대수적으로 분석하는 데 사용됩니다.

2. 확률론과 통계학:
   - 조합론은 확률 계산의 기초를 제공합니다.
   - 이산 확률 분포(예: 이항 분포, 포아송 분포)는 이산 수학의 개념을 기반으로 합니다.

3. 수치해석:
   - 이산 수학의 수열과 급수 이론은 수치 방법의 수렴성 분석에 사용됩니다.
   - 그래프 알고리즘은 많은 수치해석 문제(예: 희소 행렬 연산)에 적용됩니다.

4. 최적화 이론:
   - 그래프 이론은 네트워크 최적화 문제의 기초를 제공합니다.
   - 정수 프로그래밍은 이산 최적화 문제를 해결하는 데 사용됩니다.

5. 정보이론:
   - 코딩 이론은 이산 수학의 대수 구조를 기반으로 합니다.
   - 정보 엔트로피 개념은 이산 확률 분포와 관련이 있습니다.

6. 복잡도 이론:
   - 그래프 이론은 많은 NP-완전 문제의 기초가 됩니다.
   - 조합적 구조의 분석은 알고리즘의 시간 및 공간 복잡도 연구에 중요합니다.

7. 컴퓨터 알고리즘:
   - 그래프 알고리즘, 정렬 알고리즘, 검색 알고리즘 등 많은 기본 알고리즘이 이산 수학을 기반으로 합니다.
   - 알고리즘의 정확성 증명에 이산 수학의 증명 기법이 사용됩니다.

8. 프로그래밍 언어 이론:
   - 형식 언어와 오토마타 이론은 이산 수학의 개념을 기반으로 합니다.
   - 논리 프로그래밍은 술어 논리를 기반으로 합니다.

9. 데이터베이스 이론:
   - 관계 대수는 집합론과 논리학을 기반으로 합니다.
   - 데이터베이스 정규화 이론은 함수적 종속성 등 이산 수학의 개념을 사용합니다.

10. 암호학:
    - 정수론은 많은 암호화 알고리즘의 기초가 됩니다.
    - 암호 프로토콜의 안전성 증명에 이산 수학의 증명 기법이 사용됩니다.

### 실무와의 연관 관계

- 알고리즘 설계 및 분석: 그래프 알고리즘, 동적 프로그래밍 등
- 데이터 구조: 트리, 그래프 등의 효율적인 구현
- 논리 회로 설계: 부울 대수를 이용한 디지털 로직 설계
- 네트워크 프로토콜: 그래프 이론을 활용한 라우팅 알고리즘
   예: Dijkstra의 최단 경로 알고리즘은 네트워크 라우팅에 사용됩니다.

   ```python
   import heapq

   def dijkstra(graph, start):
       distances = {node: float('infinity') for node in graph}
       distances[start] = 0
       pq = [(0, start)]
       
       while pq:
           current_distance, current_node = heapq.heappop(pq)
           
           if current_distance > distances[current_node]:
               continue
           
           for neighbor, weight in graph[current_node].items():
               distance = current_distance + weight
               if distance < distances[neighbor]:
                   distances[neighbor] = distance
                   heapq.heappush(pq, (distance, neighbor))
       
       return distances

   # 사용 예:
   graph = {
       'A': {'B': 4, 'C': 2},
       'B': {'D': 3, 'E': 1},
       'C': {'B': 1, 'D': 5},
       'D': {'E': 2},
       'E': {}
   }
   print(dijkstra(graph, 'A'))
   ```

## 행렬 (Matrices)

행렬은 선형대수학의 핵심 도구입니다.
많은 선형대수학 개념이 행렬을 통해 표현되고 계산됩니다.

- 행렬의 정의와 연산: 덧셈, 뺄셈, 곱셈, 전치
- 행렬식과 역행렬
- 선형 방정식 시스템
- 고유값과 고유벡터
- 행렬의 대각화

### 다른 과목과의 연관성

1. 선형대수학:
   - 행렬은 선형대수학의 핵심 도구입니다. 선형 변환, 벡터 공간, 고유값/고유벡터 등 대부분의 선형대수 개념이 행렬을 통해 표현되고 연산됩니다.
   - 행렬 분해(예: LU 분해, QR 분해, 특이값 분해)는 선형대수학의 주요 주제입니다.

2. 이산 수학:
   - 그래프 이론에서 인접 행렬은 그래프 구조를 표현하는 데 사용됩니다.
   - 조합론에서 행렬은 순열과 조합을 표현하고 계산하는 데 활용됩니다.

3. 확률론과 통계학:
   - 공분산 행렬은 다변량 통계 분석에서 중요한 역할을 합니다.
   - 마르코프 체인은 전이 확률 행렬로 표현됩니다.
   - 주성분 분석(PCA)과 같은 차원 축소 기법에서 행렬 연산이 핵심적입니다.

4. 수치해석:
   - 선형 시스템 해법(예: 가우스 소거법, 반복법)은 행렬 연산을 기반으로 합니다.
   - 수치 적분, 미분 방정식 해법 등에서 행렬 방법이 사용됩니다.

5. 최적화 이론:
   - 선형 프로그래밍에서 제약 조건과 목적 함수를 행렬로 표현합니다.
   - 비선형 최적화에서 헤시안 행렬은 중요한 역할을 합니다.

6. 정보이론:
   - 오류 정정 코드에서 생성 행렬과 패리티 검사 행렬이 사용됩니다.
   - 데이터 압축 기법 중 일부는 행렬 변환을 사용합니다.

7. 복잡도 이론:
   - 행렬 곱셈 알고리즘의 복잡도 분석은 중요한 연구 주제입니다.
   - 그래프 알고리즘의 복잡도 분석에서 행렬 표현이 사용됩니다.

8. 컴퓨터 그래픽스:
   - 3D 변환(회전, 이동, 스케일링 등)은 행렬을 사용하여 표현됩니다.
   - 컴퓨터 비전에서 이미지 처리와 변환에 행렬 연산이 광범위하게 사용됩니다.

9. 양자 역학:
   - 양자 상태와 연산자는 행렬로 표현됩니다.
   - 밀도 행렬은 양자 시스템의 상태를 기술하는 데 사용됩니다.

10. 제어 이론:
    - 상태 공간 표현에서 시스템 동역학은 행렬 방정식으로 표현됩니다.
    - 칼만 필터와 같은 추정 알고리즘에서 행렬 연산이 중요합니다.

11. 신호 처리:
    - 이산 푸리에 변환(DFT)은 행렬 형태로 표현될 수 있습니다.
    - 디지털 필터 설계에서 행렬 방법이 사용됩니다.

12. 머신러닝과 데이터 과학:
    - 선형 회귀, 주성분 분석(PCA), 특이값 분해(SVD) 등 많은 알고리즘이 행렬 연산을 기반으로 합니다.
    - 신경망의 가중치는 행렬로 표현되며, 행렬 곱은 신경망 연산의 핵심입니다.

### 실무와의 연관 관계

- 컴퓨터 그래픽스: 3D 변환, 회전, 스케일링 등
- 데이터 분석: 주성분 분석(PCA), 특이값 분해(SVD) 등
- 추천 시스템: 협업 필터링에서의 행렬 분해
   예: 3D 그래픽스에서의 회전 행렬 사용

   ```python
   import numpy as np

   def rotate_3d(point, angle, axis):
       # 라디안으로 변환
       angle = np.radians(angle)
       
       # 회전 행렬 생성
       if axis == 'x':
           rotation_matrix = np.array([
               [1, 0, 0],
               [0, np.cos(angle), -np.sin(angle)],
               [0, np.sin(angle), np.cos(angle)]
           ])
       elif axis == 'y':
           rotation_matrix = np.array([
               [np.cos(angle), 0, np.sin(angle)],
               [0, 1, 0],
               [-np.sin(angle), 0, np.cos(angle)]
           ])
       elif axis == 'z':
           rotation_matrix = np.array([
               [np.cos(angle), -np.sin(angle), 0],
               [np.sin(angle), np.cos(angle), 0],
               [0, 0, 1]
           ])
       
       # 점 회전
       rotated_point = np.dot(rotation_matrix, point)
       return rotated_point

   # 사용 예:
   point = np.array([1, 0, 0])
   rotated_point = rotate_3d(point, 90, 'z')
   print(rotated_point)  # 약 [0, 1, 0]
   ```

## 선형대수학 (Linear Algebra)

선형대수학은 행렬 이론을 더 추상적이고 일반적인 수준으로 확장합니다.
벡터 공간과 선형 변환의 개념은 행렬 연산의 이론적 기초를 제공합니다.

- 벡터 공간과 부분공간
- 선형 독립과 기저
- 선형 변환
- 내적 공간
- 직교성과 최소제곱법
- 행렬의 Jordan 표준형
- 쌍대성

### 다른 과목과의 연관성

수학의 여러 분야뿐만 아니라 자연과학, 공학, 사회과학 등 다양한 학문 분야에서 핵심적인 도구로 사용됩니다.
선형대수학의 개념과 기법을 깊이 이해하는 것은 이러한 분야들을 학습하고 연구하는 데 매우 중요합니다.

1. 행렬론:
   - 선형대수학은 행렬 이론을 더 추상적이고 일반적인 수준으로 확장합니다.
   - 벡터 공간과 선형 변환의 개념은 행렬 연산의 이론적 기초를 제공합니다.

2. 이산 수학:
   - 그래프 이론에서 선형대수 기법(예: 스펙트럼 그래프 이론)이 사용됩니다.
   - 코딩 이론에서 선형 코드는 벡터 공간 이론을 기반으로 합니다.

3. 확률론과 통계학:
   - 다변량 통계 분석에서 선형대수 개념이 광범위하게 사용됩니다.
   - 주성분 분석(PCA), 요인 분석 등의 차원 축소 기법은 선형대수를 기반으로 합니다.
   - 공분산 행렬과 그 고유값 분석은 많은 통계적 방법의 핵심입니다.

4. 수치해석:
   - 선형 시스템 해법, 최소제곱법, 고유값 문제 등 많은 수치 알고리즘이 선형대수를 기반으로 합니다.
   - 반복법(예: 共역구배법)은 벡터 공간의 성질을 이용합니다.

5. 최적화 이론:
   - 선형 프로그래밍은 선형대수학의 직접적인 응용입니다.
   - 비선형 최적화에서도 선형 근사와 2차 근사에 선형대수가 사용됩니다.

6. 정보이론:
   - 오류 정정 코드의 설계와 분석에 선형대수 기법이 사용됩니다.
   - 데이터 압축 알고리즘(예: SVD를 이용한 압축)에 선형대수가 응용됩니다.

7. 복잡도 이론:
   - 행렬 곱셈의 복잡도는 중요한 연구 주제입니다(예: Strassen 알고리즘).
   - 양자 컴퓨팅의 이론적 기초에 선형대수가 필수적입니다.

8. 미분방정식:
   - 선형 미분방정식 시스템의 해법에 선형대수 기법이 사용됩니다.
   - 고유값 문제는 많은 물리 시스템의 안정성 분석에 중요합니다.

9. 함수해석학:
   - 무한차원 벡터 공간(힐베르트 공간 등)의 이론은 선형대수의 개념을 확장한 것입니다.
   - 푸리에 해석은 선형대수의 개념을 함수 공간으로 확장한 것으로 볼 수 있습니다.

10. 컴퓨터 그래픽스:
    - 3D 변환, 투영, 음영 처리 등에 선형대수가 광범위하게 사용됩니다.
    - 컴퓨터 비전에서 이미지 처리와 패턴 인식에 선형대수 기법이 응용됩니다.

11. 양자 역학:
    - 양자 상태는 힐베르트 공간의 벡터로 표현되며, 양자 연산자는 선형 변환으로 모델링됩니다.
    - 양자 얽힘, 중첩 등의 개념은 텐서 곱 공간을 이용해 설명됩니다.

12. 제어 이론:
    - 선형 시스템 이론은 선형대수를 기반으로 합니다.
    - 상태 공간 표현, 제어 가능성, 관측 가능성 등의 개념에 선형대수가 사용됩니다.

13. 머신러닝과 데이터 과학:
    - 선형 회귀, 서포트 벡터 머신, 신경망 등 많은 알고리즘이 선형대수를 기반으로 합니다.
    - 차원 축소, 특징 추출, 데이터 변환 등에 선형대수 기법이 광범위하게 사용됩니다.

14. 암호학:
    - 공개키 암호 시스템 중 일부(예: 타원곡선 암호)는 선형대수를 기반으로 합니다.
    - 행렬을 이용한 암호화 방식에서 선형대수 지식이 필요합니다.

15. 경제학:
    - 입출력 분석, 선형 경제 모델 등에 선형대수가 사용됩니다.
    - 포트폴리오 이론에서 분산과 공분산의 계산에 행렬 연산이 사용됩니다.

### 실무와의 연관 관계

- 머신러닝: 선형 회귀, 주성분 분석(PCA), 지지벡터기계(SVM) 등
- 신호 처리: 푸리에 변환, 웨이블릿 변환 등
- 최적화 문제: 선형 프로그래밍, 컨벡스 최적화 등
- 검색 엔진: PageRank 알고리즘 (고유벡터 계산)
   예: 간단한 선형 회귀 구현

   ```python
   import numpy as np

   def linear_regression(X, y):
       # 정규 방정식을 사용한 선형 회귀
       # β = (X^T X)^(-1) X^T y
       X = np.column_stack((np.ones(len(X)), X))  # 절편을 위해 1을 추가
       beta = np.linalg.inv(X.T.dot(X)).dot(X.T).dot(y)
       return beta

   # 사용 예:
   X = np.array([1, 2, 3, 4, 5])
   y = np.array([2, 4, 5, 4, 5])

   beta = linear_regression(X, y)
   print("Intercept:", beta[0])
   print("Slope:", beta[1])

   # 예측
   X_new = np.array([6, 7, 8])
   y_pred = beta[0] + beta[1] * X_new
   print("Predictions:", y_pred)
   ```

## 확률론과 통계학 (Probability Theory and Statistics)

데이터 분석과 머신러닝 알고리즘의 기초, 시스템 성능 평가 및 예측, A/B 테스팅 및 실험 설계,
신뢰성 있는 소프트웨어 설계 등에 활용됩니다.

- 확률 공간과 확률 변수
- 조건부 확률과 베이즈 정리
- 확률 분포 (이산 및 연속)
- 기대값과 분산
- 대수의 법칙과 중심극한정리
- 추정과 가설검정
- 회귀분석과 상관분석
- 베이지안 통계

### 다른 과목과의 연관성

- 이산 수학의 조합론과 밀접한 관련
- 선형대수학의 개념들(예: 행렬 연산)이 다변량 통계에서 사용됨
- 최적화 이론의 기초를 제공 (예: 최대 우도 추정)

### 실무와의 연관 관계

- 추천 시스템 개발
- 이상 탐지 알고리즘
- 네트워크 트래픽 분석
- 금융 공학 애플리케이션

예시 코드 (간단한 베이지안 A/B 테스트):

```python
import numpy as np
from scipy import stats

def bayesian_ab_test(conversions_A, trials_A, conversions_B, trials_B, samples=100000):
    # 베타 분포에서 샘플링
    A = stats.beta.rvs(conversions_A + 1, trials_A - conversions_A + 1, size=samples)
    B = stats.beta.rvs(conversions_B + 1, trials_B - conversions_B + 1, size=samples)
    
    # B가 A보다 더 나은 확률 계산
    prob_B_better = (B > A).mean()
    
    return prob_B_better

# 사용 예
conversions_A, trials_A = 200, 1000
conversions_B, trials_B = 220, 1000

prob = bayesian_ab_test(conversions_A, trials_A, conversions_B, trials_B)
print(f"B가 A보다 더 나을 확률: {prob:.2%}")
```

## 수치해석 (Numerical Analysis)

과학 계산 및 시뮬레이션 소프트웨어 개발, 컴퓨터 그래픽스와 물리 엔진, 금융 모델링 및 리스크 분석,
머신러닝 알고리즘의 효율적 구현 등에 활용됩니다.

- 수치적 오차와 안정성
- 선형 시스템 해법
- 보간법과 근사
- 수치 미분과 적분
- 상미분 방정식의 수치해법
- 고유값 문제
- 최적화 알고리즘

### 다른 과목과의 연관성

- 선형대수학의 실제적 응용
- 최적화 이론의 알고리즘 구현에 필수적
- 미적분학의 컴퓨터 구현

### 실무와의 연관 관계

- 3D 렌더링 엔진 개발
- 기상 예측 모델 구현
- 로보틱스 제어 시스템
- 유한요소법을 이용한 공학 시뮬레이션

예시 코드 (뉴턴-랩슨 법을 이용한 근 찾기):

```python
def newton_raphson(f, df, x0, tol=1e-6, max_iter=100):
    x = x0
    for _ in range(max_iter):
        fx = f(x)
        if abs(fx) < tol:
            return x
        dfx = df(x)
        if dfx == 0:
            return None  # 미분값이 0이면 중단
        x = x - fx / dfx
    return None  # 최대 반복 횟수 초과

# 사용 예: x^2 - 5 = 0 의 양의 근 찾기
f = lambda x: x**2 - 5
df = lambda x: 2*x

root = newton_raphson(f, df, 1)
print(f"근사해: {root}")
print(f"f(root): {f(root)}")
```

## 최적화 이론 (Optimization Theory)

알고리즘 설계와 효율성 향상, 리소스 할당 문제 해결, 머신러닝 모델의 학습 과정 이해,
네트워크 흐름 최적화 등에 활용됩니다.

- 선형 프로그래밍
- 비선형 프로그래밍
- 정수 프로그래밍
- 컨벡스 최적화
- 동적 프로그래밍
- 휴리스틱과 메타휴리스틱 알고리즘
- 제약 최적화

### 다른 과목과의 연관성

- 선형대수학의 응용
- 미적분학의 극값 문제와 연관
- 확률론과 결합하여 확률적 최적화 문제 다룸

### 실무와의 연관 관계

- 물류 시스템 최적화
- 포트폴리오 관리 시스템
- 추천 시스템 개선
- 네트워크 라우팅 최적화

예시 코드 (단순한 경사 하강법):

```python
import numpy as np

def gradient_descent(f, grad_f, x0, learning_rate=0.1, max_iter=1000, tol=1e-6):
    x = x0
    for _ in range(max_iter):
        grad = grad_f(x)
        if np.linalg.norm(grad) < tol:
            return x
        x = x - learning_rate * grad
    return x

# 사용 예: f(x, y) = x^2 + y^2 의 최소값 찾기
f = lambda x: x[0]**2 + x[1]**2
grad_f = lambda x: np.array([2*x[0], 2*x[1]])

x0 = np.array([1.0, 1.0])
result = gradient_descent(f, grad_f, x0)
print(f"최소점: {result}")
print(f"최소값: {f(result)}")
```

## 정보이론 (Information Theory)

데이터 압축 알고리즘 이해와 개발, 통신 시스템 설계, 머신러닝에서의 정보 이득 개념,
암호화 시스템 설계 등에 활용됩니다.

- 엔트로피와 정보량
- 데이터 압축
- 채널 용량
- 오류 정정 코드
- 암호학 기초
- 콜모고로프 복잡도

### 다른 과목과의 연관성

- 확률론과 밀접한 관련
- 이산 수학의 코딩 이론과 연결
- 복잡도 이론과 연관

### 실무와의 연관 관계

- 데이터 압축 소프트웨어 개발
- 네트워크 프로토콜 최적화
- 보안 시스템 구현
- 자연어 처리 알고리즘

예시 코드 (간단한 엔트로피 계산):

```python
import math

def calculate_entropy(probabilities):
    return -sum(p * math.log2(p) for p in probabilities if p > 0)

# 사용 예
probs = [0.5, 0.25, 0.125, 0.125]
entropy = calculate_entropy(probs)
print(f"엔트로피: {entropy} 비트")
```

## 복잡도 이론 (Complexity Theory)

알고리즘의 효율성 평가, 문제의 난이도 분류 및 이해, 최적화 문제 해결 전략 수립,
암호 시스템의 안전성 분석 등에 활용됩니다.

- 계산 복잡도 클래스 (P, NP, NP-완전, PSPACE 등)
- 시간 복잡도와 공간 복잡도
- 리덕션과 완전성
- 근사 알고리즘
- 랜덤화 알고리즘
- 평균 케이스 분석

### 다른 과목과의 연관성

- 이산 수학의 그래프 이론과 연관
- 알고리즘 설계와 밀접한 관련
- 정보이론의 콜모고로프 복잡도와 연결

### 실무와의 연관 관계

- 대규모 데이터 처리 시스템 설계
- 최적화 문제 해결 (예: 스케줄링, 라우팅)
- 암호화 알고리즘 개발
- 인공지능 시스템의 성능 분석

예시 코드 (간단한 시간 복잡도 측정):

```python
import time
import matplotlib.pyplot as plt

def measure_time(func, n):
    start = time.time()
    func(n)
    return time.time() - start

def linear_algorithm(n):
    return sum(range(n))

def quadratic_algorithm(n):
    return sum(i*j for i in range(n) for j in range(n))

sizes = range(100, 1001, 100)
linear_times = [measure_time(linear_algorithm, n) for n in sizes]
quadratic_times = [measure_time(quadratic_algorithm, n) for n in sizes]

plt.plot(sizes, linear_times, label='Linear')
plt.plot(sizes, quadratic_times, label='Quadratic')
plt.xlabel('Input Size')
plt.ylabel('Time (seconds)')
plt.legend()
plt.title('Time Complexity Comparison')
plt.show()
```
