# Go pointer

Go에서의 포인터에 대한 완벽 가이드를 제공하겠습니다. 이 가이드는 당신의 질문들을 중심으로 구성되며, Go의 포인터 시스템에 대한 깊이 있는 이해를 제공할 것입니다.

1. 포인터의 기본 개념

포인터는 메모리 주소를 저장하는 특별한 변수입니다. Go에서 포인터는 타입 안전성을 제공하며, C언어와 달리 포인터 연산을 허용하지 않습니다.

기본 문법:
- `&변수`: 변수의 메모리 주소를 얻습니다.
- `*포인터`: 포인터가 가리키는 값을 얻습니다 (역참조).

예시:

```go
x := 5
ptr := &x   // x의 메모리 주소를 ptr에 저장
fmt.Println(*ptr)  // 5 출력 (ptr이 가리키는 값)
*ptr = 10   // x의 값을 10으로 변경
fmt.Println(x)  // 10 출력
```

2. 값 타입 vs 참조 타입

Go에는 값 타입과 참조 타입이 있습니다:

- 값 타입: int, float, bool, struct 등
- 참조 타입: slice, map, channel, interface 등

참조 타입은 내부적으로 포인터를 사용하여 데이터를 참조합니다.

3. 질문 1에 대한 답변

`&`를 사용하여 바로 인자로 넘길 수 있는 경우와 그렇지 않은 경우의 차이는 주로 다음과 같은 이유로 발생합니다:

a) 임시 변수의 주소:
Go 1.17 이전에는 임시 변수나 리터럴의 주소를 직접 사용할 수 없었습니다. 예를 들어:

```go
// Go 1.17 이전에는 컴파일 에러
func(p *int) {}(&int(5))
```

그러나 Go 1.17부터는 이러한 제한이 완화되어, 많은 경우 임시 변수의 주소를 직접 사용할 수 있게 되었습니다.

b) 메서드 리시버:
메서드의 리시버가 포인터 타입인 경우, 값 타입의 변수에 대해 자동으로 주소를 취합니다.

```go
type S struct{}
func (s *S) M() {}

var s S
s.M()  // &s.M()와 동일하게 동작
```

c) 맵 요소:
맵의 요소는 주소를 직접 얻을 수 없습니다. 이는 맵의 내부 구현 때문입니다.

```go
m := map[string]int{"key": 5}
// &m["key"] // 컴파일 에러
value := m["key"]
ptr := &value // 이렇게 해야 함
```

d) 인터페이스의 동적 값:
인터페이스의 동적 값의 주소를 직접 얻을 수 없습니다.

```go
var i interface{} = 5
// &i.(int) // 컴파일 에러
value := i.(int)
ptr := &value // 이렇게 해야 함
```

4. 질문 2에 대한 답변

메서드 리시버에 따른 사용 가능성:

a) 값 리시버로 정의된 메서드:
- 값과 포인터 모두로 호출 가능
- 값 리시버는 원본 데이터를 변경할 수 없음

```go
type S struct{ data int }
func (s S) M() { fmt.Println(s.data) }

var s S
s.M()    // 값으로 호출 가능
(&s).M() // 포인터로도 호출 가능 (Go가 자동으로 역참조)
```

b) 포인터 리시버로 정의된 메서드:
- 포인터로 호출 가능
- 값으로도 호출 가능 (Go가 자동으로 주소를 취함)
- 원본 데이터를 변경할 수 있음

```go
type S struct{ data int }
func (s *S) M() { s.data++ }

var s S
(&s).M() // 포인터로 호출 가능
s.M()    // 값으로도 호출 가능 (Go가 자동으로 &s.M()으로 변환)
```

c) 인터페이스 구현 시 주의사항:
- 값 타입은 값 리시버 메서드만 구현한 인터페이스를 만족
- 포인터 타입은 값 리시버와 포인터 리시버 메서드 모두 구현한 인터페이스를 만족

```go
type I interface { M() }

type S struct{}
func (s S) M()  {} // 값 리시버
func (s *S) N() {} // 포인터 리시버

var s S
var i I
i = s    // OK: 값 타입은 값 리시버 메서드를 구현한 인터페이스를 만족
i = &s   // OK: 포인터 타입은 값 리시버와 포인터 리시버 메서드 모두 구현한 인터페이스를 만족
```

5. 최선의 방법

a) 일관성: 한 타입에 대해 모든 메서드를 값 리시버나 포인터 리시버 중 하나로 통일하는 것이 좋습니다.

b) 포인터 리시버 사용이 권장되는 경우:
- 메서드가 리시버를 수정해야 하는 경우
- 리시버가 크기가 큰 구조체인 경우 (성능 향상)
- 일관성을 위해 일부 메서드가 포인터 리시버를 필요로 하는 경우

c) 값 리시버 사용이 권장되는 경우:
- 리시버가 불변(immutable)이어야 하는 경우
- 기본 타입, 작은 구조체, 또는 단순한 값들의 경우

d) 인터페이스 구현 시:
인터페이스를 구현할 때는 주로 포인터 리시버를 사용하는 것이 더 유연합니다. 이는 포인터 타입이 값 리시버와 포인터 리시버 메서드 모두를 만족할 수 있기 때문입니다.

결론:
Go의 포인터 시스템은 유연성과 안전성을 동시에 제공합니다. 메서드 리시버 선택 시 일관성, 성능, 그리고 의도된 사용 방식을 고려해야 합니다. 대부분의 경우 포인터 리시버를 사용하는 것이 더 유연하고 효율적이지만, 각 상황에 맞는 최적의 선택을 해야 합니다.
