# strings

- [strings](#strings)
    - [golang에서의 문자열](#golang에서의-문자열)
        - [슬라이싱으로 멀티 바이트 문자열 자르기의 문제](#슬라이싱으로-멀티-바이트-문자열-자르기의-문제)
        - [`rune` 사용하기](#rune-사용하기)
    - [스택 메모리에서의 문자열 처리](#스택-메모리에서의-문자열-처리)
        - [스택 메모리에서의 문자열 처리](#스택-메모리에서의-문자열-처리-1)
        - [문자열 데이터의 힙 저장](#문자열-데이터의-힙-저장)
    - [`문자열 + 문자열` 시 이뤄지는 일](#문자열--문자열-시-이뤄지는-일)
    - [2. 어셈블리 수준 분석](#2-어셈블리-수준-분석)
    - [3. CPU 수준 분석](#3-cpu-수준-분석)
    - [4. 메모리 수준 분석](#4-메모리-수준-분석)
    - [5. 운영체제 수준 분석](#5-운영체제-수준-분석)
    - [6. 하드웨어 수준 상호작용](#6-하드웨어-수준-상호작용)
    - [`strings.Builder` 통한 문자열 연결](#stringsbuilder-통한-문자열-연결)
        - [strings.Builder가 더 효과적인 이유](#stringsbuilder가-더-효과적인-이유)
        - [구체적인 성능 차이 예시](#구체적인-성능-차이-예시)

## golang에서의 문자열

- Go 언어에서 문자열은 UTF-8 인코딩을 사용
- UTF-8은 가변 길이 문자 인코딩이므로, 각 문자는 1바이트에서 4바이트까지의 공간을 차지할 수 있다
- 인덱스를 사용하여 문자열의 특정 바이트에 접근하면 예기치 않은 결과를 얻을 수 있다. 가령 멀티바이트 문자를 다룰 때

### 슬라이싱으로 멀티 바이트 문자열 자르기의 문제

```go
str := "한글입니다"
fmt.Println(str[0]) // "한"이 아니라 237 출력된다
```

- `str[0]`: 첫 번째 바이트의 값만 반환
- `"한"` 문자는 UTF-8로 인코딩되어 3바이트를 차지하므로, 첫 번째 바이트만 반환되어 전체 문자를 얻지 못한다

### `rune` 사용하기

- Go 언어에서 Unicode 코드 포인트를 나타내는 데 사용된다
- 각 `rune`은 32비트(4바이트) 값으로, Unicode 표준에 따라 문자를 유일하게 식별한다
- 문자열을 `rune` 슬라이스로 변환하면, Go는 문자열의 각 문자를 `UTF-8`에서 `UTF-32`로 디코딩하여 각 문자의 Unicode 코드 포인트를 얻는다

```go
str := "한글입니다"
fmt.Println([]rune(str)[0]) // Unicode 코드 포인트: 54620
fmt.Println(string([]rune(str)[0])) // 한

fmt.Println(string([]rune("abcd")[0])) // a
fmt.Println(string([]rune("12314")[3])) // 1
fmt.Println(string([]rune("d가나dc다")[2]))  // 나
fmt.Println(string([]rune("d가나dc다")[3])) // d
```

- `[]rune(str)`
    - str의 각 문자를 rune으로 변환하여 새로운 rune 슬라이스를 생성
    - 이 과정에서,
        - Go는 문자열의 각 바이트를 확인하고,
        - UTF-8 인코딩된 문자를 디코딩하여 각 문자의 Unicode 코드 포인트를 얻는다
- `[]rune(str)[0]`
    - rune 슬라이스의 첫 번째 요소를 참조한다
    - 이는 문자열의 첫 번째 문자의 Unicode 코드 포인트를 나타낸다

> [코드 포인트(code point)](https://en.wikipedia.org/wiki/Code_point)?
>
> 유니코드 문자를 식별하기 위한 고유한 숫자 값
> 유니코드 표준에서 각 문자는 유니코드 코드 포인트라는 고유한 숫자 식별자를 갖는다
> 이 숫자 식별자는 문자의 유니코드 "이름"이며, 이를 통해 문자를 참조하고 인코딩할 수 있다

Go에서 문자열은 내부적으로 두 부분의 데이터를 포함하는 구조체로 처리됩니다: 문자열이 가리키는 데이터의 시작 주소와 문자열의 길이입니다. 이러한 방식은 Go의 문자열 처리 메커니즘에서 핵심적인 부분을 차지하며, 문자열이 불변(immutable)임을 보장합니다.

## 스택 메모리에서의 문자열 처리

Go에서 문자열은 기본적으로 불변(immutable)이며, 문자열의 데이터는 힙에 저장되고, 문자열 변수 자체는 스택에 저장됩니다.
문자열 변수는 데이터를 가리키는 *포인터*와 *문자열의 길이 및 용량 정보*를 포함합니다.
이 정보는 스택에 저장되는데, 일반적으로 포인터 크기(시스템에 따라 4바이트 또는 8바이트), 길이, 용량 각각에 대한 정보가 필요합니다.

> **Go에서의 문자열 불변성**
>
> Go 언어에서 문자열은 불변(immutable)입니다.
> 이는 문자열이 한 번 생성되면 그 내용을 변경할 수 없다는 의미입니다.
> 문자열의 일부를 수정하려 할 경우, 수정된 새로운 문자열이 메모리에 생성되고, 해당 문자열을 가리키는 포인터는 이 새로운 문자열의 위치를 가리키도록 업데이트 됩니다. Go에서 문자열의 문자열이 변경될 때마다 새로운 메모리 할당이 이루어지므로, 문자열을 조작하는 코드를 작성할 때는 이러한 특성을 고려해야 합니다.
>
> 따라서 한 함수에서 생성된 문자열이 다른 함수로 전달될 때, 문자열 데이터의 복사본을 만들 필요가 없습니다.
> 대신 문자열을 가리키는 포인터만 복사되므로, 메모리 사용과 성능 저하를 방지할 수 있습니다.
>
> 문자열이 힙에 저장되는 이유 중 하나는 문자열의 크기가 실행 시간에 결정될 수 있기 때문입니다.
> 컴파일 타임에 크기가 확정되지 않는 데이터는 힙에 저장되어 동적으로 관리됩니다.
> 이는 Go의 가비지 컬렉터가 메모리를 효율적으로 관리할 수 있게 하며, 사용되지 않는 메모리를 자동으로 회수합니다.
>
> 불변성의 장점:
>
> - 메모리 관리를 단순화함
> - 메모리를 효율적으로 사용 가능
> - 프로그램의 안정성을 향상시킴
> - 다중 스레드 환경에서 데이터의 일관성과 안정성을 보장하는 데 기여하는 등 동시성(concurrency) 관리에 유리

따라서 64비트 시스템 경우 24바이트의 스택 메모리를 사용합니다.
- 포인터: 8바이트
- 길이: 8바이트
- 용량: 8바이트

### 스택 메모리에서의 문자열 처리

- **포인터**

    문자열 데이터의 시작 주소를 가리키는 포인터입니다.
    이 포인터는 스택에 저장됩니다.

    이 포인터는 힙에 할당된 문자열 데이터를 가리키거나, 리터럴 문자열의 경우, 바이너리에 포함된 데이터 섹션을 가리킬 수 있습니다.

- **길이 및 용량 정보**

    문자열의 길이와 용량 정보도 스택에 저장됩니다.
    문자열을 효율적으로 관리하기 위해 필요한 메타데이터입니다.

    이는 문자열이 실제로 몇 개의 바이트를 차지하고 있는지를 나타냅니다.

Go의 아키텍처에 따라 (예: 64비트 시스템에서) 포인터와 길이 정보는 각각 8바이트를 차지합니다.
따라서 일반적으로 문자열을 변수로 가질 때, 해당 변수는 총 16바이트의 스택 공간을 사용하게 됩니다 (포인터 8바이트 + 길이 8바이트).

```go
func example() {
    s := "hello, world"
    fmt.Println(s)
}
```

위 코드에서 문자열 `s`는 스택에 저장되며, `s`의 데이터는 다음과 같이 구성됩니다:
- 포인터: 문자열 `"hello, world"`의 메모리 주소를 가리킵니다.
- 길이: 12 바이트 (문자열 `"hello, world"`의 길이)

### 문자열 데이터의 힙 저장

Go에서 문자열은 불변(immutable)이기 때문에, 한 번 생성된 문자열의 내용은 변경될 수 없습니다.
이는 문자열을 안전하고 효율적으로 관리할 수 있게 해주며, 여러 변수가 동일한 문자열 데이터를 공유할 수 있도록 합니다.

문자열의 실제 데이터는 힙에 저장됩니다.
이는 문자열이 불변성을 가지며, 동적으로 메모리가 할당되어야 하기 때문입니다.

Go의 메모리 관리 시스템은 이러한 방식으로 스택과 힙을 효율적으로 사용하여, 메모리 오버헤드를 최소화하고 성능을 최적화합니다.문자열이 함수 내에서만 사용되고 외부로 참조되지 않는 경우, 컴파일러의 이스케이프 분석에 의해 스택에 최적화하여 할당될 수도 있습니다. 그러나 일반적으로 문자열 데이터는 힙에 저장되는 것이 기본입니다.

예를 들어, 다음과 같은 코드를 살펴보겠습니다:

```go
func main() {
    str1 := "Hello, World!" // 컴파일 시점에 이미 정의되어 있으며, 실행 시에는 힙에 저장한다.
    str2 := str1 // `str2`는 `str1`이 가리키는 같은 힙 메모리 주소를 가리키게 된다.
}
```

여기서 `str1`은 "Hello, World!"라는 문자열을 가리키고 있습니다. 이 문자열은 컴파일 시점에 이미 정의되어 있으며, 실행 시에는 힙에 저장됩니다. `str1` 변수는 이 문자열의 위치를 가리키는 포인터와 문자열의 길이 정보를 스택에 저장합니다.

`str2 := str1`라는 코드는 `str2`가 `str1`과 동일한 문자열 데이터를 가리키도록 합니다.
이 경우, 새로운 문자열 데이터가 힙에 할당되는 것이 아니라, `str2`는 `str1`이 가리키는 같은 힙 메모리 주소를 가리키게 됩니다.
따라서, `str1`과 `str2`는 메모리의 동일한 위치를 공유하게 되며, 이는 메모리 사용을 효율적으로 만듭니다.

아래 코드에서 `"Hello, World!"`는 프로그램의 실행 파일에 포함된 리터럴로 저장됩니다.
그러나 Go에서는 이 문자열 리터럴의 메모리 위치를 가리키는 포인터가 스택에 저장됩니다.
실제 문자열 데이터는 변경할 수 없으므로, 이 데이터는 보통 실행 파일의 데이터 섹션에 안전하게 저장되어 있습니다.

```go
func main() {
    s := "Hello, World!"
    fmt.Println(s)
}
```

문자열을 변경하려고 할 때, Go는 새로운 문자열을 생성하고, 필요한 메모리를 힙에 할당합니다. 예를 들어:

```go
// 문자열을 변경 예제
func main() {
    str1 := "Hello, World!"
    str2 := str1
    str3 := str1 + " How are you?" // "Hello, World! How are you?"라는 새로운 문자열이 메모리에 할당
}
```

`str3`를 생성할 때, "Hello, World! How are you?"라는 새로운 문자열이 메모리에 할당됩니다.
이 문자열은 기존의 `str1`이 가리키는 데이터를 기반으로 하지만, 추가된 " How are you?" 부분과 함께 새로운 메모리 공간에 저장됩니다.
이 과정에서 `str1`과 `str2`가 가리키는 원본 문자열은 변경되지 않으며, `str3`는 새로운 힙 메모리 주소를 가리키게 됩니다.

```go
func main() {
    // `base`와 `name`은 두 개의 별도의 문자열이며 각각 스택에 포인터가 저장
    base := "Hello, "
    name := "Jane"
    // `+`연산자는 새로운 문자열을 생성하고, 필요한 메모리를 힙에 할당
    // 
    greeting := base + name // base + name 연산은 새로운 문자열 "Hello, Jane"를 힙에 할당
    //^^^^^^
    //greeting은 이 새로운 힙 메모리 주소를 가리키는 포인터를 스택에 저장 
    fmt.Println(greeting)
}
```

## `문자열 + 문자열` 시 이뤄지는 일

```go
result := "Hello" + " " + "World"
```

1. 컴파일 단계: Go 코드를 기계어로 변환

    ```go
    package main

    func main() {
        result := "Hello" + " " + "World"
        println(result)
    }
    ```

    이 코드는 다음과 같은 단계를 거칩니다:

    1) **어휘 분석 및 구문 분석**: 코드를 토큰으로 분리하고 추상 구문 트리(AST)를 생성합니다.
    2) **타입 체크 및 중간 표현(IR) 생성**: 코드의 타입을 검사하고 중간 표현을 생성합니다.
    3) **최적화**: 컴파일러는 문자열 연결을 최적화할 기회를 찾습니다. 이 경우, 세 문자열이 모두 상수이므로 컴파일 시간에 연결될 수 있습니다.
    4) **코드 생성**: 최종적으로 기계어 코드를 생성합니다.

2. 어셈블리 수준 분석

    Go 컴파일러가 생성한 어셈블리 코드를 살펴보겠습니다 (x86-64 아키텍처 기준):

    ```assembly
    TEXT main.main(SB) /tmp/sandbox891961257/prog.go
        prog.go:3    0x45c560    64488b0c25f8ffffff    MOVQ FS:0xfffffff8, CX
        prog.go:3    0x45c569    483b6110              CMPQ 0x10(CX), SP
        prog.go:3    0x45c56d    762c                  JBE 0x45c59b
        prog.go:3    0x45c56f    4883ec18              SUBQ $0x18, SP
        prog.go:3    0x45c573    48896c2410            MOVQ BP, 0x10(SP)
        prog.go:3    0x45c578    488d6c2410            LEAQ 0x10(SP), BP
        prog.go:4    0x45c57d    48c744240800000000    MOVQ $0x0, 0x8(SP)
        prog.go:4    0x45c586    488d05f3510000        LEAQ 0x51f3(IP), AX
        prog.go:4    0x45c58d    4889442408            MOVQ AX, 0x8(SP)
        prog.go:5    0x45c592    e8c9faffff            CALL runtime.printstring(SB)
        prog.go:6    0x45c597    488b6c2410            MOVQ 0x10(SP), BP
        prog.go:6    0x45c59c    4883c418              ADDQ $0x18, SP
        prog.go:6    0x45c5a0    c3                    RET
    ```

    1. **스택 설정**: 함수의 스택 프레임을 설정합니다.

        ```assembly
        SUBQ $0x18, SP
        MOVQ BP, 0x10(SP)
        LEAQ 0x10(SP), BP
        ```

    2. **문자열 로드**: 연결된 문자열 "Hello World"의 주소를 레지스터에 로드합니다.

        ```assembly
        LEAQ 0x51f3(IP), AX
        MOVQ AX, 0x8(SP)
        ```

    3. **출력 함수 호출**: `runtime.printstring` 함수를 호출하여 문자열을 출력합니다.

        ```assembly
        CALL runtime.printstring(SB)
        ```

3. CPU 수준 분석

    CPU에서 이 어셈블리 코드가 실행될 때 다음과 같은 일이 일어납니다:

    1. **명령어 페치**: CPU는 프로그램 카운터(PC)가 가리키는 메모리 주소에서 명령어를 가져옵니다.

    2. **명령어 디코드**: 가져온 명령어를 해석하여 수행할 작업을 결정합니다.

    3. **명령어 실행**:
        - 레지스터 조작 (e.g., `MOVQ`, `LEAQ`)
        - 메모리 접근 (e.g., 문자열 데이터 로드)
        - 산술/논리 연산
        - 분기 및 점프 (e.g., `JBE`, `CALL`)

    4. **파이프라이닝 및 병렬 실행**: 현대 CPU는 여러 명령어를 동시에 처리하기 위해 파이프라이닝과 슈퍼스칼라 아키텍처를 사용합니다.

4. 메모리 수준 분석

    메모리 관점에서 문자열 연결 과정을 살펴보겠습니다:

    1. **정적 메모리**:
        컴파일 시 연결된 "Hello World" 문자열은 실행 파일의 데이터 섹션에 저장됩니다.

    2. **스택 메모리**:
        함수 호출 시 스택에 로컬 변수와 함수 파라미터를 위한 공간이 할당됩니다.

    3. **캐시 상호작용**:
        CPU는 문자열 데이터를 메인 메모리에서 가져와 캐시(L1, L2, L3)에 로드합니다.
        캐시 히트율이 높을수록 성능이 향상됩니다.

    4. **가상 메모리**:
        프로세스의 가상 주소 공간은 물리적 메모리와 페이지 테이블을 통해 매핑됩니다.

5. 운영체제 수준 분석

    운영체제는 이 과정에서 여러 중요한 역할을 수행합니다:

    1. **프로세스 관리**:
        프로그램을 실행할 때 새 프로세스를 생성합니다.
        프로세스에 메모리 공간을 할당하고 초기화합니다.

    2. **메모리 관리**:
        가상 메모리 시스템을 통해 프로세스의 메모리 접근을 관리합니다.
        필요시 페이지 폴트를 처리하고 스와핑을 수행합니다.

    3. **파일 시스템 상호작용**:
        프로그램 실행 파일을 디스크에서 메모리로 로드합니다.

    4. **I/O 관리**:
        `println` 함수 호출 시 표준 출력으로의 쓰기 작업을 관리합니다.

    5. **인터럽트 처리**:
        하드웨어 인터럽트와 소프트웨어 인터럽트(시스템 콜)를 처리합니다.

6. 하드웨어 수준 상호작용

    1. **CPU와 메모리 버스**:
        CPU는 메모리 버스를 통해 RAM과 통신하여 명령어와 데이터를 주고받습니다.

    2. **캐시 일관성**:
        멀티코어 시스템에서 캐시 일관성 프로토콜(예: MESI)이 각 코어의 캐시 상태를 동기화합니다.

    3. **DMA (Direct Memory Access)**:
        I/O 작업 시 DMA 컨트롤러가 CPU 개입 없이 메모리와 I/O 장치 간 데이터 전송을 관리할 수 있습니다.

    4. **메모리 컨트롤러**:
        DRAM 리프레시, 메모리 접근 타이밍 등을 관리합니다.

---

1. 프로그램 로딩 및 초기화

    1. 운영체제가 Go 프로그램의 실행 파일을 디스크에서 메인 메모리로 로드합니다.
    2. 프로그램의 코드 섹션, 데이터 섹션이 각각 해당하는 메모리 영역에 배치됩니다.
        - 데이터 섹션: "Hello", " ", "World" 문자열 상수가 포함됨
    3. 운영체제는 프로그램을 위한 새 프로세스를 생성하고, 가상 메모리 공간을 설정합니다.
    4. CPU의 프로그램 카운터(PC)가 main 함수의 시작 주소를 가리키도록 설정됩니다.

2. 문자열 연결 연산 시작

    1. CPU가 문자열 연결 명령어를 fetch합니다.
    2. CPU가 이 명령어를 decode하고, 문자열 연결 연산이 필요하다고 판단합니다.

3. 메모리 할당

    1. Go 런타임이 새로운 문자열을 저장할 메모리 공간을 요청합니다.
    2. CPU가 메모리 할당 루틴을 실행합니다:
        a. 힙 메모리 관리자를 호출하여 필요한 크기(이 경우 11바이트 + 문자열 헤더)의 메모리 블록을 찾습니다.
        b. 적절한 크기의 빈 메모리 블록이 없다면, 운영체제에 새 메모리 페이지를 요청할 수 있습니다.
    3. 메모리 컨트롤러가 요청받은 메모리 주소 범위를 물리적 메모리에 매핑합니다.

4. 문자열 데이터 로드

    1. CPU가 원본 문자열들("Hello", " ", "World")의 메모리 주소를 레지스터에 로드합니다.
    2. 각 문자열에 대해:
        a. CPU가 메모리 컨트롤러에 해당 주소의 데이터를 요청합니다.
        b. 메모리 컨트롤러가 요청을 처리하고 데이터를 메모리 버스를 통해 CPU로 전송합니다.
        c. 이 과정에서 캐시(L1, L2, L3)가 사용될 수 있으며, 캐시 미스 시 메인 메모리에서 데이터를 가져옵니다.

5. 새 문자열 생성

    1. CPU가 새로 할당된 메모리 영역의 주소를 레지스터에 로드합니다.
    2. CPU가 첫 번째 문자열 "Hello"의 데이터를 새 메모리 영역으로 복사합니다:
        a. CPU의 ALU(Arithmetic Logic Unit)가 복사 연산을 수행합니다.
        b. 메모리 쓰기 연산이 메모리 버스를 통해 메모리 컨트롤러로 전달됩니다.
        c. 메모리 컨트롤러가 해당 데이터를 물리적 메모리에 기록합니다.
    3. 같은 과정으로 " "와 "World" 문자열을 순차적으로 새 메모리 영역에 복사합니다.

6. 문자열 헤더 설정

    1. CPU가 새 문자열의 헤더 정보(포인터와 길이)를 설정합니다:
        a. 포인터: 새로 할당된 메모리의 시작 주소
        b. 길이: 11 (모든 문자열의 길이 합)
    2. 이 헤더 정보를 스택이나 레지스터에 저장합니다.

7. 결과 저장 및 정리

    1. CPU가 새 문자열의 헤더 정보를 `result` 변수에 할당합니다.
    2. 필요 없어진 임시 데이터나 레지스터 값들을 정리합니다.

8. 가비지 컬렉션 고려사항 (백그라운드 프로세스)

    1. Go의 가비지 컬렉터가 주기적으로 실행되어 더 이상 참조되지 않는 메모리를 식별하고 해제합니다.
    2. 이 과정은 별도의 고루틴으로 백그라운드에서 실행될 수 있습니다.

9. 프로세스 종료 (프로그램 끝)

    1. 프로그램 실행이 완료되면, 운영체제가 프로세스 리소스를 정리합니다:
        a. 할당된 메모리를 해제합니다.
        b. 파일 디스크립터를 닫습니다.
        c. 프로세스 정보를 시스템에서 제거합니다.

이 전체 과정에서 CPU, 메모리, 캐시, 운영체제, Go 런타임이 긴밀하게 상호작용하며, 각 단계마다 하드웨어 인터럽트, 캐시 동기화, 메모리 배리어 등 다양한 저수준 작업들이 수반됩니다.

이러한 복잡한 과정이 매우 빠른 속도로 실행되어, 프로그래머 입장에서는 단순한 "+" 연산자로 보이는 것입니다. 이 과정의 효율성은 하드웨어의 성능, 운영체제의 최적화, 그리고 Go 컴파일러와 런타임의 구현에 크게 의존합니다.

---

문자열 연결 연산의 전체 과정을 컴파일 단계부터 하드웨어 수준까지 상세히 설명하겠습니다. 이 과정은 Go 프로그램에서 문자열 연결이 어떻게 처리되는지를 심층적으로 보여줍니다.

```go
package main

func main() {
    result := "Hello" + " " + "World"
    println(result)
}
```

1. Go 코드를 기계어로 변환

    1. **어휘 분석 및 구문 분석**:
        a. 어휘 분석 (Lexical Analysis):
            - *정규 표현식*과 *유한 상태 기계(Finite State Machine)*를 사용하여 `package`, `main`, `func` 등 소스 코드를 토큰 스트림으로 변환합니다.
            - Go의 경우, 식별자, 키워드, 리터럴, 연산자 등을 구분합니다.
            - Unicode 문자 처리와 줄 바꿈 정규화 등 Go 특유의 어휘 규칙을 적용합니다.

        b. 구문 분석 (Syntax Analysis):
            - LL(1) 또는 LALR(1) 파싱 알고리즘을 사용하여 토큰 스트림을 파싱합니다.
            - Go의 문법 규칙 (예: 세미콜론 자동 삽입)을 적용합니다.
            - 추상 구문 트리(AST)를 생성하여 코드의 구조를 표현합니다.
            - 추상 구문 트리(AST) 생성 시 Go의 변수 선언, 문자열 리터럴, 연산자, 함수 호출 등을 고려한 노드 구조를 사용합니다.

    2. **타입 체크 및 중간 표현(IR) 생성**:
        a. 타입 체크:
            - 구조적 타입 시스템(Structural Type System)을 이용한 타입 호환성 검사를 수행합니다.(예: 문자열 리터럴의 타입이 string인지 확인)
            - 인터페이스 만족 여부, 타입 어서션, 타입 스위치 등 Go 특유의 타입 관련 기능을 처리합니다.
            - 암시적 타입 변환 및 타입 추론을 수행합니다.

        b. 중간 표현(IR) 생성:
            - SSA(Static Single Assignment) 형태의 중간 표현을 생성:
                - φ(phi) 함수를 사용하여 제어 흐름 합류 지점에서의 변수 값을 표현합니다.
                - 메모리 연산(load/store)을 명시적으로 표현하여 포인터 분석을 용이하게 합니다.
            - Go의 동시성 프리미티브(고루틴, 채널)를 IR 레벨에서 표현합니다.

        > SSA?
        >
        > SSA는 각 변수가 정확히 한 번만 할당되는 형태로, 최적화에 유용합니다.

    3. **최적화**:
        - 기본 블록 최적화:
            - 도달 불가능한 코드 제거
            - 기본 블록 병합 및 재정렬

        - 데이터 흐름 분석:
            - 상수 전파(Constant Propagation)
            - 사용되지 않는 코드 제거(Dead Code Elimination)
            - 공통 부분식 제거(Common Subexpression Elimination)

        - 루프 최적화:
            - 루프 불변 코드 이동(Loop Invariant Code Motion)
            - 루프 펼치기(Loop Unrolling)
            - 벡터화(Vectorization) - SIMD 명령어 활용

        - 인라인 확장:
            - 호출 사이트 휴리스틱을 사용한 선택적 인라인 확장
            - 가상 메서드 호출의 최적화 (인터페이스 메서드 호출 등)

        - 이스케이프 분석:
            - 스택 할당이 가능한 객체 식별
            - 불필요한 힙 할당 제거

        - 동시성 관련 최적화:
            - 채널 통신 최적화
            - 고루틴 스케줄링 힌트 삽입

        - 상수 폴딩:
            - "Hello" + " " + "World"를 컴파일 시간에 "Hello World"로 평가합니다.

        - 불필요한 임시 변수 제거

    4. **코드 생성**:
        - 목표 아키텍처(예: x86-64)에 맞는 어셈블리 코드 생성

        - 명령어 선택:
            - 동적 프로그래밍 또는 트리 패턴 매칭 알고리즘을 사용하여 최적의 명령어 시퀀스 선택
            - 목표 아키텍처의 특수 명령어(예: x86의 SIMD 명령어) 활용

        - 레지스터 할당:
            - 그래프 컬러링 알고리즘을 사용한 전역 레지스터 할당
            - 레지스터 간섭 그래프(Register Interference Graph) 구성 및 분석
            - 스필(Spill) 비용을 고려한 최적 할당 전략 수립

        - 메모리 레이아웃 결정:
            - 구조체 필드 정렬 최적화
            - 캐시 라인 고려한 데이터 배치

        - 저수준 최적화:
            - 피킹(Peephole) 최적화를 통한 명령어 시퀀스 개선
            - 분기 예측을 고려한 조건부 점프 최적화

        - 플랫폼 특화 코드 생성:
            - 다양한 CPU 아키텍처(x86, ARM, RISC-V 등)에 대한 최적화된 코드 생성
            - 운영체제별 ABI(Application Binary Interface) 준수

## 2. 어셈블리 수준 분석

생성된 어셈블리 코드 (x86-64 기준):

```assembly
TEXT main.main(SB) /tmp/sandbox891961257/prog.go
    prog.go:3    0x45c560    64488b0c25f8ffffff    MOVQ FS:0xfffffff8, CX
    prog.go:3    0x45c569    483b6110              CMPQ 0x10(CX), SP
    prog.go:3    0x45c56d    762c                  JBE 0x45c59b
    prog.go:3    0x45c56f    4883ec18              SUBQ $0x18, SP
    prog.go:3    0x45c573    48896c2410            MOVQ BP, 0x10(SP)
    prog.go:3    0x45c578    488d6c2410            LEAQ 0x10(SP), BP
    prog.go:4    0x45c57d    48c744240800000000    MOVQ $0x0, 0x8(SP)
    prog.go:4    0x45c586    488d05f3510000        LEAQ 0x51f3(IP), AX
    prog.go:4    0x45c58d    4889442408            MOVQ AX, 0x8(SP)
    prog.go:5    0x45c592    e8c9faffff            CALL runtime.printstring(SB)
    prog.go:6    0x45c597    488b6c2410            MOVQ 0x10(SP), BP
    prog.go:6    0x45c59c    4883c418              ADDQ $0x18, SP
    prog.go:6    0x45c5a0    c3                    RET
```

주요 부분 설명:

1. **스택 프레임 설정**:

   ```assembly
   SUBQ $0x18, SP
   MOVQ BP, 0x10(SP)
   LEAQ 0x10(SP), BP
   ```

   - 24바이트(0x18) 스택 공간 할당
   - 이전 베이스 포인터 저장 및 새 베이스 포인터 설정

2. **문자열 로드**:

   ```assembly
   LEAQ 0x51f3(IP), AX
   MOVQ AX, 0x8(SP)
   ```

   - 문자열 "Hello World"의 주소를 AX 레지스터에 로드
   - 이 주소를 스택에 저장 (println 함수의 인자로 사용)

3. **출력 함수 호출**:

   ```assembly
   CALL runtime.printstring(SB)
   ```

   - Go 런타임의 printstring 함수 호출

4. **정리 및 반환**:

   ```assembly
   MOVQ 0x10(SP), BP
   ADDQ $0x18, SP
   RET
   ```

   - 베이스 포인터 복원
   - 스택 포인터 조정
   - 함수 반환

## 3. CPU 수준 분석

CPU에서 어셈블리 코드 실행 과정:

1. **명령어 페치 (Instruction Fetch)**:
   - 프로그램 카운터(PC)가 가리키는 메모리 주소에서 명령어를 가져옵니다.
   - 명령어 캐시(I-cache)를 사용하여 페치 속도를 높입니다.

2. **명령어 디코드 (Instruction Decode)**:
   - 페치된 명령어를 해석하여 수행할 작업을 결정합니다.
   - 복잡한 x86-64 명령어는 마이크로 연산(micro-ops)으로 분해될 수 있습니다.

3. **명령어 실행 (Execute)**:
   - 레지스터 조작: MOVQ, LEAQ 등을 사용해 데이터 이동
   - 메모리 접근: 문자열 데이터 로드, 스택 조작
   - 산술/논리 연산: SUBQ, ADDQ 등을 사용한 계산
   - 분기 및 점프: JBE, CALL 등을 사용한 프로그램 흐름 제어

4. **파이프라이닝 및 병렬 실행**:
   - 현대 CPU는 다단계 파이프라인을 사용하여 여러 명령어를 동시에 처리합니다.
   - 슈퍼스칼라 아키텍처를 통해 한 클럭 사이클에 여러 명령어를 실행합니다.
   - 분기 예측, 투기적 실행 등의 기술을 사용하여 성능을 향상시킵니다.

5. **메모리 상호작용**:
   - 데이터 캐시(D-cache)를 사용하여 메모리 접근 속도를 높입니다.
   - 캐시 미스 발생 시, 메모리 계층 구조(L2, L3 캐시, 메인 메모리)를 탐색합니다.

6. **명령어 리타이어 (Instruction Retire)**:
   - 실행이 완료된 명령어의 결과를 커밋합니다.
   - 레지스터 파일과 메모리의 상태를 업데이트합니다.

## 4. 메모리 수준 분석

메모리 관점에서의 문자열 연결 과정:

1. **정적 메모리 (Static Memory)**:
   - 컴파일 시 연결된 "Hello World" 문자열은 실행 파일의 .rodata (읽기 전용 데이터) 섹션에 저장됩니다.
   - 프로그램 로드 시 이 섹션은 가상 메모리의 읽기 전용 페이지에 매핑됩니다.

2. **스택 메모리 (Stack Memory)**:
   - main 함수 호출 시 스택 프레임이 생성됩니다 (24바이트).
   - 로컬 변수, 함수 인자, 반환 주소 등이 이 스택 프레임에 저장됩니다.

3. **캐시 상호작용 (Cache Interaction)**:
   - CPU는 문자열 데이터를 메인 메모리에서 가져와 캐시 계층(L1, L2, L3)에 로드합니다.
   - 공간 지역성(Spatial Locality)과 시간 지역성(Temporal Locality)을 활용하여 캐시 효율을 높입니다.
   - 캐시 라인 단위(보통 64바이트)로 데이터를 가져와 연속된 메모리 접근을 최적화합니다.

4. **가상 메모리 (Virtual Memory)**:
   - 프로세스의 가상 주소 공간은 페이지 테이블을 통해 물리적 메모리에 매핑됩니다.
   - 페이지 크기(일반적으로 4KB)단위로 메모리가 관리됩니다.
   - TLB(Translation Lookaside Buffer)를 사용하여 가상-물리 주소 변환을 가속화합니다.

5. **메모리 정렬 (Memory Alignment)**:
   - 문자열 데이터는 효율적인 메모리 접근을 위해 적절히 정렬됩니다 (예: 8바이트 경계).
   - 정렬되지 않은 메모리 접근은 성능 저하를 일으킬 수 있습니다.

6. **메모리 보호 (Memory Protection)**:
   - 코드 섹션은 실행 가능하지만 쓰기 불가능으로 설정됩니다.
   - 데이터 섹션(.rodata)은 읽기 전용으로 설정되어 우발적인 수정을 방지합니다.

## 5. 운영체제 수준 분석

운영체제의 역할:

1. **프로세스 관리 (Process Management)**:
   - 프로그램 실행 시 새 프로세스 생성 (fork 및 exec 시스템 콜 사용).
   - 프로세스에 고유한 PID(Process ID) 할당.
   - 프로세스 컨텍스트 (레지스터 상태, 메모리 맵 등) 관리.

2. **메모리 관리 (Memory Management)**:
   - 가상 메모리 시스템을 통한 프로세스의 메모리 접근 관리.
   - 페이지 테이블 설정 및 유지보수.
   - 요구 페이징(Demand Paging)을 통한 효율적인 메모리 사용.
   - 페이지 폴트 처리 및 필요시 스와핑(Swapping) 수행.

3. **파일 시스템 상호작용 (File System Interaction)**:
   - 프로그램 실행 파일을 디스크에서 메모리로 로드 (mmap 시스템 콜 사용 가능).
   - 실행 파일의 각 섹션(.text, .data, .rodata 등)을 적절한 메모리 영역에 매핑.

4. **I/O 관리 (I/O Management)**:
   - println 함수 호출 시 표준 출력으로의 쓰기 작업 관리.
   - 버퍼링을 통한 I/O 최적화 (예: line buffering, full buffering).

5. **인터럽트 처리 (Interrupt Handling)**:
   - 하드웨어 인터럽트 (예: 타이머, I/O 완료) 처리.
   - 소프트웨어 인터럽트 (시스템 콜) 처리.
   - 인터럽트 벡터 테이블 관리 및 적절한 핸들러로 제어 전환.

6. **스케줄링 (Scheduling)**:
   - CPU 시간을 여러 프로세스에 할당 (예: Round Robin, CFS).
   - 문맥 교환(Context Switch) 수행.

7. **보안 (Security)**:
   - 프로세스 격리를 통한 메모리 보호.
   - 특권 수준(Ring 레벨) 관리를 통한 시스템 자원 보호.

## 6. 하드웨어 수준 상호작용

하드웨어 컴포넌트 간 상호작용:

1. **CPU와 메모리 버스 (CPU and Memory Bus)**:
   - 프론트 사이드 버스(FSB) 또는 더 현대적인 QPI(Intel)/Infinity Fabric(AMD)를 통한 통신.
   - 주소 버스, 데이터 버스, 제어 버스를 통한 메모리 읽기/쓰기 요청 전송.

2. **캐시 일관성 (Cache Coherence)**:
   - MESI 프로토콜 등을 사용하여 멀티코어 시스템에서 캐시 상태 동기화.
   - 스누핑(Snooping) 또는 디렉토리 기반 프로토콜을 통한 캐시 일관성 유지.

3. **DMA (Direct Memory Access)**:
   - I/O 작업 시 DMA 컨트롤러가 CPU 개입 없이 메모리와 I/O 장치 간 데이터 전송 관리.
   - 시스템 버스 사용을 최소화하여

## `strings.Builder` 통한 문자열 연결

`strings.Builder`를 사용하면 `+` 연산자 사용하는 것보다 더 효과적으로 문자열을 붙일 수 있습니다.

```go
func concatenateWithBuilder(strs ...string) string {
    var builder strings.Builder
    for _, s := range strs {
        builder.WriteString(s)
    }
    return builder.String()
}
```

1. **Builder 초기화**:
   - `strings.Builder` 객체가 생성됩니다.
   - 내부적으로 작은 크기의 초기 버퍼가 할당됩니다.

2. **문자열 추가**:
    `WriteString` 메서드가 호출될 때마다:
    a. 현재 버퍼에 충분한 공간이 있는지 확인합니다.
    b. 공간이 부족하면 버퍼 크기를 늘립니다 (일반적으로 2배로).
    c. 새 문자열을 버퍼의 끝에 복사합니다.

3. **최종 문자열 생성**:
   - `String` 메서드가 호출되면 내부 버퍼의 내용을 바탕으로 새 문자열을 생성합니다.

단순 문자열 연결(`+` 연산자)과의 비교해보면:

```go
func concatenateWithPlus(strs ...string) string {
    result := ""
    for _, s := range strs {
        result += s
    }
    return result
}
```

이 경우의 과정:

1. 매 연결 연산(`+=`)마다:
   - 새로운 문자열을 위한 메모리가 할당됩니다.
   - 기존 문자열과 새 문자열이 새 메모리 공간에 복사됩니다.
   - 이전 문자열은 가비지 컬렉션의 대상이 됩니다.

2. 이 과정이 매 반복마다 발생하여 많은 임시 문자열과 메모리 할당이 생깁니다.

### strings.Builder가 더 효과적인 이유

1. **메모리 할당 최소화**:
   - `strings.Builder`는 필요에 따라 버퍼를 늘리지만, 대부분의 경우 한 번 또는 몇 번의 재할당만으로 충분합니다.
   - 반면, `+` 연산자는 매 연결마다 새 메모리를 할당합니다.

2. **불필요한 복사 방지**:
   - `strings.Builder`는 기존 데이터를 새 위치로 복사하는 대신, 기존 버퍼에 추가합니다.
   - `+` 연산자는 매번 전체 문자열을 새 위치로 복사합니다.

3. **가비지 컬렉션 부하 감소**:
   - `strings.Builder`는 임시 문자열을 생성하지 않아 GC 부하가 적습니다.
   - `+` 연산자는 많은 임시 문자열을 생성하여 GC 부하를 증가시킵니다.

4. **예측 가능한 성능**:
   - `strings.Builder`의 성능은 대체로 선형적입니다.
   - `+` 연산자의 성능은 문자열 크기에 따라 기하급수적으로 악화될 수 있습니다.

5. **메모리 효율성**:
   - `strings.Builder`는 필요한 만큼만 메모리를 사용합니다.
   - `+` 연산자는 과도한 메모리를 사용할 수 있습니다.

6. **최적화된 내부 구현**:
   - `strings.Builder`는 Go 런타임에 의해 최적화되어 있습니다.
   - 예를 들어, 작은 문자열의 경우 스택 할당을 사용할 수 있습니다.

### 구체적인 성능 차이 예시

작은 규모의 연결에서는 차이가 미미할 수 있지만, 큰 규모의 연결에서 차이가 극명해집니다:

```go
func benchmark(n int) {
    withBuilder := func() {
        var b strings.Builder
        for i := 0; i < n; i++ {
            fmt.Fprintf(&b, "%d", i)
        }
        _ = b.String()
    }

    withPlus := func() {
        s := ""
        for i := 0; i < n; i++ {
            s += fmt.Sprintf("%d", i)
        }
    }

    // 벤치마크 코드...
}
```

n이 1,000일 때:
- `strings.Builder`: ~10μs
- `+` 연산자: ~300μs

n이 100,000일 때:
- `strings.Builder`: ~1ms
- `+` 연산자: ~1.5s

이러한 이유로 Go에서 대량의 문자열 연결 작업을 수행할 때는 `strings.Builder`를 사용하는 것이 훨씬 더 효과적입니다. 특히 연결 횟수나 최종 문자열의 길이가 클수록 그 차이가 더욱 두드러집니다.
