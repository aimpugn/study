# package oriented design

- [package oriented design](#package-oriented-design)
    - [Go 패키지 관리 및 설계 원칙](#go-패키지-관리-및-설계-원칙)
    - [Package Oriented Design](#package-oriented-design-1)
    - [패키지의 역할](#패키지의-역할)
        - [분리 및 응집](#분리-및-응집)
        - [프로젝트 레벨의 구성](#프로젝트-레벨의-구성)
        - [API 중심의 설계](#api-중심의-설계)
    - [설계 지침](#설계-지침)
        - [명확성과 목적성](#명확성과-목적성)
        - [사용자 중심 설계](#사용자-중심-설계)
        - [에러 인터페이스](#에러-인터페이스)
        - [단일 종속 지점 회피](#단일-종속-지점-회피)
        - [타입 중복 허용](#타입-중복-허용)
    - [소스 트리 구조 예시](#소스-트리-구조-예시)
        - [github.com/servi-io/api](#githubcomservi-ioapi)
            - [`internal/` 디렉토리의 사용](#internal-디렉토리의-사용)
            - [패키지 간의 상호 작용 방식](#패키지-간의-상호-작용-방식)
            - [`attachments`와 `locations` 패키지의 예](#attachments와-locations-패키지의-예)
        - [패키지 구조 예시2](#패키지-구조-예시2)
            - [베스트 프랙티스와 그 이유](#베스트-프랙티스와-그-이유)
    - [주의 사항](#주의-사항)
    - [기타](#기타)

## Go 패키지 관리 및 설계 원칙

Go에서의 패키징은 코드의 조직화, 의존성 관리, 그리고 모듈화를 통해 대규모 프로젝트의 복잡성을 관리할 수 있는 강력한 수단을 제공한다. 이는 마이크로서비스 아키텍처와 유사한 접근 방식을 채택하여 각 패키지가 독립적으로 기능하도록 한다.

결국, 코드를 잘 조직화된 패키지로 분할하여, 가독성, 확장성, 그리고 유지 보수성을 향상시키는 것이 목표다.

## Package Oriented Design

Go 언어에서 Package Oriented Design(PoD)은 강력하고 유지 보수가 용이한 코드 구조를 만드는 데 도움을 준다.
각 서비스의 내부 구조를 명확히 하고, 관심사를 분리하여 코드의 가독성과 유지 보수성을 향상시킬 수 있다.

마이크로서비스 아키텍처에서 각 서비스는 독립적으로 배포되고 운영될 수 있는 자체 기능 단위로 보인다.
Go에서 마이크로서비스를 개발할 때, 각 마이크로서비스는 별도의 패키지 또는 모듈로 구성될 수 있으며, 이는 서비스의 논리적 경계를 정의하는 데 도움을 준다.

## 패키지의 역할

### 분리 및 응집

다양한 프로그램 조각을 서로 분리하여 큰 팀이 큰 프로젝트에서 효율적으로 작업할 수 있게 한다.

한 팀이 사용자 인터페이스(UI)를 담당하고, 다른 팀이 데이터베이스 관리를 담당하는 큰 프로젝트를 생각해보자.
UI 팀은 `ui` 패키지를, 데이터베이스 팀은 `db` 패키지를 각각 관리한다.
이러한 분리는 각 팀이 자신의 코드 베이스에만 집중할 수 있게 하며, 변경 사항이 다른 팀의 작업에 미치는 영향을 최소화한다.
동시에, 각 패키지는 잘 정의된 API를 통해 서로 통신할 수 있어, 시스템 전체의 응집력을 유지합니다.

### 프로젝트 레벨의 구성

프로젝트 레벨에서 대부분이 마이크로서비스처럼 동작하도록 하며, 이는 소스 코드 레벨에서의 구성에 영향을 미친다.

전자 상거래 시스템을 구축한다고 가정해보자. 이 시스템은 다양한 기능이 필요하다
- 주문 처리
- 재고 관리
- 사용자 인증 등

각 기능을 별도의 마이크로서비스로 구성하여, 예를 들어 `orders`, `inventory`, `auth` 등의 독립적인 패키지로 분리할 수 있다. 이러한 구성은 각 마이크로서비스가 독립적으로 개발, 배포, 확장될 수 있게 해줌으로써, 대규모 프로젝트의 복잡성을 효과적으로 관리할 수 있게 한다.

### API 중심의 설계

개발자는 소스 코드 자체보다는 필요한 컴포넌트와 API 간의 관계에 초점을 맞춰야 한다.

`inventory` 패키지가 재고 수량을 업데이트하는 기능을 제공한다고 가정합시다. 이 패키지는 `UpdateStock` 같은 함수를 API로 제공한다.

```go
package inventory

type InventoryService interface {
    UpdateStock(itemId string, change int) error
}
```

`orders` 패키지는 주문이 완료될 때마다 이 함수를 호출하여 재고 수량을 감소시킨다.
이 경우, `orders` 패키지는 `inventory` 패키지의 내부 구현보다는 `UpdateStock` 함수의 존재와 사용 방법에 초점을 맞춘다.
이렇게 API 중심의 설계를 통해, 패키지 간의 결합도는 낮추고, 각 패키지의 독립성과 재사용성을 높일 수 있다.

이러한 접근 방식은 개발자들이 구현 세부 사항에 얽매이지 않고 시스템의 전체 구조와 각 컴포넌트 간의 관계에 집중할 수 있게 한다.
패키지 간의 명확하고 잘 정의된 인터페이스를 통해, 각 팀은 자신의 작업에 집중하면서도 전체 프로젝트의 목표를 향해 협력할 수 있다.

## 설계 지침

- **타입 중복 허용**: 필요한 경우, 다른 패키지에서 타입을 중복시켜 사용함으로써 각 패키지의 독립성을 유지할 수 있습니다.

### 명확성과 목적성

패키지 이름은 구체적이고 목적이 드러나야 하며, `common`과 같이 모호한 이름은 사용을 피해야 한다.

가령 여러분이 파일 업로드와 관련된 기능을 제공하는 패키지를 설계한다고 가정해보자.
이 패키지의 이름을 `common`이나 `utils`와 같이 모호하게 지으면, 그 용도나 포함된 기능을 명확하게 파악하기 어렵다.
대신, 패키지 이름을 `fileuploader`로 지정하면, 이 패키지가 파일 업로드 기능을 제공한다는 것을 바로 알 수 있다.
이처럼 명확하고 구체적인 패키지 이름은 패키지의 목적과 기능을 쉽게 이해할 수 있게 해준다.

### 사용자 중심 설계

패키지는 사용하기 쉽고, 직관적이며, 간단해야 하며, 사용자를 존중하는 설계가 필요하다.

`dateutils` 패키지가 다양한 날짜 및 시간 관련 유틸리티 함수를 제공한다고 가정해보자.
사용자가 가장 자주 필요로 하는 기능 중 하나가 현재 날짜를 "YYYY-MM-DD" 형식의 문자열로 변환하는 것일 수 있다.
이 경우,직관적이고 사용하기 쉬운 함수를 제공하여 사용자가 쉽게 원하는 기능을 찾고 사용할 수 있게 해야 한다.

```go
package dateutils

type DateUtils interface {
    // 현재 날짜를 "YYYY-MM-DD" 형식의 문자열로 변환
    FormatCurrentDate() string
}
```

### 에러 인터페이스

인터페이스 레벨에서 에러를 처리하여, 에러 핸들링을 간소화하고 일관성을 유지해야 한다.

네트워크 통신을 담당하는 `network` 패키지가 있다고 가정해보자.
이 패키지 내에서 발생할 수 있는 다양한 에러(예: 타임아웃, 연결 실패 등)를 처리하기 위해, `network` 패키지는 `NetworkError`라는 인터페이스를 정의하고, 이를 통해 에러를 일관적으로 처리할 수 있게 한다.

```go
package network

type NetworkError interface {}
```

사용자는 이 인터페이스를 통해 에러 유형을 쉽게 파악하고 적절한 대응을 할 수 있다.

### 단일 종속 지점 회피

패키지는 단일 종속 지점이 되어서는 안 되며, 공통 타입(common types)의 사용을 피해야 한다.

여러 패키지에서 공통으로 사용되는 `User` 구조체를 가지고 있다고 가정해보자.
이 구조체를 단일 `common` 패키지에 넣고 모든 패키지에서 이를 참조하게 만들면, `common` 패키지에 대한 종속성이 생기고, 나중에 `User` 구조체에 변경이 필요할 때 여러 패키지에 영향을 미치게 된다.
대신, 각 패키지가 필요로 하는 필드만을 포함하는 자체적인 `User` 구조체를 정의하여 사용함으로써, 패키지 간의 종속성을 줄이고 변경에 더 유연하게 대응할 수 있다.

### 타입 중복 허용

`ecommerce` 시스템 내에서 `orders` 패키지와 `shipping` 패키지가 있고, 두 패키지 모두 주문 정보를 다루는 `Order` 타입을 사용한다고 가정해보자.
`Order` 타입을 중앙 `common` 패키지에 정의하는 대신, 각 패키지에서 필요로 하는 필드만을 포함하여 별도의 `Order` 타입을 정의함으로써, 두 패키지는 서로 독립적으로 유지되고, 필요에 따라 각자의 `Order` 타입을 자유롭게 수정하거나 확장할 수 있다.
이는 각 패키지의 변경 사항이 다른 패키지에 영향을 미치는 것을 방지하고, 각 패키지의 유지보수성을 향상시킨다.

## 소스 트리 구조 예시

### github.com/servi-io/api

```plaintext
github.com/servi-io/api
├── cmd/
│   ├── servi/
│   │   ├── cmdupdate/
│   │   ├── cmdquery/
│   │   └── servi.go
│   └── servid/
│       ├── handlers/
│       ├── routes/
│       ├── tests/
│       └── servid.go
└── internal/ (특별한 컴파일러 보호)
    ├── attachments/
    ├── locations/
    ├── orders/
    │   ├── customers/
    │   ├── items/
    │   ├── tags/
    │   └── orders.go
    ├── registrations/
    └── platform/
        ├── crypto/
        ├── mongo/
        └── json/
```

- `internal/` 디렉토리는 다른 패키지가 import하지 못하도록 특별히 보호된다.
- 같은 레벨의 패키지 간에는 서로 import를 허용하지 않는다. 예를 들어, `handlers`와 `routes`는 서로 import하지 않아야 합니다.
- `attachments`가 `locations`을 필요로 하는 경우, 이는 설계의 큰 문제를 나타낸다. 올바른 접근 방법은 `locations`를 별도의 패키지로 분리하거나, 필요한 경우 `attachments` 내에 위치시키는 것이다.

#### `internal/` 디렉토리의 사용

Go에서 `internal` 디렉토리는 특별한 의미를 갖는다.
이는 해당 디렉토리 안에 위치한 코드가 해당 모듈(또는 부모 디렉토리) 내부에서만 사용될 수 있음을 의미한다.
따라서 외부에서 이 코드를 임포트하려고 하면 컴파일 에러가 발생한다.
이는 라이브러리나 애플리케이션의 내부 구현을 외부로 노출하지 않기 위해 사용된다.

`internal` 디렉토리의 사용은 내부 API를 실수로 외부에서 사용하는 것을 방지한다.
이를 통해 개발자는 공개 API와 내부 구현을 명확하게 분리할 수 있으며, 내부 API의 변경으로 인해 외부 사용자에게 영향을 주는 것을 방지할 수 있다.

#### 패키지 간의 상호 작용 방식

예를 들어, `handlers`와 `routes` 패키지가 서로를 임포트하지 않아야 한다는 규칙은 순환 의존성 문제를 방지한다.
순환 의존성은 패키지 A가 패키지 B를 임포트하고, 동시에 패키지 B도 다시 패키지 A를 임포트하는 상황을 의미한다.
이는 프로젝트의 복잡성을 증가시키고, 컴파일 타임을 늘리며, 유지보수를 어렵게 만든다.

각 패키지가 독립적으로 유지되도록 하여, 코드의 모듈성과 재사용성을 증가시킨다.
패키지 간의 명확한 경계를 설정함으로써, 각 패키지의 책임을 명확히 할 수 있고, 시스템의 다른 부분에 미치는 영향 없이 내부 구현을 변경할 수 있다.

#### `attachments`와 `locations` 패키지의 예

`attachments`가 `locations`을 필요로 하는 경우, 이 두 패키지 간의 강한 결합이 발생할 수 있다.
강한 결합은 한 패키지의 변경이 다른 패키지에도 영향을 미치게 하여, 유지보수성을 저하시키고 변경 사항을 적용하기 어렵게 만든다.

`locations` 기능이 `attachments` 내부에 필요한 경우, 이를 별도의 패키지로 분리하거나 `attachments` 내에 통합하는 결정은 시스템의 결합도를 관리하는 데 도움이 된다. `locations`를 별도의 패키지로 분리하면 재사용성이 증가하지만, 동시에 두 패키지 간의 인터페이스를 신중하게 설계해야 합니다. 반면, `attachments` 내에 `locations` 기능을 통합하면, `attachments`의 내부 구현이 좀 더 복잡해질 수 있지만, 이 두 기능 간의 의존성을 내부적으로 관리할 수 있게 됩니다.

이러한 설계 결정 각각은 특정 상황에서의 이점과 함께 고려해야 할 단점이 있습니다. 결국 중요한 것은 프로젝트의 요구 사항, 팀의 작업 방식, 그리고 유지보수성과 확장성에 대한 장기적인 계획을 고려하여 최적의 결정을 내리는 것입니다.

### 패키지 구조 예시2

각 서비스별로 `repositories`, `types` (또는 `models`), `handlers` (또는 `controllers`) 같은 서브 패키지를 포함할 수 있습니다. 이렇게 함으로써, 각 서비스의 내부 구조를 명확히 하고, 관심사를 분리하여 코드의 가독성과 유지 보수성을 향상시킬 수 있습니다.

다음은 당신의 예시를 확장하여 각 마이크로서비스 내부를 구성할 수 있는 방법에 대한 추천 구조입니다:

```bash
product/
├── cmd/
│   └── main.go            # product 서비스의 실행 가능 파일
├── pkg/
│   ├── repositories/
│   │   └── mysql.go       # MySQL을 사용한 product 저장소 구현
│   ├── types/
│   │   └── product.go     # product 도메인 타입 정의
│   └── handlers/
│       └── product.go     # HTTP 요청 핸들러
admin/
├── cmd/
│   └── main.go            # admin 서비스의 실행 가능 파일
├── pkg/
│   ├── repositories/
│   │   └── mysql.go       # MySQL을 사용한 admin 저장소 구현
│   ├── types/
│   │   ├── users.go       # user 도메인 타입 정의
│   │   └── admin.go       # admin 도메인 타입 정의
│   └── handlers/
│       └── admin.go       # HTTP 요청 핸들러
order/
├── cmd/
│   └── main.go            # order 서비스의 실행 가능 파일
├── pkg/
│   ├── repositories/
│   │   └── mysql.go       # MySQL을 사용한 order 저장소 구현
│   ├── types/
│   │   └── order.go       # order 도메인 타입 정의
│   └── handlers/
│       └── order.go       # HTTP 요청 핸들러
```

#### 베스트 프랙티스와 그 이유

1. **도메인 중심 디자인**: 각 마이크로서비스는 특정 도메인의 문제를 해결하도록 설계됩니다. 도메인 주도 설계(DDD) 원칙을 적용하여, 비즈니스 로직을 중심으로 코드를 조직합니다. 이 접근 방식은 비즈니스 로직과 인프라스트럭처 코드 간의 관심사 분리를 촉진합니다.

2. **명확한 인터페이스 정의**: `repositories`나 `services` 같은 패키지 내에서 인터페이스를 사용하여 구성 요소 간의 의존성을 관리합니다. 이를 통해 구현 세부 사항을 추상화하고, 테스트 용이성을 높이며, 유연성을 향상시킬 수 있습니다.

3. **레이어드 아키텍처**: 데이터 액세스 레이어(`repositories`), 비즈니스 로직 레이어(`services`), 프레젠테이션 레이어(`handlers` or `controllers`)로 코드를 분리합니다. 이 계층적 구조는 코드의 분리와 재사용을 촉진합니다.

4. **단일 책임 원칙(SRP)**: 각 패키지, 타입, 함수는 하나의 명확한 책임만을 가져야 합니다. 이 원칙은 코드의 이해, 테스트, 유지 보수를 용이하게 합니다.

5. **테스트 가능한 코드**: 각 컴포넌트는 독립적으로 테스트 가능해야 합니다. 인터페이스와 의존성 주입을 활용하여, 단위 테스트와 통합 테스트를 용이하게 합니다.

이러한 베스트 프랙티스는 마이크로서비스의 독립성, 확장성, 유지 보수성을 향상시키는 데 중점을 둡니다. 각 서비스가 독립적으로 개발, 배포, 확장될 수 있도록 하여, 큰 규모의 시스템에서도 유연성과 효율성을 보장합니다.

## 주의 사항

- 패턴과 프레임워크에 대한 의존성을 줄이고, 설계에 집중해야 한다.
- 변경 사항이 발생했을 때, 그 변경 사항이 다른 부분으로 파급되지 않도록 설계해야 한다.
- 타입 단언(type assertions)을 자주 사용하는 것은 설계상의 문제를 나타내며, 인터페이스와 디커플링을 통해 해결해야 한다.

이 지침은 Go 프로젝트에서 효율적인 패키지 관리와 설계를 위한 기본적인 틀을 제공합니다. 패키지 설계는 사용성, 이식성, 그리고 유지보수성을 고려하여 이루어져야 합니다.

## 기타

- [Reducing Go Dependencies](https://dev.to/danielgtaylor/reducing-go-dependencies-dec)
