# Philosophy

- [Philosophy](#philosophy)
    - [Go 언어의 철학과 목표](#go-언어의-철학과-목표)
        - [1. 간결성과 명료성 (Simplicity and Clarity)](#1-간결성과-명료성-simplicity-and-clarity)
        - [2. 효율성 (Efficiency)](#2-효율성-efficiency)
        - [3. 동시성 (Concurrency)](#3-동시성-concurrency)
        - [4. 신뢰성 (Reliability)](#4-신뢰성-reliability)
        - [5. 확장성 (Scalability)](#5-확장성-scalability)
    - [경량 스레드 고루틴(Goroutine)](#경량-스레드-고루틴goroutine)
        - [메모리 사용량](#메모리-사용량)
        - [관리 및 스케줄링](#관리-및-스케줄링)
        - [생성 및 전환 비용](#생성-및-전환-비용)
        - [동시성 모델](#동시성-모델)

## Go 언어의 철학과 목표

- 개발자가 신속하고 효율적으로 안정적이고 확장 가능한 소프트웨어를 개발할 수 있도록 돕는 것
- 각각의 철학과 목표는 Go의 다양한 기능과 문법적 요소들에 반영되어 있으며, 이를 통해 개발자는 실제 문제를 효과적으로 해결할 수 있다

### 1. 간결성과 명료성 (Simplicity and Clarity)

- 코드의 간결성: Go는 불필요한 요소를 최소화하며, 코드를 단순하고 이해하기 쉽게 만듭니다. 이는 빠른 학습 곡선과 쉬운 유지보수를 가능하게 합니다.
- 명료한 문법: Go의 문법은 명료하고 직관적이며, 복잡한 표현을 피합니다. 이는 개발자들이 코드의 의도를 쉽게 파악하고 오류를 줄일 수 있도록 돕습니다.

### 2. 효율성 (Efficiency)

- 빠른 컴파일 시간: Go는 빠른 컴파일 시간을 목표로 합니다. 이는 개발자의 생산성을 높이고, 대규모 프로젝트에서도 빠른 개발 주기를 유지할 수 있게 합니다.
- 성능: Go는 C와 비슷한 수준의 높은 성능을 제공합니다. 이는 정적 타입, 간결한 메모리 관리, 효율적인 컴파일러 최적화 덕분입니다.

### 3. 동시성 (Concurrency)

- 고루틴(Goroutines): Go는 경량 스레드인 고루틴을 사용하여 동시성을 쉽게 구현할 수 있도록 합니다. 고루틴은 기존 스레드보다 훨씬 적은 메모리를 사용하고, 쉽게 생성 및 관리할 수 있습니다.
- 채널(Channels): Go의 채널은 고루틴 간의 데이터 통신과 동기화를 용이하게 합니다. 이는 동시성 프로그래밍을 더 안전하고 관리하기 쉽게 만듭니다.

### 4. 신뢰성 (Reliability)

- 정적 타입 시스템: Go는 강력한 정적 타입 시스템을 가지고 있으며, 이는 컴파일 시간에 오류를 발견하고, 안정적인 프로그램을 작성하는 데 도움이 됩니다.
- 내장된 도구: Go는 포맷팅, 문서화, 테스팅, 성능 분석을 위한 강력한 도구들을 내장하고 있습니다. 이는 코드의 일관성을 유지하고, 품질을 개선하는 데 중요합니다.

### 5. 확장성 (Scalability)

- 모듈화 및 패키지 관리: Go는 모듈화된 구조와 효율적인 패키지 관리 시스템을 제공합니다. 이는 대규모 프로젝트에서 코드를 관리하고 재사용하기 쉽게 만듭니다.
- 다양한 환경에서의 운용: Go는 다양한 운영 체제와 아키텍처를 지원하며, 클라우드 및 서버리스 환경에도 적합합니다.

## 경량 스레드 고루틴(Goroutine)

- Go 언어의 고루틴(Goroutines)은 일반적으로 "경량 스레드"라고 불리며, Java나 Kotlin에서 사용되는 전통적인 스레드와 몇 가지 중요한 차이점이 있다
- 고루틴의 특성들은 Go 언어가 동시성을 더 효율적이고 간단하게 다룰 수 있도록 돕는다.
- 특히, 고루틴은 메모리 사용량이 적고, 빠르며, 동시에 많은 수의 동작을 쉽게 관리할 수 있게 만드는 특징을 가지고 있다

### 메모리 사용량

- 고루틴
    - 고루틴은 매우 작은 메모리 스택(일반적으로 몇 킬로바이트)으로 시작하며, 필요에 따라 동적으로 확장된다.
    - 이로 인해 수천, 수만 개의 고루틴을 동시에 운용하는 것이 가능하다
- Java/Kotlin 스레드
    - 전통적인 스레드는 훨씬 더 큰 메모리 스택을 사용한다(예: 몇 백 킬로바이트에서 몇 메가바이트).
    - 이는 동일한 양의 메모리에서 더 적은 수의 스레드만 생성할 수 있음을 의미한다

### 관리 및 스케줄링

- 고루틴
    - 고루틴은 **Go 런타임**에 의해 관리되며, **사용자 공간(user space)에서 스케줄링**된다.
    - 이는 운영 체제 커널이 아닌 Go 런타임이 스케줄링과 관리를 담당합니다.
- Java/Kotlin 스레드
    - 전통적인 스레드는 운영 체제 커널에 의해 관리되며, 커널 스레드에 해당한다
    - 이로 인해 컨텍스트 전환(context switch) 비용이 더 높고, 스케줄링이 운영 체제에 의존적이다

### 생성 및 전환 비용

- 고루틴
    - 고루틴이 사용자 공간에서 관리되기 때문에, 고루틴의 생성, 종료, 컨텍스트 전환은 매우 가볍다
- Java/Kotlin 스레드
    - 스레드의 생성, 종료 및 컨텍스트 전환은 비교적 더 많은 자원을 소모한다
    - 특히 운영 체제 커널이 관여하는 컨텍스트 전환이 더 비용이 많이 든다

### 동시성 모델

- 고루틴
    - Go는 `channel`을 통한 통신을 권장한다("통신으로 메모리를 공유하라, 메모리 공유로 통신하지 마라").
    - 이는 데드락과 경쟁 상태를 관리하는 데 도움이 된다
- Java/Kotlin 스레드
    - 전통적인 스레드 모델에서는 객체와 자원에 대한 공유와 잠금(locking)을 통해 동시성을 관리한다.
    - 이는 복잡한 동기화와 데드락 관리가 필요할 수 있다
