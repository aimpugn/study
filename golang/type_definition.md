# [Type Definition](https://go.dev/ref/spec#Type_definitions)

- [Type Definition](#type-definition)
    - [Type Definition?](#type-definition-1)
        - [사용 예](#사용-예)
        - [장점](#장점)
        - [vs 타입 별칭(Type Alias)](#vs-타입-별칭type-alias)
            - [사용 예](#사용-예-1)
            - [장점](#장점-1)
    - [instance?](#instance)
        - [구조체, 인스턴스, 객체](#구조체-인스턴스-객체)
            - [구조체 (Struct)](#구조체-struct)
            - [인스턴스 (Instance)](#인스턴스-instance)
            - [객체 (Object)](#객체-object)
        - [Go의 타입 시스템](#go의-타입-시스템)
        - [인스턴스의 개념](#인스턴스의-개념)
        - [`PgProvider` 예시](#pgprovider-예시)
    - [별칭 타입](#별칭-타입)

## Type Definition?

`type MyType string`은 새로운 타입 `MyType`을 정의하며, 기본 타입인 `string`에서 파생된다.
이렇게 정의된 `MyType`은 `string`과 내부적으로 동일한 구조를 가지지만, Go의 타입 시스템에서는 `string`과는 별개의 타입으로 취급된다. 따라서, `MyType`은 `string`과 호환되지 않는다.

### 사용 예

```go
type MyType string

func PrintMyType(mt MyType) {
    fmt.Println(mt)
}

var mt MyType = "hello"
PrintMyType(mt) // 정상 작동
```

### 장점

- 타입 안전성(Type Safety): `MyType`은 `string`과 구분되므로, `MyType`을 요구하는 함수에 `string`을 잘못 전달하는 실수를 컴파일 타임에 방지할 수 있다.
- 의미 부여: `MyType`은 특정 도메인이나 컨텍스트에 맞는 의미를 부여하여 코드의 가독성과 유지보수성을 향상시킨다.

### vs 타입 별칭(Type Alias)

타입 별칭은 기존 타입에 대한 새로운 이름을 제공하며, 기본 타입과 완전히 동일한 타입으로 단지 다른 이름을 가질 뿐이다.
`type MyType = string`은 `string`에 대한 새로운 이름인 `MyType`을 생성하는 타입 별칭이다.
타입 별칭은 기본 타입과 완전히 동일하게 취급되며, 호환성을 유지한다.
타입 별칭은 Go 1.9 버전에서 도입되었으며, 기존 코드와의 호환성을 유지하면서 점진적인 코드 변경을 용이하게 하기 위한 목적으로 추가되었다.

#### 사용 예

```go
type MyType = string

func PrintString(s string) {
    fmt.Println(s)
}

var mt MyType = "hello"
PrintString(mt) // 정상 작동
```

#### 장점

- 코드 리팩토링: 기존 코드베이스에서 타입을 새로운 이름으로 점진적으로 변경하고자 할 때 유용합니다. 이는 대규모 리팩토링이나 API 마이그레이션 시에 특히 도움이 됩니다.
- 호환성 유지: 기존 타입과의 호환성을 유지하면서 새로운 이름을 사용할 수 있다.
- 간결한 표현: 긴 타입 명칭을 간결하게 표현할 수 있어 코드의 가독성을 높일 수 있다.

## instance?

Go 언어에서 "인스턴스(instance)"라는 용어는 다른 객체 지향 프로그래밍 언어에서의 사용과 약간 다를 수 있다.
Go는 전통적인 클래스 기반의 객체 지향 언어가 아니기 때문에, 클래스의 인스턴스라는 개념 대신, 구체적인 데이터 타입의 값을 지칭하는 데 사용된다.
Go에서 모든 값은 어떤 타입의 인스턴스라고 볼 수 있으며, 이는 기본 타입(예: `int`, `string` 등)의 값부터 사용자 정의 타입(예: 구조체, 인터페이스)까지 포함합니다.

실제로 구조체의 인스턴스를 "구조체 인스턴스"(struct instance)라고 부를 수도 있습니다. 하지만 "구조체 인스턴스"(struct instance)와 "객체"(object) 사이의 벤 다이어그램에서 서로 교차하는 부분과 그렇지 않는 부분이 있기 때문에 "구조체 인스턴스"(struct instance)는 "객체"가 아닙니다.

Go에서는 '객체'에 대해, 구조체가 아닌 모든 사용자 정의 타입에도 메서드를 정의하는 것이 허용되고 권장되는 관례입니다.

```go
type Something int

func (s Something) PrintMe() {
    fmt.Println(s)
}
```

이는 'Something'이 인터페이스에 참여할 수도 있고, 또는 단순히 유용한 메서드들을 가질 수도 있다는 것을 의미합니다.

반면에, 구조체는 반드시 메서드를 가질 필요가 없다. 그러한 구조체의 인스턴스는 제 생각에는 "메서드"를 가져야만 하는 "객체"가 아니다. 그것들은 단지 "구조체"일 뿐이다.

그래서 저는 Go에서 어떤 종류의 메서드를 가진 것들에 대해 일반적으로 이야기할 때, 종종 "객체"라는 단어를 사용한다.
오직 공식 용어만을 사용하여 이 개념에 가장 가까운 것은 "비어 있지 않은 메서드 세트를 가진 값"이라고 할 수도 있다.

즉, Go에서 "메서드를 가진 값"을 가리키기 위해 "객체"라는 용어를 사용할 수 있다. 왜냐하면 "구조체 인스턴스"는 정확하지 않으며, 구조체 외의 것들도 메서드를 가질 수 있고, 구조체는 반드시 메서드를 가질 필요가 없기 때문이다(이는 그것들을 단지 "구조체"로 만들며, 분명히 "객체"가 아니다).

### 구조체, 인스턴스, 객체

- **구조체**: 데이터의 틀 또는 모델을 정의합니다. 클래스에 가까운 개념이지만, 메서드를 내부에 포함하지 않고 별도로 정의합니다.
- **인스턴스**: 구조체(또는 다른 타입)의 정의를 바탕으로 생성된 구체적인 데이터입니다. 메모리에 할당된 상태를 의미합니다.
- **객체**: Go에서는 넓은 의미로 사용되며, 데이터와 그에 대한 연산을 포함한 모든 것을 지칭할 수 있습니다. 이는 기본 데이터 타입의 값부터 복잡한 구조체 인스턴스까지 포함합니다.

#### 구조체 (Struct)

구조체는 Go에서 복합 데이터 타입을 정의하는 기본적인 방법입니다. 구조체는 여러 필드(데이터 멤버)를 묶어 하나의 더 큰 단위로 구성할 수 있게 해주며, 각 필드는 서로 다른 타입일 수 있습니다. 구조체를 사용하여 객체지향 프로그래밍의 클래스와 비슷한 패턴을 구현할 수 있지만, Go는 전통적인 클래스 기반 객체지향 언어는 아닙니다.

```go
type Person struct {
    Name string
    Age  int
}
```

#### 인스턴스 (Instance)

인스턴스는 특정 타입의 구체적인 실현을 의미합니다. 구조체 타입을 정의한 후, 해당 타입의 변수를 선언하고 초기화하여 구조체의 인스턴스를 생성할 수 있습니다. 이 인스턴스는 해당 구조체 타입의 속성과 메서드를 가지고 있으며, 메모리 상에 할당됩니다.

```go
var john Person = Person{Name: "John", Age: 30}
```

여기서 `john`은 `Person` 구조체의 인스턴스입니다.

#### 객체 (Object)

Go 언어의 문맥에서 "객체"라는 용어는 넓은 의미로 사용될 수 있으며, 일반적으로 데이터와 그 데이터에 적용 가능한 연산(함수나 메서드)의 결합을 가리킵니다. Go에서는 모든 값(기본 타입의 값, 구조체의 인스턴스, 함수 등)과 타입(기본 타입, 구조체 타입, 인터페이스 타입 등)을 객체로 간주할 수 있습니다. 그러나 Go는 전통적인 의미의 객체지향 프로그래밍 언어가 아니기 때문에, 클래스와 상속 같은 개념 대신 구조체와 인터페이스를 사용하여 객체지향 프로그래밍의 일부 패턴을 구현합니다.

### Go의 타입 시스템

Go의 타입 시스템은 강력하고, 정적 타입 언어입니다. 이는 프로그램이 실행되기 전에 모든 변수와 표현식의 타입이 결정되어야 함을 의미합니다. Go에서 타입은 데이터의 형태와 그 데이터에 수행할 수 있는 연산을 정의합니다.

- **기본 타입**: Go에는 여러 기본 타입이 있으며, 이들은 언어에 내장된 타입입니다. 예를 들어, `int`, `float64`, `bool`, `string` 등이 있습니다.
- **복합 타입**: 사용자는 기본 타입을 조합하여 복합 타입을 정의할 수 있습니다. 가장 흔한 예는 구조체(`struct`)이지만, 배열, 슬라이스, 맵, 채널 등도 포함됩니다.
- **인터페이스**: 인터페이스 타입은 메서드 시그니처의 집합으로 정의됩니다. 어떤 타입이 특정 인터페이스를 만족시키려면, 그 인터페이스에 정의된 모든 메서드를 구현해야 합니다.

### 인스턴스의 개념

Go에서 타입의 "인스턴스"는 해당 타입의 구체적인 값이나 예시를 의미합니다. 예를 들어, `string` 타입의 변수가 "hello"라는 값을 가지고 있다면, "hello"는 `string` 타입의 인스턴스입니다. 사용자 정의 타입의 경우, 그 타입의 인스턴스는 해당 타입의 구조체나 인터페이스 등을 사용해 생성된 값입니다.

```go
type MyStruct struct {
    Field int
}

var myInstance MyStruct = MyStruct{Field: 10}
```

위 예제에서 `myInstance`는 `MyStruct` 타입의 인스턴스입니다. 여기서 `MyStruct{Field: 10}`은 `MyStruct` 타입의 새로운 인스턴스를 생성합니다.

### `PgProvider` 예시

`PgProvider`가 `string`을 기반으로 하는 사용자 정의 타입인 경우, `PgProvider` 타입의 모든 값은 `string`의 인스턴스이면서 동시에 `PgProvider` 타입의 인스턴스라고 할 수 있습니다. 따라서, 이 컨텍스트에서 `PgProvider` 인스턴스라고 하는 것은 기술적으로 정확하며, `PgProvider` 타입의 구체적인 값을 나타냅니다.

Go에서는 이러한 방식으로 타입을 확장하고 타입 안전성을 높이면서도, 기본 타입의 간결함과 효율성을 유지할 수 있습니다.

## 별칭 타입
