# function

## 시그니처

Go 언어에서는 Java와 유사하게 메서드나 함수의 정의를 설명할 때 "시그니처(signature)"라는 용어를 사용한다.
메서드 시그니처나 함수 시그니처는 그 함수나 메서드의 이름, 매개변수 리스트, 반환 타입 등을 포함하여 그 구조를 정의한다.
메서드든 일반 함수든 Go에서 함수로 간주하기 때문에, Go 언어의 컨텍스트에서는 보통 "함수 시그니처"라고 하는 것이 일반적이다.

### 메서드 시그니처

Go에서 메서드는 특정 타입(주로 구조체)에 연결된 함수로, 해당 타입의 인스턴스(리시버)를 통해 호출된다.
메서드의 시그니처에는 리시버 타입도 포함된다.

```go
func  (r *Receiver) Do() error {}
```

- 리시버 타입: `*Receiver` (리시버 변수명 `r` 포함)
- 메서드 이름: `Do`
- 매개변수 리스트: 없음 (괄호 내부가 비어 있음)
- 반환 타입: `error`

따라서, 이 메서드의 전체 시그니처는 리시버 타입을 포함하여 `func (r *Receiver) Do() error`로 표현할 수 있습니다.

### 함수 시그니처

일반 함수의 경우, 리시버가 없으므로 함수 이름, 매개변수 리스트, 반환 타입만으로 시그니처가 정의된다.

```go
func Sum(a int, b int) int {}
```

- 함수 이름: `Sum`
- 매개변수 리스트: `a int`, `b int`
- 반환 타입: `int`

### 용어 사용

Go 커뮤니티 내에서는 메서드나 함수에 대해 특별히 구분하지 않고 "함수 시그니처"라는 용어를 널리 사용한다.
하지만 특정 타입의 인스턴스(리시버)에 종속되어 있음을 강조하고 싶을 때 "메서드 시그니처"라고 명시적으로 언급할 때도 있다.

## 함수와 메서드

Go 언어에서 *리시버가 있는 메서드*와 *리시버가 없는 함수*는 구문적으로 구분되며, 이들 사이에는 명확한 차이가 있다.
이 차이는 주로 그 함수나 메서드가 특정 타입의 인스턴스와 관련되어 있는지 여부에 기반한다.
하지만 Go의 타입 시스템과 인터페이스를 통해 다형성을 제공하는 방식 때문에, 함수와 메서드 사이의 구분이 다른 언어보다 덜 엄격하게 느껴질 수 있다.

### 리시버가 있는 메서드

메서드는 특정 타입의 인스턴스(리시버)에 연결된 함수다.
이는 객체 지향 프로그래밍의 메서드와 유사한 개념으로, 특정 타입의 인스턴스에 대해 작동한다.
메서드는 해당 타입의 인스턴스를 사용해야만 호출할 수 있으며, 인스턴스의 상태를 조회하거나 변경하는 데 사용될 수 있다.

```go
type MyType struct {
    // 필드 정의
}

// MyType의 인스턴스에 대한 메서드
func (m MyType) MyMethod() {
    // 메서드 구현
}
```

### 리시버가 없는 함수

리시버가 없는 함수는 특정 타입에 속하지 않고, 패키지 레벨에서 정의된다.
이러한 함수는 특정 타입의 인스턴스 없이 호출될 수 있으며, 전역 함수나 유틸리티 함수로 사용될 수 있다.

```go
func MyFunction() {
    // 함수 구현
}
```

### 엄격한 구분

Go 언어는 함수와 메서드를 구문적으로 구분한다.
- 메서드 정의에는 리시버가 명시되어 있어야 하며, 이 리시버는 메서드가 작동하는 타입의 인스턴스를 지정한다.
- 반면, 일반 함수는 리시버 없이 정의된다.

그러나 Go에서는 인터페이스를 통해 다형성을 실현하고, 함수를 값으로 전달하거나, 고차 함수를 사용하는 등의 기능을 통해 함수와 메서드 사이의 경계를 유연하게 다룬다. 예를 들어, 인터페이스 메서드로 일반 함수를 사용할 수 있게 하는 등의 기술을 사용할 수 있다.
