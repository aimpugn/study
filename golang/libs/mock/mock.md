# mock

- [mock](#mock)
    - [`mock` 패키지 사용](#mock-패키지-사용)
    - [`mock` 패키지 사용의 장점](#mock-패키지-사용의-장점)
    - [`mock` 패키지 사용의 목적](#mock-패키지-사용의-목적)
    - [mockery 통해 생성된 코드](#mockery-통해-생성된-코드)
        - [mockery의 mock 패키지 사용 방식](#mockery의-mock-패키지-사용-방식)

## `mock` 패키지 사용

mock 패키지(예: Go의 `gomock`, Python의 `unittest.mock`)는 테스트 더블을 쉽게 생성하고 관리할 수 있게 해주는 도구입니다.

## `mock` 패키지 사용의 장점

1. **생산성 향상**

    반복적인 모의 객체 생성 작업을 자동화하여 개발 시간을 단축합니다.
    복잡한 인터페이스에 대한 모의 객체를 쉽게 생성할 수 있습니다.

2. **일관성 유지**

    표준화된 방식으로 모의 객체를 생성하여 팀 전체의 일관성을 유지할 수 있습니다.
    코드 리뷰 시 모의 객체 생성 로직에 대한 검토 부담을 줄일 수 있습니다.

3. **유지보수성 향상**

    인터페이스 변경 시 모의 객체도 자동으로 업데이트되어 유지보수가 용이합니다.
    테스트 코드의 가독성이 향상되어 향후 수정이 더 쉬워집니다.

4. **고급 기능 제공**

    복잡한 동작(예: 메서드 호출 횟수 검증, 호출 순서 확인 등)을 쉽게 구현할 수 있습니다.
    다양한 시나리오에 대한 테스트를 더 쉽게 작성할 수 있습니다.

5. **오류 감소**

    직접 구현 시 발생할 수 있는 실수를 줄일 수 있습니다.
    타입 안전성을 보장하여 컴파일 시점에 오류를 잡을 수 있습니다.

## `mock` 패키지 사용의 목적

1. **단위 테스트 격리**

    외부 의존성을 효과적으로 격리하여 순수한 단위 테스트를 가능하게 합니다.
    테스트 대상 코드의 동작만을 검증할 수 있습니다.

2. **테스트 속도 향상**

    실제 객체 대신 가벼운 모의 객체를 사용하여 테스트 실행 속도를 높입니다.
    CI/CD 파이프라인에서의 빠른 피드백을 가능하게 합니다.

3. **엣지 케이스 테스트**

    실제 환경에서 재현하기 어려운 상황을 쉽게 시뮬레이션할 수 있습니다.
    오류 조건, 네트워크 지연 등 다양한 시나리오를 테스트할 수 있습니다.

4. **인터페이스 설계 검증**

    모의 객체 생성을 통해 인터페이스 설계의 적절성을 검증할 수 있습니다.
    클라이언트 코드 관점에서 인터페이스의 사용성을 평가할 수 있습니다.

5. **행위 중심 테스트 지원**

    객체 간 상호작용을 쉽게 검증할 수 있어 행위 주도 개발(BDD)을 지원합니다.
    메서드 호출 순서, 인자 등을 정확히 검증할 수 있습니다.

## mockery 통해 생성된 코드

```go
// GetUserSettings provides a mock function with given fields: ctx, user
func (_m *MockUserRepository) GetUserSettings(ctx context.Context, user *domain.User) (*domain.UserSettings, error) {
    // `Called` 메서드는 모의 객체의 메서드 호출을 기록합니다. 
    // 이는 나중에 테스트에서 이 메서드가 호출되었는지, 어떤 인자로 호출되었는지 검증할 수 있게 합니다. 
    // 또한, 테스트 설정 시 정의한 반환값을 제공합니다.
    // 모의 객체의 Called 메서드를 호출하여 이 함수 호출을 기록하고 반환값을 얻음
    ret := _m.Called(ctx, user)

    // Called 메서드가 반환값을 제공하지 않으면 패닉 발생
    if len(ret) == 0 {
        panic("no return value specified for GetUserSettings")
    }

    // 반환값을 저장할 변수 선언
    var r0 *domain.UserSettings
    var r1 error

    // 가장 구체적이고 유연한 시나리오부터 처리합니다 (전체 함수 시그니처 매칭).
    // 첫 번째 반환값이 함수인 경우 처리:
    // 
    // 타입 단언(type assertion)을 사용하여 반환값이 특정 함수 타입인지 확인합니다. 이는 모의 객체의 동적 동작을 지원하기 위한 것입니다.
    // 사용자가 함수를 반환값으로 설정할 수 있게 하여, 모의 객체가 더 복잡한 동작을 시뮬레이션할 수 있게 합니다. 
    // 이를 통해 컨텍스트나 입력에 따라 다른 결과를 반환하는 등의 동적인 동작을 구현할 수 있습니다.
    if rf, ok := ret.Get(0).(func(context.Context, *domain.User) (*domain.UserSettings, error)); ok {
        return rf(ctx, user)
    }

    // 그 다음으로 구체적인 시나리오를 처리합니다 (부분 함수 시그니처 매칭).
    // 첫 번째 반환값이 함수이지만 리턴해야 할 값을 하나만 반환하는 경우 처리
    if rf, ok := ret.Get(0).(func(context.Context, *domain.User) *domain.UserSettings); ok {
        r0 = rf(ctx, user)
    } else {
        // 마지막으로 가장 단순한 시나리오를 처리합니다 (직접 값 설정).
        // 함수가 아닌 경우, 직접 값 할당
        if ret.Get(0) != nil {
            r0 = ret.Get(0).(*domain.UserSettings)
        }
    }

    // 단순한 오류 반환과 복잡한 오류 생성 로직 모두를 지원합니다.
    // 두 번째 반환값(오류)이 함수인 경우 처리
    if rf, ok := ret.Get(1).(func(context.Context, *domain.User) error); ok {
        r1 = rf(ctx, user)
    } else {
        // 함수가 아닌 경우, 직접 오류 값 할당
        r1 = ret.Error(1)
    }

    // 최종 결과 반환
    return r0, r1
}
```

### mockery의 mock 패키지 사용 방식

mockery는 `testify/mock` 패키지를 기반으로 하며, 이를 확장하여 사용합니다.
mock 패키지의 기본 기능을 활용하면서도, 코드 생성을 통해 더 타입 안전하고 사용하기 쉬운 인터페이스를 제공합니다.

`EXPECT`, `${TYPE}_Expecter`, `${TYPE}_${METHOD_NAME}_Call`는 mockery가 제공하는 추가적인 타입들로,
더 타입 안전하고 IDE 친화적인 방식으로 모의 객체를 설정하고 사용할 수 있게 합니다.
mockery가 이렇게 복잡한 구조를 사용하는 이유는 다음과 같습니다:
1. 타입 안정성: 생성된 코드는 컴파일 시점에 타입 오류를 잡을 수 있게 합니다.
2. IDE 지원: 자동 완성, 리팩토링 등 IDE 기능을 더 잘 활용할 수 있습니다.
3. 유연성: 다양한 사용 패턴(함수 반환, 값 반환 등)을 지원합니다.
4. 가독성: 생성된 코드는 특정 인터페이스에 맞춰져 있어, 사용자가 직접 작성하는 것보다 일관성 있고 이해하기 쉽습니다.
