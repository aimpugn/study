# Go modules

- [Go modules](#go-modules)
    - [`go.mod`란?](#gomod란)
    - [왜 go.mod가 각 디렉토리에 필요한가?](#왜-gomod가-각-디렉토리에-필요한가)
        - [독립적인 의존성 관리](#독립적인-의존성-관리)
        - [버전 관리](#버전-관리)
        - [명확한 구조](#명확한-구조)
        - [이식성](#이식성)
        - [간편한 빌드 및 테스트](#간편한-빌드-및-테스트)
    - [Go 모듈 설정 확인](#go-모듈-설정-확인)
    - ["공개 모듈 프록시"와 "체크섬 데이터베이스"](#공개-모듈-프록시와-체크섬-데이터베이스)
        - [공개 모듈 프록시 (Go Module Proxy)](#공개-모듈-프록시-go-module-proxy)
        - [체크섬 데이터베이스 (Go Module Checksum Database)](#체크섬-데이터베이스-go-module-checksum-database)
        - [이슈 발생](#이슈-발생)
    - [`go.mod`의 `module` 이름 바꾸기](#gomod의-module-이름-바꾸기)
    - [go get 으로 가져올 수 있도록 하기](#go-get-으로-가져올-수-있도록-하기)
        - [모듈 이름 설정](#모듈-이름-설정)
        - [Git 태그 생성 및 Push](#git-태그-생성-및-push)
        - [Go Get 사용](#go-get-사용)
    - [replace 와 hash](#replace-와-hash)

## `go.mod`란?

- Go 언어에서 작업 공간을 구성하는 데는 여러 가지 방법이 있지만, Go Modules를 사용하는 것이 현재 가장 권장되는 방법
- 이를 사용하면 `GOPATH`에 종속되지 않고, 각 프로젝트 디렉토리에 독립적으로 의존성을 관리할 수 있다

## 왜 go.mod가 각 디렉토리에 필요한가?

```tree
/path/to/docs/
|-- go/
|   |-- example1/
|   |   |-- go.mod
|   |   |-- main.go
|   |-- example2/
|   |   |-- go.mod
|   |   |-- main.go
|   |-- example3/
|   |   |-- go.mod
|   |   |-- main.go
|   |-- example4/
|       |-- cmd/
|       |   |-- go.mod
|       |   |-- main.go
|       |-- server/
|           |-- server.go

```

### 독립적인 의존성 관리

- 각 프로젝트(예제)가 독립적으로 의존성을 관리할 수 있다
- 예를 들어,
    - `example1` 프로젝트에서는 `packageA` v1.0을, `example2` 프로젝트에서는 `packageA` v2.0을 사용하고 싶을 수 있다.
    - 각 디렉토리에 go.mod 파일이 있으면 이런 상황을 쉽게 처리할 수 있다

### 버전 관리

- 각 프로젝트가 자체적으로 버전을 관리할 수 있다
- 이는 특히 여러 사람이 작업하거나, 프로젝트가 복잡해질 경우 유용하다

### 명확한 구조

- go.mod 파일이 있는 디렉토리는 **Go 모듈의 root 디렉토리로 간주**된다
- 이를 통해 Go 도구는 어디서 의존성을 찾아야 하는지, 어떤 소스 파일을 빌드해야 하는지 명확하게 알 수 있다

### 이식성

- go.mod 파일이 있는 디렉토리는 기본적으로 독립적인 작업 공간이 된다
- 따라서 이 디렉토리를 다른 환경으로 이동시키거나, 다른 사람에게 공유하기 쉽다

### 간편한 빌드 및 테스트

- 각 디렉토리에 `go.mod` 파일이 있으면, 해당 디렉토리에서 `go build`, `go test`, `go run`등의 명령을 실행할 때 추가적인 설정 없이 바로 실행할 수 있다

## Go 모듈 설정 확인

1. go.mod 파일 확인:
    - 모듈 이름과 Go 버전이 올바른지 확인
    - 필요한 모든 종속성이 나열되어 있는지, 그리고 그들의 버전이 올바른지 확인
2. go.sum 파일 확인:
    - 이 파일은 모듈의 의존성과 체크섬을 포함한다
    - 일반적으로 이 파일은 수동으로 편집되지 않지만, 문제가 발생한 경우 이 파일을 확인하여 모든 체크섬이 올바른지 확인할 수 있다
3. 환경 변수 확인:
    - `GO111MODULE` 환경 변수를 확인하여 모듈 지원이 활성화되어 있는지 확인한다
    - 이 변수가 on으로 설정되어 있는지 확인

    ```shell
    ╰─ go env GO111MODULE
    on
    ```

4. 모듈 종속성 확인

    ```shell
    #  프로젝트의 모든 모듈 종속성을 나열
    go list -m all
    ```

5. 모듈 종속성 업데이트:

    ```shell
    # 프로젝트의 모든 패키지를 빌드하고, 문제가 없는지 확인
    go build ./...
    ```

6. 모듈의 테스트 실행

    ```shell
    # 프로젝트의 모든 테스트를 실행하고, 문제가 없는지 확인
    go test ./...
  
    ```

## "공개 모듈 프록시"와 "체크섬 데이터베이스"

- 모듈 관리와 보안에 중요한 역할

### [공개 모듈 프록시 (Go Module Proxy)](https://goproxy.io/docs/introduction.html)

- 목적
    - Go 모듈 프록시는 Go 패키지들을 캐싱하고 제공하는 중간 서버 역할
    - 이를 통해 *Go 모듈들의 다운로드*와 *버전 관리*가 더욱 빠르고 안정적으로 이루어질 수 있다
- 작동 방식
    - 개발자가 특정 모듈을 요청할 때, Go 도구(`go get`, `go build` 등)는 설정된 모듈 프록시 서버를 통해 해당 모듈을 검색하고 다운로드
    - 이 과정은 모듈의 소스 저장소에 직접 접근하는 것보다 빠르고 안정적일 수 있다
- 캐싱
    - 모듈 프록시는 요청받은 모듈의 복사본을 캐시에 저장한다
    - 이로 인해 다음에 같은 모듈이 요청될 때, 소스 저장소가 아닌 프록시의 캐시에서 빠르게 제공될 수 있다
- 대표적인 예
    - Go의 공식 모듈 프록시인 `proxy.golang.org`는 많은 Go 개발자들이 사용하는 기본 설정된 프록시 서버

### [체크섬 데이터베이스 (Go Module Checksum Database)](https://go.dev/ref/mod#checksum-database)

- 목적
    - 체크섬 데이터베이스는 *모듈의 무결성과 보안을 보장*하기 위해 사용된다
    - 모듈의 내용이 변경되었는지 확인하는 데 필요한 체크섬(해시 값)을 저장하고 제공
- 보안
    - 모듈을 다운로드할 때, Go 도구는 체크섬 데이터베이스에서 해당 모듈의 체크섬을 확인하여, 다운로드된 모듈이 수정되지 않았음을 보증한다
    - 이는 믿을 수 없는 소스로부터의 코드 주입 또는 중간자 공격을 방지한다
- 대표적인 예: `sum.golang.org`는 Go의 공식 체크섬 데이터베이스로, 모듈의 무결성을 검증하는 데 사용됩니다.

### 이슈 발생

`GOPRIVATE`이 설정되지 않았을 때, Go 도구는 비공개 또는 내부 저장소에 있는 모듈을 공개 모듈 프록시나 체크섬 데이터베이스에서 찾으려고 시도할 수 있습니다. 이러한 모듈들은 공개적으로 접근할 수 없기 때문에, 이러한 시도는 실패하고 에러를 발생시킬 수 있습니다. 따라서, 비공개 모듈의 경우 `GOPRIVATE`을 적절히 설정하여 이러한 공개 모듈 시스템의 기본 동작을 우회해야 합니다.

## `go.mod`의 `module` 이름 바꾸기

```diff
-module github.com/my_org/submodule
+module github.com/other_org/submodule

go 1.20

... 생략 ...
```

- `go.mod` 파일에서 Go 모듈의 이름을 변경하는 것은 상대적으로 간단한 작업이지만, 여러 모듈이 함께 사용되는 상황에서는 몇 가지 추가적인 단계를 거쳐야 한다

1. 모듈명 변경: 먼저, `go.mod` 파일을 열고 `module` 지시어에서 모듈의 이름을 변경

   ```go
   module github.com/other_org/submodule

   go 1.20
   ...
   ```

2. 소스 코드 내 참조 업데이트:
    - 모듈 이름이 변경되면, 해당 모듈을 참조하는 모든 Go 파일에서 import 경로도 업데이트해야 한다
    - 이는 `github.com/my_org/submodule`을 `github.com/other_org/submodule`로 변경하는 것을 포함한다
3. 하위 모듈 및 의존성 업데이트
    - 만약 다른 모듈이나 패키지가 변경된 모듈에 의존하고 있다면, 그들의 `go.mod` 파일에서도 의존성의 경로를 업데이트해야 한다
4. Go Workspaces 사용
    - `go.work` 파일이 있다면, 이 파일 내에서도 모듈 경로를 업데이트해야 한다
    - `go.work` 파일은 다수의 모듈을 포함하는 작업 공간을 정의하는데 사용되므로, 여기에도 새로운 모듈 경로를 반영해야 한다
5. 테스트 및 빌드
    - 모든 변경 사항을 적용한 후, 프로젝트를 빌드하고 테스트하여 모든 것이 예상대로 작동하는지 확인한다
    - 이는 `go build`와 `go test` 명령을 사용하여 수행할 수 있다
6. 버전 관리 시스템 업데이트
    - 변경 사항을 Git과 같은 버전 관리 시스템에 커밋하고, 필요한 경우 새로운 리포지토리에 푸시
7. 하위 모듈의 의존성 업데이트
    - 만약 다른 프로젝트나 모듈이 이 모듈에 의존하고 있다면, 그 프로젝트의 `go.mod` 파일에서도 의존성 경로를 업데이트해야 한다

## go get 으로 가져올 수 있도록 하기

```go
// go.mod
module github.com/my-org/private-repo/another_service

// go.work 통해 관리되는 워크스페이스의 서브 패키지를 replace 사용해서 require
// https://github.com/golang/go/issues/50750 이슈 해결되면 제거
replace github.com/my-org/subpkg v0.0.1 => ../subpkg
```

```bash
# 이렇게 가져오도록 바꾸기
go get github.com/my-org/private-repo/subpkg@tag-version
```

1. Go 모듈 시스템
    - Go에서 모듈의 구성
        - 스 코드를 담고 있는 폴더
        - 관련 설정 파일인 `go.mod`. `go.mod` 파일은 다음 요소들을 포함
            - 모듈의 이름
            - 의존성 및
            - 기타 설정
2. 모노레포
    - 모노레포는 여러 프로젝트를 하나의 저장소에서 관리하는 접근 방식
    - `subpkg`는 모노레포 안의 하위 패키지로 존재하며, 이를 외부에서 참조하기 위해서는 몇 가지 추가적인 설정이 필요합니다.
3. Go Get과 Git 태그
    - Go에서 외부 모듈을 가져오는 (`go get`) 경우, 일반적으로 해당 모듈의 원격 저장소 URL과 태그(버전)를 지정한다.
    - 이때 Go는 Git 태그를 사용하여 특정 버전의 모듈을 가져온다

이제 주어진 상황에 대한 해결 방법을 제시하겠습니다:

### 모듈 이름 설정

- `subpkg`가 모노레포 안에 있더라도, 그 자체로 독립된 Go 모듈로 작동하도록 설정할 수 있다
- 이를 위해 `subpkg` 디렉토리에 `go.mod` 파일을 만들고, 모듈 이름을 `github.com/my-org/private-repo/subpkg`로 지정한다.

### Git 태그 생성 및 Push

- `subpkg`에 대한 변경 사항을 커밋하고, 적절한 버전 번호로 Git 태그를 생성한다
- 예를 들어, `v1.0.0`이라는 태그를 생성하려면, `subpkg` 디렉토리에서 다음과 같이 명령을 실행

    ```bash
    git tag v1.0.0
    # 원격 Git 저장소에 반영
    git push origin v1.0.0
    ```

### Go Get 사용

- 이제 다른 프로젝트에서 `subpkg` 모듈을 사용하려면, `go get` 명령을 사용하여 해당 모듈을 가져올 수 있다

  ```bash
  go get github.com/my-org/private-repo/subpkg@v1.0.0
  ```

이 방식으로, `go get`을 사용하여 태그된 버전의 모듈을 가져올 수 있습니다. 모듈의 버전 관리는 Git 태그를 통해 이루어지며, Go는 이 태그를 사용하여 특정 버전의 모듈을 식별하고 가져옵니다.

중요한 점: 만약 `private-repo`가 실제로 비공개 저장소라면, 해당 저장소에 접근할 수 있는 권한이 있는 사용자만 `go get`을 통해 모듈을 가져올 수 있습니다. Go 모듈 시스템은 기본적으로 공개된 Git 저장소에서 모듈을 가져옵니다. 비공개 저장소에서 모듈을 가져오려면 적절한 인증 설정이 필요합니다.

## replace 와 hash

go.mod.sum 은 reproducible 하지 않다
