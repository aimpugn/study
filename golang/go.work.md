# `go.work`

- [`go.work`](#gowork)
    - [`go.work`](#gowork-1)
    - [`go.work.sum`](#goworksum)
    - [리베이스시 `go.work.sum`의 충돌 해소](#리베이스시-goworksum의-충돌-해소)
        - [자동 병합 시도](#자동-병합-시도)
        - [수동 병합의 회피](#수동-병합의-회피)
        - [리베이스를 계속 진행](#리베이스를-계속-진행)
        - [팀과의 협의](#팀과의-협의)
        - [원격 저장소의 상태를 기준으로 사용](#원격-저장소의-상태를-기준으로-사용)
        - [테스트와 검증](#테스트와-검증)
    - [`go.work`에 모듈을 명시하지 않을 경우](#gowork에-모듈을-명시하지-않을-경우)
        - [`go.work` 파일에 모듈이 명시되지 않았을 때의 영향](#gowork-파일에-모듈이-명시되지-않았을-때의-영향)
        - [`go.work` 워크스페이스와 하위 모듈 생성](#gowork-워크스페이스와-하위-모듈-생성)
        - [결론](#결론)

## `go.work`

- Go 1.18부터 도입된 워크스페이스 기능(`go.work`)은 여러 관련 모듈을 하나의 작업 공간에서 함께 관리할 수 있게 해준다
- `go.work` 파일은 워크스페이스에 포함될 모듈의 경로를 나열한다.
- 이를 통해 여러 모듈 간의 의존성 관리와 개발 작업이 용이해진다

## `go.work.sum`

- `go.work.sum` 파일은 Go 워크스페이스에서 사용하는 모듈의 의존성을 추적하는데 사용된다
- 각 의존성의 특정 버전의 체크섬을 포함하고 있다
- 이 파일은 `go.mod` 파일과 유사하게 프로젝트의 의존성을 관리하지만, 워크스페이스 수준에서 작동한다

## 리베이스시 `go.work.sum`의 충돌 해소

### 자동 병합 시도

- 일반적으로 Git은 충돌을 자동으로 해결할 수 없을 때만 사용자에게 해결을 요구한다
- `go.work.sum` 파일의 경우, 자동 병합이 실패할 수 있으며, 이 경우 수동 개입이 필요

### 수동 병합의 회피

- 가장 깔끔하고 안전한 방법은 충돌이 발생한 `go.work.sum` 파일을 무시하고 새로 생성하는 것
    - 충돌이 발생한 `go.work.sum` 파일을 삭제
    - 명령어 `go work sync`를 사용하여 워크스페이스의 모든 모듈에 대한 새로운 `go.work.sum` 파일을 생성
    - 생성된 `go.work.sum` 파일을 커밋

### 리베이스를 계속 진행

- 리베이스 중 `go.work.sum` 파일의 충돌을 해결한 후에는 리베이스 과정을 계속 진행할 수 있다
    - `go work sync` 명령어로 새로운 `go.work.sum` 파일을 생성
    - `git add go.work.sum`
    - `git rebase --continue`

### 팀과의 협의

- 만약 이 프로젝트가 여러 사람과의 협업으로 이루어지고 있다면, `go.work.sum` 파일의 관리 방식에 대해 팀 내에서 일관된 방침을 세우는 것이 중요하다
- 어떤 경우에는 `go.work.sum` 파일을 Git에서 추적하지 않도록 결정할 수도 있다

### 원격 저장소의 상태를 기준으로 사용

- 만약 로컬 변경 사항이 `go.work.sum` 파일에 중요하지 않다면, 원격 저장소의 `go.work.sum` 파일 상태를 그대로 사용하는 것이 좋을 수 있다
- 이는 `git checkout --theirs path/to/go.work.sum` 명령어로 수행할 수 있다

### 테스트와 검증

- 충돌 해결 후에는 `go test` 명령어를 사용하여 의존성이 정확히 설치되었고, 모든 것이 올바르게 작동하는지 확인해야 한다
- `go.work.sum` 파일의 충돌을 해결하는 정석적인 방법은 상황에 따라 다를 수 있지만, 일반적으로 충돌을 해결하고 새로운 `go.work.sum` 파일을 생성하여 의존성이 올바르게 관리되고 있는지 확인하는 것

## `go.work`에 모듈을 명시하지 않을 경우

### `go.work` 파일에 모듈이 명시되지 않았을 때의 영향

1. 모듈 인식
    - `go.work` 파일은 워크스페이스에 포함할 모듈의 목록을 정의한다
    - 이 파일에 특정 모듈이 명시되지 않은 경우, Go 도구체인은 해당 모듈을 현재 활성화된 워크스페이스의 일부로 인식하지 않을 수 있다.
    - 결과적으로, 해당 모듈의 의존성 해석 및 빌드 과정이 워크스페이스의 컨텍스트에서 이루어지지 않을 것이다.
    - 이는 Go 툴체인이 해당 모듈을 워크스페이스 내의 다른 모듈들과 함께 빌드하거나 테스트하는 과정에서 고려하지 않는다는 것을 의미

2. 의존성 관리: 워크스페이스 내에서 모듈 간의 의존성이 해석될 때, `go.work`에 명시된 모듈만 고려됩니다. 만약 특정 모듈이 `go.work`에 포함되지 않았다면, 그 모듈의 의존성이나 참조는 워크스페이스 컨텍스트 내에서 올바르게 해석되지 않을 수 있습니다.

3. IDE와의 통합:
    - 개발 환경이나 IDE에서 `go.work` 파일을 기반으로 워크스페이스를 인식하고 관리한다
    - 모듈이 `go.work`에 포함되지 않으면 IDE에서 해당 모듈을 워크스페이스의 일부로 인식하지 못할 수 있으며, 이는 의존성 해석 및 기타 기능에 영향을 미칠 수 있다

### `go.work` 워크스페이스와 하위 모듈 생성

`go.work` 파일로 관리되는 워크스페이스에서 하위 모듈을 생성하는 것은 여전히 가능합니다. `go.work` 파일은 워크스페이스의 일부로 간주되는 모듈을 정의하는 역할을 하지만, 이것이 워크스페이스 외부에서 모듈을 생성하거나 관리할 수 없다는 것을 의미하지는 않습니다.

1. 독립된 모듈 생성: 새로운 하위 모듈을 생성하고자 할 때, 해당 모듈에 대한 `go.mod` 파일을 만들어 모듈을 초기화합니다. 이 모듈은 독립적으로 관리될 수 있습니다.

2. 워크스페이스에 추가 (선택 사항): 필요에 따라 이 모듈을 `go.work` 파일에 추가하여 워크스페이스의 일부로 만들 수 있습니다. 이렇게 하면 워크스페이스 내의 다른 모듈과의 상호 작용이나 의존성 관리가 용이해집니다.

3. 모듈 간 의존성: `go.work`에 추가되지 않은 모듈도 다른 모듈과 상호 작용할 수 있지만, 의존성 관리는 각 모듈의 `go.mod` 파일을 통해 이루어집니다.

### 결론

`go.work`는 특정 모듈들을 하나의 통합된 작업 공간으로 그룹화하는 데 사용되며, 워크스페이스에 포함된 모듈은 워크스페이스의 컨텍스트 내에서 관리됩니다. 하지만 이것이 `go.work` 외부에서 모듈을 생성하거나 사용할 수 없다는 의미는 아닙니다. 워크스페이스에 포함되지 않은 모듈도 여전히 독 립적으로 존재하고 관리될 수 있으며, 필요에 따라 워크스페이스에 추가할 수 있습니다.
