# pass by

## 메모리 처리 일반

- **가변적으로 처리되는 자료형의 메모리 할당 위치**

   Go에서 `fmt.Sprintf`와 같은 함수를 사용하여 문자열을 생성할 때, 결과적으로 생성되는 문자열은 힙(heap)에 저장됩니다.

   Go의 컴파일러와 가비지 컬렉터는 동적으로 메모리를 관리하며, 스택(stack)에 할당할 수 없거나, 함수 호출 범위를 벗어나는 생명주기를 가진 데이터는 힙에 할당됩니다.

   `fmt.Sprintf`는 내부적으로 문자열을 조합하고 새로운 문자열을 반환하는데, 이 반환된 문자열은 힙에 저장될 수 있습니다.

- **스택에서의 포인터 사용**

    스택에 저장된 변수나 데이터 구조는 힙에 할당된 데이터를 가리키는 포인터를 포함할 수 있습니다.

    예를 들어, `fmt.Sprintf`로 생성된 문자열을 변수에 할당하면, 그 변수는 스택에 위치하고, 실제 문자열 데이터는 힙에 위치하며, 변수는 힙에 저장된 문자열을 가리키는 포인터를 갖게 됩니다.

## pass by value

### When string

```go
type Receiver struct {
    SomeString string
}

func (r *Receiver)Test() {
    anotherFunction(r.SomeString)

}

func anotherFunction(someString string) { ... }
```

문자열 자체가 이미 내부적으로 데이터에 대한 포인터를 포함하고 있기 때문에, 대부분의 경우 문자열을 값 타입으로 사용하는 것이 효율적입니다.

- **SomeString의 사용과 메모리 복사**

   Go에서 문자열은 불변(immutable)이며, 문자열을 다룰 때 일반적으로 데이터의 복사본을 생성하지 않고 포인터를 통해 참조합니다.

   `r.SomeString`을 사용할 때, 이 문자열 데이터 자체의 복사가 발생하지 않습니다.
   대신, `SomeString`의 메모리 주소를 참조하는 포인터가 사용됩니다.
   따라서, 메모리 효율성이 높아집니다.

- **anotherFunction 호출과 매개변수 전달**

   `anotherFunction`을 호출하면서 `r.SomeString`을 매개변수로 넘길 때, Go의 문자열은 불변이기 때문에, 이 함수로 전달될 때 실제 문자열 데이터의 복사본을 생성하지 않습니다.

   대신, 문자열을 가리키는 포인터(주소)와 문자열의 길이 및 용량을 저장하는 메타데이터만 함수의 매개변수로 복사됩니다.
   이는 Go의 슬라이스와 유사한 방식으로 처리되며, 메모리 사용과 성능 최적화에 도움을 줍니다.

## pass by reference
