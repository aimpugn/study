# Go tools objdump

## go tool objdump`?

`go tool objdump`는 Go 프로그램의 컴파일된 바이너리에서 저수준의 어셈블리 코드를 추출하고 분석하기 위한 도구다.
이 도구는 개발자가 Go 프로그램의 컴파일된 코드를 보다 상세하게 이해할 수 있게 하며, 성능 최적화나 디버깅 과정에서 유용하게 사용될 수 있다.

### `go tool objdump`와 일반 `objdump`의 차이점

- **용도 및 언어 지원**: 일반 `objdump`는 GNU Binutils 패키지의 일부로, 다양한 프로그래밍 언어와 실행 파일 포맷을 지원하는 범용 도구입니다. 반면, `go tool objdump`는 Go 언어로 작성된 프로그램에 특화되어 있습니다.
- **출력 형식**: `go tool objdump`는 Go 언어의 심볼과 타입 정보에 대한 이해를 바탕으로 한 출력을 제공하며, Go 개발자에게 더 친숙한 정보와 형식으로 데이터를 제공합니다.
- **기능적 차이**: `go tool objdump`는 Go의 런타임, 고루틴, 채널 등 Go 언어의 특징을 반영한 정보를 제공할 수 있습니다. 일반 `objdump`는 이러한 언어 특정적인 요소에 대해 인식하지 못합니다.

## `go tool objdump`와 관련된 다른 도구들

Go 언어는 여러 가지 유용한 도구들을 제공하여 개발자가 코드를 효율적으로 분석하고 최적화할 수 있도록 지원합니다. 몇 가지 예를 들면:

- **`go build`**: Go 소스 코드를 컴파일하여 실행 가능한 바이너리 파일을 생성합니다.
- **`go test`**: Go 프로그램의 테스트를 실행합니다.
- **`go fmt`**: Go 소스 코드를 Go 언어의 표준 포맷에 맞게 자동으로 포매팅합니다.
- **`go vet`**: Go 소스 코드를 분석하여 의심스러운 구문, 에러 프론, 논리적 오류 등을 찾아냅니다.
- **`go profile`**: 프로그램의 실행 중에 성능 측정 데이터를 수집합니다. CPU 사용량, 메모리 할당 및 블록킹 이벤트 등 다양한 유형의 프로파일링을 지원합니다.
- **`go trace`**: Go 프로그램의 실행 중 발생하는 다양한 이벤트를 추적하여 시각화합니다.

이 도구들은 Go 개발 환경의 일부로서, Go 프로그램의 개발, 디버깅, 성능 최적화 과정을 지원합니다.

## 사용법

### 1. Go 프로그램 작성

타입 assertion과 reflection을 사용하는 간단한 예제 코드를 작성합니다. 예를 들어, interface 변수에 대해 타입 assertion을 수행하는 부분과 `reflect` 패키지를 사용하여 타입 정보를 확인하는 부분을 포함합니다.

```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    var i interface{} = "hello"

    // 타입 assertion
    s, ok := i.(string)
    if ok {
        fmt.Println(s)
    }

    // Reflection
    r := reflect.ValueOf(i)
    fmt.Println("Type of i:", r.Type())
}
```

### 2. 컴파일

작성한 프로그램을 컴파일합니다. 컴파일은 일반적으로 `go build` 명령어를 사용하여 수행됩니다.

```sh
go build -o example example.go
```

### 3. `go tool objdump` 사용

컴파일된 바이너리에 대해 `go tool objdump`를 실행하여 어셈블리 코드를 확인합니다. `go tool objdump`는 Go 프로그램의 어셈블리 코드를 출력해 주는 도구입니다.

```sh
go tool objdump example
```

특정 함수나 경로를 필터링하려면, 명령어 뒤에 필터를 추가합니다. 예를 들어, `main.main` 함수만 보고 싶다면:

```sh
go tool objdump -s "main.main" example
```

이렇게 하면, `main.main` 함수에 해당하는 어셈블리 코드 부분을 확인할 수 있으며, 여기서 타입 assertion과 reflection을 사용하는 부분의 차이를 직접 볼 수 있습니다. 각 오퍼레이션에 대한 어셈블리 코드를 살펴보며, 실행 시의 성능과 사용된 명령어들의 차이점을 분석할 수 있습니다.

이 과정을 통해 Go 언어에서 타입 assertion과 reflection의 내부 작동 방식과 성능 차이를 보다 깊이 이해할 수 있습니다.

### 4. 결과 읽어보기

```text
  main.go:8        0x10008b4f8        90000145        ADRP 163840(PC), R5            
  main.go:8        0x10008b4fc        9106c0a5        ADD $432, R5, R5            
  main.go:8        0x10008b500        b94000a5        MOVWU (R5), R5                
  main.go:8        0x10008b504        d29a44a6        MOVD $53797, R6                
  main.go:8        0x10008b508        f2ae0746        MOVK $(28730<<16), R6            
  main.go:8        0x10008b50c        2b0600bf        CMNW R6, R5                
  main.go:8        0x10008b510        54000408        BHI 32(PC)                
  main.go:8        0x10008b514        d281a786        MOVD $3388, R6                
  main.go:8        0x10008b518        f2ac9fa6        MOVK $(25853<<16), R6            
  main.go:8        0x10008b51c        6b0600bf        CMPW R6, R5                
  main.go:8        0x10008b520        54000389        BLS 28(PC)                
  main.go:8        0x10008b524        d29e4186        MOVD $61964, R6                
  main.go:8        0x10008b528        f2aed106        MOVK $(30344<<16), R6            
  main.go:8        0x10008b52c        6b0600bf        CMPW R6, R5                
  main.go:8        0x10008b530        54000308        BHI 24(PC)                
  main.go:8        0x10008b534        d2879f47        MOVD $15610, R7                
  main.go:8        0x10008b538        f2ad7da7        MOVK $(27629<<16), R7            
  main.go:8        0x10008b53c        6b0700bf        CMPW R7, R5                
  main.go:8        0x10008b540        54000280        BEQ 20(PC)                
  main.go:8        0x10008b544        6b0600bf        CMPW R6, R5                
  main.go:8        0x10008b548        54000241        BNE 18(PC)    
```

 main.go:8은 아래 부분이다

```go
    switch val.(type) {
```

이 어셈블리 코드는 Go 프로그램에서 타입 스위치를 구현하는 부분이다.
Go의 타입 스위치는 `interface{}` 타입의 변수 `val`의 실제 타입을 검사하여 해당 케이스를 실행하는 구조다.
이 코드 조각은 `val.(type)`에서 시작되는 타입 스위치의 어셈블리 구현을 보여준다.

#### 어셈블리 코드 분석

- **ADRP 및 ADD 명령어**:
    - `ADRP` (Add Relative to Page)와 `ADD` 명령어는 주소 계산을 위해 사용됩니다.
    - `ADRP`는 주어진 PC(프로그램 카운터) 상대 주소에 해당하는 페이지의 주소를 레지스터 `R5`에 로드합니다.
    - 이후 `ADD` 명령어를 통해 특정 오프셋을 추가하여 최종 주소를 계산합니다.

- **MOVWU 및 MOVD/MOVK 명령어**:
    - `MOVWU` (Move Word Unsigned)는 주소 `R5`에서 32비트 무부호 정수를 로드하여 `R5`에 저장합니다.
    - `MOVD`는 레지스터에 직접 상수 값을 로드하는 데 사용되고,
    - `MOVK`는 레지스터의 특정 부분에 값을 덮어쓰는 데 사용됩니다.

- **CMNW 및 CMPW 명령어**:
    - `CMNW` (Compare Negative Word) 레지스터의 값들을 비교
    - `CMPW` (Compare Word)는 레지스터의 값들을 비교합니다.
    - 이 명령어들은 조건부 분기 명령어들과 함께 사용되어, 타입 체크의 결과에 따라 다른 실행 경로를 선택합니다.

- **BHI, BLS, BEQ, BNE 명령어**: 이러한 분기 명령어들은 비교 연산의 결과에 따라 실행을 다른 위치로 점프시킵니다. 예를 들어,
    - `BHI` (Branch if Higher)는 한 값이 다른 값보다 클 경우에 분기를 수행하고,
    - `BEQ` (Branch if Equal)는 두 값이 동일할 때 분기를 수행합니다.

#### 개선 사항 분석하기

어셈블리 코드 분석과 성능 비교에 대해 더 자세히 설명하겠습니다. 전문가들은 어셈블리 코드를 분석하여 프로그램의 성능을 비교하고 개선 방향을 결정합니다. 이 과정에서 중요한 몇 가지 측면을 고려합니다.

1. **명령어 수**: 프로그램의 성능은 실행되는 명령어의 수에 크게 영향을 받습니다. 일반적으로 명령어 수가 적은 프로그램이 더 빠르게 실행됩니다. 따라서, 같은 작업을 수행하면서 명령어 수를 줄일 수 있는 최적화는 성능 향상에 기여합니다.

2. **명령어 종류와 사이클**: 모든 명령어가 동일한 시간(사이클) 안에 실행되는 것은 아닙니다. 메모리 접근, 산술 연산, 분기 등 다양한 명령어가 있으며, 각각의 실행 시간이 다릅니다. 예를 들어, 메모리 접근 명령어는 CPU 내부 연산 명령어보다 더 많은 사이클을 요구할 수 있습니다. 따라서, 성능 비교 시 이러한 차이를 고려해야 합니다.

3. **파이프라이닝과 병렬 처리**: 현대의 CPU는 파이프라이닝과 병렬 처리를 통해 여러 명령어를 동시에 처리할 수 있습니다. 어셈블리 코드를 분석할 때 이러한 CPU의 기능을 최대한 활용하는지 확인하는 것이 중요합니다. 예를 들어, 데이터 의존성으로 인해 파이프라인이 지연되는 경우 최적화를 통해 이를 줄일 수 있습니다.

4. **메모리 접근 패턴**: 메모리 접근 패턴은 프로그램의 성능에 큰 영향을 미칩니다. 캐시 메모리의 효율적 사용은 프로그램의 실행 속도를 크게 향상시킬 수 있습니다. 어셈블리 코드에서는 데이터의 공간적 및 시간적 지역성을 고려하여 메모리 접근을 최적화할 수 있습니다.

어셈블리 코드 분석을 통해 전문가들은 이러한 측면을 면밀히 검토하고, 프로그램의 성능을 결정하는 핵심 요소를 파악합니다. 성능 최적화는 이러한 분석을 바탕으로, 명령어 수를 줄이고, CPU 사이클을 최소화하며, 메모리 접근을 최적화하는 방향으로 이루어집니다. 따라서, 어셈블리 코드 분석은 프로그램의 성능을 극대화하기 위한 필수적인 과정입니다.
