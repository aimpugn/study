# Go method

- [Go method](#go-method)
    - [함수와 메서드?](#함수와-메서드)
        - [함수(Function)](#함수function)
        - [메서드(Method)](#메서드method)
        - [주요 차이점](#주요-차이점)
    - [리시버는 값 또는 포인터](#리시버는-값-또는-포인터)
        - [메서드 집합(Method Sets) 규칙](#메서드-집합method-sets-규칙)
        - [정의된 리시버에 따라 메서드 호출해야 함](#정의된-리시버에-따라-메서드-호출해야-함)
            - [`json.Marshal`과 `MarshalJSON` 메서드](#jsonmarshal과-marshaljson-메서드)
        - [포인터 리시버를 사용하는 이유](#포인터-리시버를-사용하는-이유)
        - [인터페이스와 포인터/값 리시버의 관계](#인터페이스와-포인터값-리시버의-관계)
        - [메서드 리시버는 포인터로 정의하되 인스턴스로 사용하기](#메서드-리시버는-포인터로-정의하되-인스턴스로-사용하기)
    - [메서드 호출 과정](#메서드-호출-과정)
        - [1. 타입 정보 사용](#1-타입-정보-사용)
        - [2. 메서드 세트에 접근](#2-메서드-세트에-접근)
        - [3. 수신자(`receiver`)를 통한 메서드 호출](#3-수신자receiver를-통한-메서드-호출)
    - [`nil`에 대해 메서드 호출](#nil에-대해-메서드-호출)
    - [메서드 vs 패키지 수준의 함수](#메서드-vs-패키지-수준의-함수)
        - [메서드(Method) 형태로 선언](#메서드method-형태로-선언)
        - [패키지 수준의 함수(Function)로 선언](#패키지-수준의-함수function로-선언)
        - [선택 기준](#선택-기준)

## 함수와 메서드?

### 함수(Function)

함수는 독립적으로 존재하는 코드 블록으로, 특정 작업을 수행한다.
함수는 입력(인자)을 받아 처리하고, 결과를 반환할 수 있다.
Go에서 함수는 `func` 키워드를 사용하여 정의된다. 어떤 타입에도 속하지 않으며, 전역적으로 호출될 수 있다.

```go
func Add(a int, b int) int {
    return a + b
}
```

### 메서드(Method)

메서드는 특정 타입에 속한 함수다.
메서드는 함수와 유사하지만, 특정 타입의 인스턴스(값 또는 포인터)와 연결되어 있으며, 이 인스턴스를 "수신자(receiver)"라고 한다.
메서드는 해당 타입의 인스턴스를 통해서만 호출될 수 있으며, 이를 통해 객체 지향 프로그래밍의 개념을 구현할 수 있다.

```go
type MyInt int

func (m MyInt) Add(other MyInt) MyInt {
    return m + other
}
```

### 주요 차이점

- **속성**:

    함수는 독립적으로 존재하는 반면, 메서드는 특정 타입의 인스턴스에 속한다.

- **호출 방식**

    함수는 이름을 통해 직접 호출되는 반면, 메서드는 특정 타입의 인스턴스를 통해 호출된다.
    이 인스턴스는 메서드의 첫 번째 매개변수로 전달되며, 이를 수신자라고 한다.

- **용도**

    함수는 일반적인 작업을 수행하는 데 사용되는 반면, 메서드는 특정 타입의 인스턴스와 관련된 작업을 수행하는 데 사용된다.
    이를 통해 타입의 메서드를 통해 해당 타입의 인스턴스에 대한 동작을 정의할 수 있다.

## 리시버는 값 또는 포인터

### 메서드 집합(Method Sets) 규칙

- **값 타입 `T`의 메서드 세트**

    모든 `T`에 대해 정의된 값 리시버를 가진 메서드를 포함한다.
    이는 `T` 타입의 인스턴스가 값 리시버를 사용하는 메서드만 호출할 수 있음을 의미한다.

- **포인터 타입 `*T`의 메서드 세트**

    모든 `T`에 대해 정의된 *값 리시버와 포인터 리시버를 가진 메서드를 포함*한다.
    이는 `*T` 타입의 인스턴스가 값 리시버와 포인터 리시버를 사용하는 **모든** 메서드를 호출할 수 있음을 의미한다.

```go
package main

import "fmt"

type MyInt int

// 값 리시버를 사용하는 메서드
func (m MyInt) ValMethod() {
    fmt.Println("Value receiver method called")
}

// 포인터 리시버를 사용하는 메서드
func (m *MyInt) PtrMethod() {
    fmt.Println("Pointer receiver method called")
}

func main() {
    var val MyInt = 5
    val.ValMethod() // 값 타입 인스턴스로 값 리시버 메서드 호출 가능
    // val.PtrMethod() // 컴파일 에러: 값 타입 인스턴스로 포인터 리시버 메서드 호출 불가능

    var ptr *MyInt = &val
    ptr.ValMethod() // 포인터 타입 인스턴스로 값 리시버 메서드 호출 가능
    ptr.PtrMethod() // 포인터 타입 인스턴스로 포인터 리시버 메서드 호출 가능
}
```

### 정의된 리시버에 따라 메서드 호출해야 함

Go 언어 스펙에서는 타입과 그 타입의 포인터가 각각 다른 메서드 집합을 가질 수 있도록 정의하고 있다.
이 규칙에 따라, 값 타입과 포인터 타입이 호출할 수 있는 메서드 집합이 달라질 수 있다.

```log
Cannot use 'cmd' (type mockCommand) as the type Command Type does not implement 'Command' as the 'GetContext' method has a pointer receiver
```

이 에러 메시지는 `Command` 인터페이스가 요구하는 메서드 중 하나의 리시버가 포인터로 정의되어 있기 때문에 발생한다.
Go에서, 인터페이스를 만족시키려면 해당 인터페이스에 정의된 모든 메서드를 구현한 타입이어야 한다.
만약 인터페이스에 정의된 메서드가 **포인터 리시버를 사용하는 경우, 해당 메서드는 포인터 타입에서만 호출**될 수 있다.
따라서, 값 타입의 변수는 포인터 리시버를 요구하는 메서드를 가진 인터페이스를 만족시키지 못한다.

예를 들어, 다음과 같은 인터페이스가 있다고 가정해 봅시다:

```go
type Command interface {
    GetContext() context.Context
}
```

그리고 다음과 같이 `GetContext` 메서드의 리시버가 포인터로 정의된 구현체가 있다.

```go
type mockCommand struct {
    // 필드 정의
}

func (m *mockCommand) GetContext() context.Context {
    // 구현
}
```

이 경우, `mockCommand` 타입의 포인터(`*mockCommand`)는 `Command` 인터페이스를 만족시킨다.
그러나 `mockCommand` 타입의 값은 `Command` 인터페이스의 `GetContext` 메서드를 구현하지 않았다고 간주된다.
왜냐하면 `GetContext` 메서드가 포인터 리시버를 요구하기 때문이다.

따라서, **`mockCommand` 타입의 변수를 `Command` 인터페이스 타입의 매개변수로 사용하려면, 해당 변수를 포인터로 전달**해야 한다.
예를 들어:

```go
var cmd Command = &mockCommand{} // 올바름
```

이와 반대로, 다음과 같이 값으로 전달하려고 하면 에러가 발생한다.

```go
var cmd Command = mockCommand{} // 에러 발생
```

위의 에러 메시지는 바로 이러한 상황에서 발생한다.
`mockCommand` 타입의 인스턴스를 값으로 사용하여 `Command` 인터페이스 타입의 변수에 할당하려고 하면, `mockCommand` 타입이 포인터 리시버를 사용하는 `GetContext` 메서드를 구현하지 않았다고 판단되어 컴파일 에러가 발생한다.

Go에서 인터페이스는 메서드 시그니처의 집합으로 정의된다.
타입이 인터페이스를 구현하기 위해서는, 그 인터페이스에 정의된 모든 메서드를 해당 타입의 메서드로 가지고 있어야 한다.
여기서 중요한 점은 메서드가 값 리시버로 정의됐는지, 아니면 포인터 리시버로 정의됐는지에 따라 해당 메서드를 가지는 타입이 달라진다.

#### `json.Marshal`과 `MarshalJSON` 메서드

`json.Marshal` 함수는 `json.Marshaler` 인터페이스를 구현하는 타입의 인스턴스를 마샬링할 때, 해당 타입의 `MarshalJSON` 메서드를 호출합니다. `json.Marshaler` 인터페이스는 다음과 같이 정의됩니다:

```go
type Marshaler interface {
    MarshalJSON() ([]byte, error)
}
```

여기서 중요한 점은, `json.Marshal` 함수가 인터페이스를 통해 메서드를 호출할 때 해당 타입의 메서드 세트에 `MarshalJSON` 메서드가 포함되어 있어야 한다는 것입니다. 즉, `MarshalJSON`이 포인터 리시버를 사용하는 경우, 이 메서드는 포인터 타입 `*T`의 메서드 세트에만 포함됩니다. 따라서, `json.Marshal`에 값 타입 `T`를 전달하면 `MarshalJSON` 메서드를 찾을 수 없게 되어, 인터페이스의 요구사항을 만족시키지 못하게 됩니다.

이 규칙은 "메서드 세트(Method Sets)" 또는 "인터페이스와 메서드 세트" 범주 하에 정리할 수 있습니다. 메서드 세트 규칙은 인터페이스 구현, 타입의 메서드 호출 가능성, 그리고 Go의 타입 시스템의 일관성을 이해하는 데 핵심적인 개념입니다. 이를 통해 Go에서는 타입 안전성을 보장하며, 메서드 호출 시의 예상 가능한 동작을 명확히 정의합니다.

### 포인터 리시버를 사용하는 이유

1. **상태 변경**: 포인터 리시버를 사용하는 메서드는 해당 타입의 인스턴스의 상태를 변경할 수 있습니다. 값 리시버를 사용하는 메서드는 호출 시 인스턴스의 복사본을 생성하므로 원본 인스턴스를 변경할 수 없습니다.

2. **성능 최적화**: 크기가 큰 구조체의 경우, 메서드 호출마다 구조체의 복사본을 만드는 것은 비효율적입니다. 포인터 리시버를 사용하면, 데이터를 복사하는 대신 메모리 주소만 전달하므로 성능을 향상시킬 수 있습니다.

### 인터페이스와 포인터/값 리시버의 관계

인터페이스는 메서드 시그니처의 집합을 정의하며, 타입이 이 인터페이스를 구현하기 위해서는 해당 메서드 시그니처와 일치하는 메서드를 가져야 합니다. 여기에는 메서드가 포인터 리시버인지 값 리시버인지가 포함됩니다.

- 값 리시버를 사용하는 메서드는 그 타입의 값과 포인터 모두에서 호출될 수 있습니다. 이는 값 리시버가 가변성(mutability)을 요구하지 않기 때문입니다.
- 반면, 포인터 리시버를 사용하는 메서드는 해당 타입의 포인터에서만 호출될 수 있습니다. 이는 포인터를 통해서만 원본 데이터를 수정할 수 있기 때문입니다.

따라서, **어떤 타입의 메서드가 포인터 리시버를 사용하는 경우, 그 타입의 포인터만이 메서드를 구현한 것으로 간주**됩니다.
이는 해당 메서드가 인터페이스를 만족시킬 수 있는 조건을 제한합니다.
**"왜"**에 대한 근본적인 이유는 Go의 타입 시스템이 타입의 가변성과 메서드 호출 시의 성능 최적화를 어떻게 다루는지에 기반합니다.
Go는 컴파일 시간에 이러한 규칙을 엄격하게 적용하여, 프로그램의 런타임 성능을 최적화하고 타입 안전성을 보장합니다.

### 메서드 리시버는 포인터로 정의하되 인스턴스로 사용하기

```go
type ByPointer struct {
    value1 string
    value2 int
    value3 []string
}

func (r *ByPointer) SetValue1(s string) {
    r.value1 = s
}

func (r *ByPointer) SetValue2(i int) {
    r.value2 = i
}

func (r *ByPointer) SetValue3(values ...string) {
    for _, value := range values {
        r.value3 = append(r.value3, value)
    }
}

func main() {
    // `ByPointer` 타입의 인스턴스 `p2`가 스택에 할당
    p2 := ByPointer{}
    // `p2Pointer`는 이 인스턴스를 가리키는 포인터
    p2Pointer := &p2
    // `p2` 인스턴스의 필드를 직접 수정
    p2Pointer.SetValue1("pointer of value")
    p2Pointer.SetValue3("111", "112", "113")
    fmt.Println(p2) // {pointer of value 0 [111 112 113]}
}
```

포인터 리시버를 사용하여 메서드를 정의하고 그 값을 포인터로 조작하는 것은 완전히 유효한 케이스다.
포인터 리시버를 사용하는 방식은 메서드 내에서 리시버가 가리키는 구조체의 필드를 수정할 때 사용된다.
이 방식을 사용하면 메서드가 리시버로 받은 구조체의 사본을 만들지 않기 때문에 메모리 사용량이 더 효율적이며, 구조체의 원본 상태를 직접 변경할 수 있다.

Go 언어의 메모리 관리 메커니즘에 따라, 구조체 인스턴스가 힙이나 스택에 할당되는 것은 Go 런타임에 의해 결정되며, 개발자가 직접 제어할 수 없다.
일반적으로 컴파일러는 이스케이프 분석을 통해 변수가 함수 범위를 벗어나 사용될지 결정하고, 그에 따라 스택에 할당할지 아니면 힙에 이스케이프시킬지를 결정한다.

Go의 가비지 컬렉터는 더 이상 필요 없어진 메모리를 자동으로 회수하며, 개발자는 객체의 생명주기를 직접 관리할 필요가 없다.
이는 Go의 가비지 컬렉션 메커니즘이 프로그램의 메모리 사용 효율성과 안정성을 보장해 주기 때문이다.

## 메서드 호출 과정

### 1. 타입 정보 사용

Go 컴파일러는 각 타입에 대한 메서드 집합을 컴파일 시점에 결정한다.
이 메서드 집합은 타입과 함께, 해당 타입의 인스턴스가 할 수 있는 모든 연산을 정의한다.
이 과정에서, 각 타입별로 어떤 메서드를 호출할 수 있는지의 정보가 타입 정보에 포함된다.

### 2. 메서드 세트에 접근

메서드를 호출할 때, Go 런타임은 이 타입 정보를 사용하여 해당 타입에 대한 메서드 세트에 접근한다.
즉, 호출하려는 메서드가 해당 타입의 메서드 세트에 속해 있는지를 확인한다.

### 3. 수신자(`receiver`)를 통한 메서드 호출

메서드가 해당 타입의 메서드 세트에 존재한다면, Go 런타임은 메서드를 호출하며, 메서드의 수신자(`receiver`)로 지정된 변수(`r` 등)를 메서드에 전달한다. 이때, 수신자는 `nil`이 될 수도 있다.

## `nil`에 대해 메서드 호출

```go
func (r *MyType) Test() bool {
  if r == nil {
    return false
  }
  return true
}

func test() {
  var tmp *MyType
  // Go 런타임은 `MyType` 타입에 정의된 `Test` 메서드를 찾아 호출하고,
  // `Test` 메서드 내에서는 `r`이 `nil`인지 아닌지를 체크한다.
  fmt.Println(tmp.Test()) // false
}
```

Go에서 메서드는 특정 타입의 값 또는 포인터를 수신자(receiver)로 받으며, 이를 기반으로 해당 타입에 연결된 연산을 수행한다.
이는 수신자가 값 타입이든 포인터 타입이든 관계없이 적용됩니다.

`nil` 포인터에 대한 메서드 호출이 가능한 근본적인 이유는 메서드 호출이 해당 타입의 메타데이터와 연결되어 있기 때문이다.
따라서, 메서드는 타입 정보를 기반으로 하여, 심지어 해당 인스턴스가 `nil` 포인터일지라도 실행될 수 있다.

메서드 호출은 타입 정보를 기반으로 이루어지며, 타입 정보에 따라 해당 타입의 인스턴스(여기서는 `nil` 포인터)에 대해 정의된 메서드를 실행하기 때문이다. 즉, Go 런타임이 메서드를 호출할 때 실제로 메모리에 존재하는 객체를 참조하는 것이 아니라, 해당 타입의 메서드 세트에 접근하기 위해 타입 정보만을 사용한다. 메서드 호출하기 위해 메모리 상에 실제로 존재하는 객체를 필요로 하지 않으므로 `nil`에 대해 메서드 호출이 가능하다.

실제 구현 측면에서, Go의 메서드는 해당 타입의 인스턴스(값이나 포인터)를 첫 번째 인자로 받는 함수로 동작한다.
이는 메서드 호출이 내부적으로 함수 호출로 변환되며, 이 과정에서 `nil` 포인터도 유효한 첫 번째 인자가 될 수 있음을 의미한다.
예를 들어, `(*MyType).Test` 함수는 내부적으로 `func Test(r*MyType) bool`와 같이 작동하며, 이 때 `r`은 메서드를 호출하는 객체의 포인터다.

결국, 메서드 호출이 해당 타입의 메서드 세트와 직접적으로 연결되어 있기 때문에, 수신자가 `nil`이더라도 메서드는 호출될 수 있다.
*실행 시점에* 수신자의 실제 상태(`nil` 여부 포함)는 메서드 내에서 분기 처리를 통해 판단된다.
이러한 방식을 사용할 때는 메서드 내에서 수신자가 `nil`인 경우를 적절히 처리해주어야 한다. 그렇지 않으면 런타임 패닉(runtime panic)이 발생할 수 있습니다.

## 메서드 vs 패키지 수준의 함수

### 메서드(Method) 형태로 선언

특정 타입에 대한 메서드로 정의함으로써, 객체 지향 프로그래밍의 이점을 활용할 수 있으며, 타입의 인터페이스를 구성하는 방식으로 확장성을 높일 수 있다.

```go
func (r *myType) parseHeader() (*returnType, error) {}
```

`myType`이라는 타입에 메서드를 정의한다.
즉, 이 메서드는 `myType` 타입의 인스턴스(또는 포인터)에 속해 있으며, 이 인스턴스의 상태에 접근하거나 수정할 수 있다.
  
메서드는 해당 타입의 인스턴스 **상태에 의존적**인 로직을 구현하는 데 적합하다.
즉, `parseHeader`가 `myType`의 필드나 상태를 사용하거나 변경해야 하는 경우 메서드로 정의하는 것이 좋다.

타입의 속성을 사용한다는 것은 해당 작업이 그 타입과 밀접한 연관이 있다는 신호일 수 있다.
따라서, 이러한 경우 메서드로 정의하는 것이 자연스러울 수 있다.

```go
func (r *myType) performAction() error {
    // r.repository를 사용하여 무언가를 합니다.
}
```

메서드는 해당 타입의 일부로, 타입과 밀접한 작업을 수행한다는 점에서 응집성이 높다.
메서드 호출 시, 작업이 특정 타입의 인스턴스에 대해 수행된다는 것이 명시적으로 드러난다.
 인터페이스를 통한 다형성, 캡슐화 등 객체 지향 프로그래밍의 이점을 활용할 수 있다.

### 패키지 수준의 함수(Function)로 선언

```go
func parseHeader() (*returnType, error) {}
```

특정 타입에 속하지 않는, 패키지 내에서 전역적으로 사용될 수 있는 함수를 정의한다.
이 함수는 특정 타입의 인스턴스 없이도 호출될 수 있으며, 타입의 내부 상태에 접근할 수 없다.

함수가 특정 타입의 인스턴스 **상태와 무관**한 로직을 수행하는 경우, 즉 입력만 받아 처리하고 결과만 반환하는 형태의 로직이라면 패키지 수준의 함수로 정의하는 것이 적합하다.
패키지 내 또는 다른 패키지에서도 사용될 수 있는 일반적이고 재사용 가능한 로직을 구현하는 데 적합하다.

가령 함수가 타입의 내부 상태를 변경하지 않고 단지 타입의 속성을 "읽기"만 한다면, 그리고 그 작업이 타입에 강하게 종속되지 않는다면, 일반 함수로 선언하고 타입을 파라미터로 넘기는 방식도 고려할 수 있다.

```go
func performAction(r *myType) error {
    // r.repository를 사용하여 무언가를 합니다.
}
```

같은 타입의 다른 인스턴스나 유사한 구조를 가진 다른 타입에 대해서도 함수를 재사용할 수 있다.
함수가 특정 타입의 메서드가 아니라 일반 함수로 정의됨으로써, 해당 타입과의 결합도가 낮아지고, 시스템 전체의 유연성을 증가시킬 수 있다.

### 선택 기준

결국, 선택은 **함수가 타입의 어떤 속성을 어떻게 사용하는가**와 **그 작업이 타입의 책임과 얼마나 밀접하게 연관되어 있는가**에 따라 달라진다.
타입의 속성을 사용하여 타입의 핵심 책임에 해당하는 작업을 수행한다면, 메서드로 정의하는 것이 좋다.
반면, 타입의 속성을 사용하지만 그 작업이 타입의 핵심 책임과는 거리가 있다면, 일반 함수로 선언하는 것이 더 적합할 수 있다.

**유지보수성과 가독성**도 중요한 고려 사항이다.
코드를 읽고 이해하는 사람이 함수나 메서드의 목적을 쉽게 파악할 수 있도록 하는 것이 중요하며, 팀 내에서 일관된 방식을 유지하는 것도 좋은 방법이다.

- **타입의 상태나 메서드가 작업에 필수적인가?**: 타입의 특정 상태에 접근하거나 수정해야 한다면 메서드로 정의한다.
- **함수가 타입과 무관한 일반적인 작업을 수행하는가?**: 타입과 독립적인 작업을 수행하거나, 다양한 타입에 대해 공통적으로 사용될 수 있는 로직이라면 패키지 수준의 함수로 정의한다.
