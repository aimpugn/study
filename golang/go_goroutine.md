# Goroutine

- [Goroutine](#goroutine)
    - [고루틴(Goroutine)이란?](#고루틴goroutine이란)
        - [vs green thread?](#vs-green-thread)
    - [경량성의 비밀](#경량성의-비밀)
    - [Channel](#channel)
    - [동기화](#동기화)
    - [유저 공간에서의 스케쥴링](#유저-공간에서의-스케쥴링)
        - [프로세스와 스레드의 스케줄링](#프로세스와-스레드의-스케줄링)
        - [Go 런타임의 고루틴 스케줄링](#go-런타임의-고루틴-스케줄링)
        - [Go 런타임의 사용자 공간 스케줄링 로직](#go-런타임의-사용자-공간-스케줄링-로직)
    - [goroutine과 k8s](#goroutine과-k8s)
        - [Kubernetes CPU 자원 할당](#kubernetes-cpu-자원-할당)
        - [Goroutine과 멀티 코어](#goroutine과-멀티-코어)
        - [Kubernetes에서 Goroutine 활용](#kubernetes에서-goroutine-활용)
        - [sorty 라이브러리와 Kubernetes](#sorty-라이브러리와-kubernetes)
        - [결론](#결론)
    - [`chan`](#chan)
        - [채널의 기본 사용법](#채널의-기본-사용법)
        - [채널의 종류](#채널의-종류)
        - [예제: Unbuffered Channel](#예제-unbuffered-channel)
        - [예제: Buffered Channel](#예제-buffered-channel)
    - [OS 신호 처리 패턴](#os-신호-처리-패턴)
        - [1. 채널 생성](#1-채널-생성)
        - [2. 신호 등록](#2-신호-등록)
        - [3. 신호 대기](#3-신호-대기)
    - [read-only 전역 변수와 goroutine](#read-only-전역-변수와-goroutine)
        - [예제: 읽기 전용 전역 변수](#예제-읽기-전용-전역-변수)
    - [채널의 생명주기](#채널의-생명주기)
    - [병렬성, 동시성, OS, 프로세스, 스레드 및 Go 테스팅 종합 가이드](#병렬성-동시성-os-프로세스-스레드-및-go-테스팅-종합-가이드)
        - [1.1. 병렬성 vs 동시성](#11-병렬성-vs-동시성)
        - [1.2. CPU, 코어, 스레드](#12-cpu-코어-스레드)
    - [2. 운영체제 (OS)](#2-운영체제-os)
        - [2.1. OS의 역할](#21-os의-역할)
        - [2.2. 프로세스 vs 스레드](#22-프로세스-vs-스레드)
        - [2.3. 스케줄러](#23-스케줄러)
    - [3. Go 언어의 동시성 모델](#3-go-언어의-동시성-모델)
        - [3.1. 고루틴 (Goroutines)](#31-고루틴-goroutines)
        - [3.2. 채널 (Channels)](#32-채널-channels)
    - [4. Go 테스팅과 병렬성](#4-go-테스팅과-병렬성)
        - [4.1. t.Parallel() 상세 분석](#41-tparallel-상세-분석)
        - [4.2. 병렬 테스트의 이점과 주의점](#42-병렬-테스트의-이점과-주의점)
    - [5. 실제 예제와 시나리오](#5-실제-예제와-시나리오)
    - [6. 결론 및 Best Practices](#6-결론-및-best-practices)

## 고루틴(Goroutine)이란?

Goroutine은 Go 언어에서 제공하는 경량 스레드 구현입니다.
`Goroutine`이라는 이름은 'Go' 언어와 '코루틴(coroutine)'의 합성어입니다.
- `coroutine`이란? 서브루틴(subroutine)의 일반화된 형태로, 실행을 중지하고 재개할 수 있는 독립적인 함수
- `goroutine`은 `coroutine`의 개념을 확장하여, 동시에 여러 작업을 쉽고 효율적으로 처리할 수 있도록 설계되었다

Goroutine은 그린 스레드와 유사한 개념입니다.
- 고루틴은 Go 런타임에 의해 관리되는 경량 실행 단위로, 함수나 메서드를 동시에 실행하는 데 사용됩니다.
- OS 스레드보다 메모리 사용량이 적고, 생성 및 전환 비용이 낮기 때문에 전통적인 OS 스레드보다 훨씬 가볍습니다.

동시성(concurrency)을 처리하는 데 사용됩니다.
- 동시성(`concurrency`)? 여러 작업이 '겹쳐서' 실행되는 것을 의미
- 병렬성(`parallelism`)? 여러 작업이 '실제로 동시에' 실행되는 것을 의미

goroutine은 Go 런타임에 의해 관리되며, Go 런타임 스케줄러는 이러한 **goroutine들을 OS 스레드에 매핑**합니다.
- 이 과정에서 Go 런타임은 많은 수의 goroutine을 소수의 OS 스레드에 효율적으로 스케줄링하여, 동시성을 높은 수준으로 관리합니다.
- 각 goroutine은 약 *2KB 정도의 스택 메모리*를 사용하는데, 이는 전통적인 스레드가 사용하는 메모리보다 훨씬 적어, 수만 개 또는 그 이상의 goroutine을 동시에 실행할 수 있습니다.

### vs green thread?

[green thread](../terminology/green_thread.md)는 운영 시스템이 아닌 사용자 수준의 라이브러리나 런타임에 의해 구현된 스레드를 의미합니다.

`goroutine`과 그린 스레드 사이에는 몇 가지 공통점이 있습니다. 둘 다 경량화된 실행 단위이며, 많은 수를 동시에 실행할 수 있도록 설계되었습니다.  
- 하지만 `goroutine`은 Go 언어의 핵심 부분으로 통합되어 있으며, Go 런타임 스케줄러에 의해 관리됩니다.
- 반면, 그린 스레드는 특정 언어나 라이브러리에서 사용자 수준에서 구현된 쓰레드입니다.

`goroutine`은 그린 스레드의 개념을 기반으로 하지만, Go 언어와 런타임에 특화된 특징과 최적화를 가지고 있습니다.
따라서 고루틴은 개념적으로 그린 스레드와 유사하다고 볼 수 있으나, Go 언어의 특정 구현과 최적화를 통해 구별됩니다.

예를 들어,
- **`goroutine`은 Go 런타임이 OS 스레드 위에서 멀티플렉싱을 수행하여 효율적으로 관리하고, 멀티코어 프로세서를 활용**할 수 있게 해줍니다.
- 반면, 그린 스레드는 특정 구현에 따라 멀티코어를 효과적으로 활용하지 못할 수도 있습니다.

따라서 고루틴은 그린 스레드에 속한다기보다는, 그린 스레드의 개념을 확장하고 특화시킨 Go 언어의 독특한 구현이라고 할 수 있습니다.

고루틴은 그린 스레드의 한 형태로 볼 수 있지만, Go 언어의 특화된 런타임 최적화와 관리 메커니즘을 가지고 있습니다. 따라서 고루틴은 단순히 그린 스레드로 분류하기보다는 *Go 언어의 고유한 경량 스레드 모델*로 이해하는 것이 좋습니다. 고루틴의 경량성, 사용자 공간 스케줄링, 높은 동시성 제공 등은 그린 스레드의 특징을 공유하면서도, Go 런타임의 최적화된 관리 덕분에 성능과 효율성이 뛰어납니다.

- 공통점

    - 고루틴과 그린 스레드는 모두 일반 OS 스레드보다 가볍습니다. 작은 메모리 스택과 낮은 생성 비용을 가지고 있습니다.
    - 두 스레드 모델 모두 사용자 공간에서 스케줄링되며, 이는 커널 스케줄링과 독립적입니다.
    - 많은 수의 고루틴이나 그린 스레드를 생성하고 실행할 수 있어 높은 동시성을 제공합니다.

- 차이점

    고루틴은 Go 런타임에 의해 관리되며, 이는 고루틴의 스케줄링, 스택 크기 조정 등을 자동으로 처리합니다.
    그린 스레드는 특정 언어나 프레임워크에 따라 다르게 구현될 수 있으며, 고루틴만큼의 자동 관리는 아닐 수 있습니다.

    고루틴은 Go 언어에 내장된 기능으로, Go 언어의 표준 라이브러리와 긴밀하게 통합되어 있습니다.
    그린 스레드는 다양한 언어와 프레임워크에서 구현될 수 있으며, 언어에 따라 다르게 동작할 수 있습니다.

    고루틴은 Go 런타임이 최적화된 방식으로 관리하며, Go 언어의 비동기 및 동시성 패턴에 최적화되어 있습니다.
    린 스레드는 일반적으로 동일한 최적화 수준을 가지지 않을 수 있습니다.

고루틴은 Go 런타임에서 자체 스케줄러를 통해 관리됩니다.
고루틴 스케줄러는 M:N 매핑 모델을 사용하여 다수의 고루틴(M)을 소수의 OS 스레드(N)에서 실행합니다.
이를 통해 고루틴의 생성 및 컨텍스트 스위칭 오버헤드를 최소화합니다.

다음은 간단한 고루틴 예제입니다:

```go
package main

import (
    "fmt"
    "time"
)

func printNumbers() {
    for i := 1; i <= 5; i++ {
        time.Sleep(1 * time.Second)
        fmt.Println(i)
    }
}

func main() {
    go printNumbers() // 고루틴 생성
    time.Sleep(6 * time.Second)
    fmt.Println("Done")
}
```

이 예제에서 `printNumbers` 함수는 고루틴으로 실행되며, 메인 함수는 고루틴이 완료될 때까지 기다립니다. 고루틴은 고유한 스택 공간을 가지며, Go 런타임이 고루틴의 실행을 관리합니다.

## 경량성의 비밀

- 초기 메모리 할당
    - 고루틴은 초기에 매우 작은 메모리 *스택*(몇 킬로바이트)을 할당받는다.
    - 이 스택은 필요에 따라 동적으로 확장되거나 축소될 수 있다
- 사용자 공간 스케줄링
    - 고루틴은 Go 런타임에 의해 *사용자 공간*(user space)에서 스케줄된다.
    - 이 덕분에 OS 커널을 거치지 않아서 컨텍스트 전환 비용이 훨씬 적다
- M:N 스케줄링 모델
    - 고루틴은 M(고루틴):N(OS 스레드) 스케줄링 모델을 사용
    - 여러 고루틴(M)을 소수의 OS 스레드(N)에 효율적으로 매핑
- 컨텍스트 스위칭 최적화
    - Goroutine 간의 컨텍스트 스위칭은 OS 스레드 수준의 컨텍스트 스위칭보다 가볍다

## Channel

- 고루틴 간의 통신은 채널을 통해 이루어진다
- 채널은 고루틴 사이에서 데이터를 안전하게 전달할 수 있는 수단을 제공한다

## 동기화

- 고루틴은 동기화 메커니즘(예: 뮤텍스, 웨이트 그룹)을 통해 공유 자원에 대한 접근을 관리하여 데드락과 경쟁 상태를 방지한다

## 유저 공간에서의 스케쥴링

- 고루틴은 사용자 공간(user space, 운영 체제의 프로세스 스케줄링과는 구별되는 개념)에서 스케줄링된다.
- 운영 체제 커널이 아닌 Go 런타임이 스케줄링과 관리를 담당

> 유저 공간?
>
> 사용자 공간은 운영 체제가 사용자 응용 프로그램을 실행하는 영역이다. 이 공간에서 응용 프로그램은 시스템 자원에 대한 직접적인 제어를 갖지 않는다.
> 사용자 공간의 프로그램은 커널의 보호를 받는 자원에 직접 접근할 수 없으며, 시스템 리소스에 접근하기 위해서는 시스템 콜을 통해 커널의 도움을 받아야 한다.
> 따라서 오류가 발생해도 시스템 전체에 영향을 미치지 않도록 격리되어 있다.
>
> 커널 공간?
>
> 커널 공간은 운영 체제의 핵심 부분이 실행되는 영역으로, 하드웨어와 직접적인 상호작용을 한다.
> 즉, 커널은 전체 시스템 리소스에 대한 권한을 가지고 있으며, 하드웨어 제어, 메모리 관리, 프로세스 스케줄링 등을 수행한다.
> 커널은 효율적인 시스템 관리를 가능하게 하지만, 오류가 발생하면 시스템 전체에 심각한 영향을 미칠 수 있다

### 프로세스와 스레드의 스케줄링

- 운영 체제 수준에서의 스케줄링
- 운영 체제는 프로세스와 커널 수준의 스레드를 스케줄링하며, 이는 CPU 자원을 어떤 프로세스나 스레드에 할당할지 결정하는 과정이다
- 컨텍스트 스위칭(context switching)이 발생할 때, 운영 체제는 CPU의 상태를 저장하고, 다음 실행할 프로세스나 스레드의 상태를 복원한다

### Go 런타임의 고루틴 스케줄링

- 고루틴과 Go 런타임
    - 고루틴은 Go 런타임에 의해 관리되며, 이 런타임은 사용자 공간(user space)에서 작동한다
    - 사용자 공간에서의 스케줄링은 운영 체제 커널을 직접 거치지 않고, Go 런타임 내부에서 고루틴들을 관리한다
    - Go 런타임이 직접 CPU를 할당하거나 컨트롤하지는 않는다. Go 런타임 내부에서 고루틴을 어떻게 스케줄하고 관리할지 결정할 뿐이다.
    - 따라서 실제 프로세서 시간을 할당받기 위해서는 OS 스레드가 필요하므로, 실제 CPU 자원의 할당은 여전히 운영 체제의 스케줄러에 의해 이루어진다
- M:N 스케줄링 모델
    - Go 런타임은 M:N 스케줄링 모델을 사용한다
    - 이는 'M' 개의 고루틴을 'N' 개의 OS 스레드에 매핑하는 것을 의미
    - 여기서 'N'은 CPU 코어의 수에 의존적이며, 일반적으로 OS 스레드 수는 CPU 코어 수보다 적거나 같다
- 스케줄링 메커니즘
    - Go 런타임은 고루틴을 실행할 OS 스레드를 선택하고, 필요에 따라 고루틴을 다른 스레드로 이동시킬 수 있다.
    - 이 과정은 모두 Go 런타임 내부에서 이루어지며, 운영 체제의 컨텍스트 스위칭과는 다른 메커니즘을 사용한다

### Go 런타임의 사용자 공간 스케줄링 로직

1. 고루틴 생성: `go` 키워드를 사용하여 고루틴을 생성하면, Go 런타임은 이를 내부 스케줄링 큐에 추가한다
2. 고루틴 실행: Go 런타임은 OS 스레드에 고루틴을 할당하여 실행한다. 이 과정에서 Go 런타임은 고루틴이 언제 실행될지, 어떤 OS 스레드에서 실행될지 결정한다.
3. 컨텍스트 전환: 고루틴이 블로킹 작업(예: I/O, 시스템 콜)을 만나면, Go 런타임은 다른 고루틴으로 전환하여 CPU 시간을 효율적으로 사용한다.

## goroutine과 k8s

### Kubernetes CPU 자원 할당

- Kubernetes에서 CPU 자원은 일반적으로 밀리코어(millicores, m) 단위로 할당된다
    - 예를 들어, `1000m`은 한 개의 CPU 코어를 완전히 사용할 수 있는 자원을 의미
- 이 할당은 Pod가 사용할 수 있는 최대 CPU 자원을 지정합니다. 즉, Pod는 이 자원 한계 내에서 자유롭게 CPU를 사용할 수 있습니다.

### Goroutine과 멀티 코어

- `goroutine`은 Go의 경량 스레드로, Go 런타임 스케줄러에 의해 관리됩니다.
- Go 런타임은 멀티 코어 환경에서 자동으로 `goroutine`을 여러 코어에 분산시켜 동시성과 병렬성을 달성합니다.

### Kubernetes에서 Goroutine 활용

- Kubernetes 환경에서 Go 프로그램을 실행할 때, Pod에 할당된 CPU 자원 내에서 `goroutine`을 사용하여 멀티 코어를 활용할 수 있습니다.
- 예를 들어, Pod에 `2000m` CPU가 할당되었다면, 이론적으로 최대 2개의 CPU 코어를 동시에 활용할 수 있습니다.
- Go 런타임은 이러한 환경에서도 여러 `goroutine`을 효율적으로 스케줄링하여 동시에 실행할 수 있습니다.

### sorty 라이브러리와 Kubernetes

- `sorty`와 같은 동시성/병렬 정렬 라이브러리는 `goroutine`을 사용하여 정렬 작업을 병렬로 수행합니다.
- Kubernetes 환경에서 Pod에 충분한 CPU 자원이 할당되면, 이러한 라이브러리는 멀티 코어를 활용해 효율적으로 동시성과 병렬 정렬 작업을 수행할 수 있습니다.

### 결론

Kubernetes에서 Pod에 할당된 CPU 자원이 충분하다면, Go 프로그램은 그 내에서 `goroutine`을 사용하여 멀티 코어의 장점을 살릴 수 있습니다. 이는 `sorty`와 같은 동시성/병렬 정렬 라이브러리에도 적용되어, Pod가 할당받은 자원 내에서 효율적인 병렬 처리가 가능합니다. 그러나 주의해야 할 점은 Pod에 할당된 자원을 초과하여 사용하려고 하면 성능 문제나 다른 제약이 발생할 수 있다는 것입니다.

## `chan`

Go 언어에서 `chan` 타입은 *고루틴 간의 통신*을 위해 사용되는 채널을 나타낸다.
채널을 통해 한 고루틴에서 다른 고루틴으로 데이터를 안전하게 전송할 수 있으며, 이를 통해 동시성 프로그래밍에서 발생할 수 있는 경쟁 상태(race condition)를 방지할 수 있다.
채널은 FIFO(First In, First Out) 방식으로 데이터를 전송한다.

### 채널의 기본 사용법

채널은 `chan` 키워드를 사용하여 선언한다.
채널의 타입은 전송되는 데이터의 타입에 의해 결정된다.
예를 들어, `int` 타입의 데이터를 전송하는 채널은 `chan int`로 선언된다.

```go
ch := make(chan int)
```

채널에 데이터를 전송하기 위해서는 채널을 대상으로 `<-` 연산자를 사용한다. 이 연산자는 "채널에 데이터를 보낸다"는 의미를 갖는다.

```go
ch <- 10 // ch 채널에 정수 10을 보낸다
```

채널로부터 데이터를 수신하기 위해서도 `<-` 연산자를 사용한다.

```go
value := <-ch // ch 채널로부터 데이터를 수신하여 value 변수에 저장한다.
```

### 채널의 종류

- **Unbuffered Channel (버퍼 없는 채널)**:
    - 데이터를 전송하는 고루틴은 수신자가 데이터를 받을 때까지 블록된다.
    - 마찬가지로, 데이터를 수신하는 고루틴도 데이터가 도착할 때까지 블록된다.
- **Buffered Channel (버퍼 있는 채널)**:
    - 채널을 생성할 때 지정된 크기의 버퍼를 갖는다.
    - 버퍼가 가득 차지 않으면, 데이터를 보내는 고루틴은 블록되지 않는다.
    - 마찬가지로 버퍼에 데이터가 있으면, 데이터를 받는 고루틴도 블록되지 않는다.

### 예제: Unbuffered Channel

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    ch := make(chan int)

    go func() {
        for i := 0; i < 5; i++ {
            ch <- i // 하나의 고루틴이 0부터 4까지의 숫자를 채널을 통해 메인 고루틴에 전송한다.
            time.Sleep(time.Second)
        }
        close(ch) // 더 이상 보낼 데이터가 없으면 채널을 닫는다.
    }()

    // 메인 고루틴은 채널로부터 숫자를 수신하여 출력
    for value := range ch {
        fmt.Println(value) // 채널로부터 데이터를 받아 출력한다.
    } // 채널이 닫히면 `for` 루프가 종료
}
```

### 예제: Buffered Channel

```go
package main

import "fmt"

func main() {
    ch := make(chan int, 2) // 버퍼 크기가 2인 채널을 생성한다.

    // 두 개의 데이터를 채널에 보낸다.
    ch <- 1 // 버퍼가 있기 때문에, 채널에 데이터를 보내는 고루틴은 즉시 블록되지 않는다.
    ch <- 2 // 버퍼가 가득 찰 때까지 데이터를 계속 보낼 수 있다.

    // 데이터를 수신하여 출력한다
    fmt.Println(<-ch)
    fmt.Println(<-ch)
}
```

## OS 신호 처리 패턴

```go
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit
```

프로그램이 외부에서 오는 특정 신호(예: 인터럽트 또는 종료 신호)를 기다리고, 이를 통해 우아하게 종료할 수 있도록 합니다.

### 1. 채널 생성

```go
quit := make(chan os.Signal, 1)
```

- `os.Signal` 타입의 `quit` 채널을 생성합니다. 이 채널은 OS 신호를 수신하기 위해 사용됩니다.
- 채널은 버퍼 크기 1로 설정됩니다. 이는 채널이 한 개의 신호를 보관할 수 있음을 의미하며, 이 신호는 비동기적으로 받아들여질 수 있습니다. 즉, 신호 발생 시 즉시 채널에 저장되어, 수신자가 준비될 때까지 대기할 수 있습니다.

### 2. 신호 등록

```go
signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
```

`signal.Notify` 함수는 `quit` 채널을 통해 프로그램이 특정 신호를 수신하길 원할 때 사용됩니다.

여기서는 아래 두 신호를 `quit` 채널에 연결합니다:
- `syscall.SIGINT`: 일반적으로 Ctrl+C에 의해 생성
- `syscall.SIGTERM`: 운영 체제가 프로세스를 종료시킬 때 보내는 신호

이 함수 호출이 완료되면, OS로부터 이 두 신호 중 하나가 발생하면 자동적으로 `quit` 채널로 전달됩니다.

### 3. 신호 대기

```go
<-quit
```

이 코드 라인은 `quit` 채널에서 신호를 기다립니다. 채널로부터 신호가 수신될 때까지 블로킹됩니다.

프로그램이 `syscall.SIGINT` 또는 `syscall.SIGTERM` 신호 중 하나를 받으면, 해당 라인은 신호를 받고 넘어가 프로그램의 다음 단계로 진행하거나 종료 준비를 합니다.

이 패턴은 주로 서버나 긴 작업을 수행하는 애플리케이션에서 "우아한 종료"를 위해 사용됩니다.

예를 들어, 신호를 받은 후에는 데이터베이스 연결을 닫거나, 임시 파일을 정리하거나, 실행 중인 작업을 안전하게 완료할 수 있습니다.

## read-only 전역 변수와 goroutine

데이터 경쟁은 여러 스레드(또는 고루틴)가 동시에 같은 데이터에 접근하려고 할 때, 그 중 적어도 하나가 데이터를 수정하려고 할 때 발생합니다.
만약 모든 접근이 단지 데이터를 읽기만 한다면, 어떤 스레드도 데이터를 변경시키지 않으므로 데이터 경쟁(race condition)이 발생하지 않습니다
이는 여러 고루틴이 동시에 같은 메모리 위치를 읽기만 하고, 그 값을 변경하지 않기 때문에 안전합니다.

### 예제: 읽기 전용 전역 변수

```go
package main

import (
    "fmt"
    "sync"
)

var globalData = []int{1, 2, 3, 4, 5} // 전역 변수, 변경되지 않음

func printData(wg *sync.WaitGroup) {
    defer wg.Done()
    for _, value := range globalData {
        fmt.Println(value)
    }
}

func main() {
    var wg sync.WaitGroup
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go printData(&wg)
    }
    wg.Wait()
}
```

이 예제에서 `globalData`는 여러 고루틴에서 동시에 접근하지만, 모든 고루틴은 데이터를 읽기만 하므로 안전합니다.

단, 다음과 같은 사항들에 주의해야 합니다.

- **불변성 보장**

    전역 변수가 프로그램 실행 동안 절대 변경되지 않는다는 것을 확실히 보장해야 합니다.
    초기화 이후에는 어떠한 수정도 이루어져서는 안 됩니다.

- **문서화**

    전역 변수가 읽기 전용임을 명확히 문서화하고, 코드 리뷰를 통해 이를 감시하는 것이 좋습니다.

## 채널의 생명주기

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    // 1. 채널 생성 (열림)
    ch := make(chan int)
    
    // 2. 채널 사용
    go sender(ch)
    go receiver(ch)
    
    // 메인 고루틴이 종료되지 않도록 대기
    time.Sleep(time.Second)
    
    // 3. 채널 닫기
    close(ch)
    
    // 닫힌 채널에서 읽기
    v, ok := <-ch
    fmt.Printf("읽은 값: %v, 채널 열림 상태: %v\n", v, ok)
}

func sender(ch chan<- int) {
    for i := 0; i < 5; i++ {
        ch <- i  // 채널에 데이터 보내기
        fmt.Printf("송신: %d\n", i)
    }
}

func receiver(ch <-chan int) {
    for {
        v, ok := <-ch  // 채널에서 데이터 받기
        if !ok {
            fmt.Println("채널이 닫혔습니다.")
            return
        }
        fmt.Printf("수신: %d\n", v)
    }
}
```

네, 채널의 열림과 닫힘에 대해 자세히 설명해 드리겠습니다. Go 언어에서 채널의 생성, 사용, 그리고 닫힘 과정을 단계별로 살펴보겠습니다.

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    // 1. 채널 생성 (열림)
    ch := make(chan int)
    
    // 2. 채널 사용
    go sender(ch)
    go receiver(ch)
    
    // 메인 고루틴이 종료되지 않도록 대기
    time.Sleep(time.Second)
    
    // 3. 채널 닫기
    close(ch)
    
    // 닫힌 채널에서 읽기
    v, ok := <-ch
    fmt.Printf("읽은 값: %v, 채널 열림 상태: %v\n", v, ok)
}

func sender(ch chan<- int) {
    for i := 0; i < 5; i++ {
        ch <- i  // 채널에 데이터 보내기
        fmt.Printf("송신: %d\n", i)
    }
}

func receiver(ch <-chan int) {
    for {
        v, ok := <-ch  // 채널에서 데이터 받기
        if !ok {
            fmt.Println("채널이 닫혔습니다.")
            return
        }
        fmt.Printf("수신: %d\n", v)
    }
}

```

1. 채널 생성 (열림):
   - `ch := make(chan int)`로 정수형 채널을 생성합니다.
   - 이 시점에서 채널은 "열린" 상태입니다.
   - 채널은 내부적으로 데이터 큐와 상태 정보를 가집니다.

2. 채널 사용:
   - 송신: `ch <- i`로 채널에 데이터를 보냅니다.
     - 채널이 가득 차면 송신자는 블록됩니다.
   - 수신: `v, ok := <-ch`로 채널에서 데이터를 받습니다.
     - 채널이 비어있으면 수신자는 블록됩니다.
     - `ok`는 채널이 열려있는지 여부를 나타냅니다.

3. 채널 닫기:
   - `close(ch)`로 채널을 닫습니다.
   - 닫힌 채널의 특성:
     - 더 이상 데이터를 보낼 수 없습니다 (panic 발생).
     - 기존에 채널에 있던 데이터는 계속 읽을 수 있습니다.
     - 모든 데이터를 읽은 후에는 채널의 제로값과 false를 반환합니다.

채널이 닫히는 과정을 더 자세히 살펴보면:

1. `close(ch)` 호출 시:
   - 채널의 내부 상태가 "닫힘"으로 변경됩니다.
   - 채널에서 대기 중이던 모든 수신자들이 깨어납니다.
   - 이후 송신 시도는 패닉을 발생시킵니다.

2. 닫힌 채널에서의 수신:
   - 채널에 남아있는 데이터가 있으면 정상적으로 수신됩니다.
   - 모든 데이터를 소비한 후:
     - `v, ok := <-ch`에서 `ok`는 `false`가 됩니다.
     - `v`는 채널 타입의 제로값이 됩니다 (int 채널의 경우 0).

3. `for range` 루프와 함께 사용 시:
   - 채널이 닫히면 루프가 자동으로 종료됩니다.

예제 실행 결과:

```sh
송신: 0
수신: 0
송신: 1
수신: 1
송신: 2
수신: 2
송신: 3
수신: 3
송신: 4
수신: 4
채널이 닫혔습니다.
읽은 값: 0, 채널 열림 상태: false
```

이 예제에서 볼 수 있듯이, 채널이 닫힌 후에도 수신자는 이를 감지하고 적절히 대응할 수 있습니다. 채널의 닫힘은 송신자가 더 이상 데이터를 보내지 않을 것임을 수신자에게 알리는 방법으로 사용됩니다.

채널의 이러한 특성은 Go의 동시성 프로그래밍에서 중요한 역할을 하며, 특히 여러 고루틴 간의 통신과 동기화에 유용하게 사용됩니다.

## 병렬성, 동시성, OS, 프로세스, 스레드 및 Go 테스팅 종합 가이드

### 1.1. 병렬성 vs 동시성

병렬성(Parallelism)과 동시성(Concurrency)은 종종 혼동되는 개념이지만, 중요한 차이가 있습니다.

- **병렬성(Parallelism)**: 여러 작업을 실제로 동시에 실행하는 것.
    - 예: 멀티코어 프로세서에서 여러 스레드가 각각 다른 코어에서 동시에 실행됨.
  
- **동시성(Concurrency)**: 여러 작업을 동시에 다루는 방식이나 구조.
    - 실제로 동시에 실행되지 않더라도, 논리적으로 동시에 실행되는 것처럼 처리.
    - 예: 단일 코어에서 시분할을 통해 여러 작업을 번갈아 수행.

### 1.2. CPU, 코어, 스레드

- **CPU (Central Processing Unit)**: 컴퓨터의 두뇌 역할을 하는 주요 처리 장치.

- **코어(Core)**: CPU 내의 실제 연산 처리 장치. 현대의 CPU는 대부분 멀티코어.

- **스레드(Thread)**:
    - **하드웨어 스레드**: 하이퍼스레딩과 같은 기술로 구현된 물리적 코어의 가상 분할.
    - **소프트웨어 스레드**: OS에서 관리하는 실행의 단위.

## 2. 운영체제 (OS)

### 2.1. OS의 역할

운영체제는 하드웨어 리소스를 관리하고, 애플리케이션과 하드웨어 간의 인터페이스 역할을 합니다.

주요 기능:
- 프로세스 관리
- 메모리 관리
- 파일 시스템 관리
- I/O 관리

### 2.2. 프로세스 vs 스레드

- **프로세스(Process)**:
    - 실행 중인 프로그램의 인스턴스.
    - 독립된 메모리 공간, 자원을 가짐.

- **스레드(Thread)**:
    - 프로세스 내에서 실행되는 가장 작은 실행 단위.
    - 같은 프로세스의 스레드들은 메모리 공간을 공유.

### 2.3. 스케줄러

OS 스케줄러는 CPU 사용을 관리하고 프로세스/스레드 간 전환을 결정합니다.

주요 스케줄링 알고리즘:
- Round Robin
- Priority Scheduling
- Multilevel Queue Scheduling

## 3. Go 언어의 동시성 모델

Go는 CSP(Communicating Sequential Processes) 모델을 기반으로 한 독특한 동시성 모델을 가지고 있습니다.

### 3.1. 고루틴 (Goroutines)

- 경량 스레드로, OS 스레드보다 훨씬 적은 리소스를 사용.
- Go 런타임에 의해 관리되며, OS 스레드에 동적으로 멥핑됨.

```go
go func() {
    // 비동기적으로 실행될 코드
}()
```

### 3.2. 채널 (Channels)

- 고루틴 간의 통신과 동기화를 위한 메커니즘.
- 데이터를 주고받을 때 사용.

```go
ch := make(chan int)
ch <- 42  // 채널에 데이터 전송
value := <-ch  // 채널에서 데이터 수신
```

## 4. Go 테스팅과 병렬성

### 4.1. t.Parallel() 상세 분석

`t.Parallel()`의 주요 동작:

1. 테스트를 병렬 실행 가능한 상태로 표시.
2. 현재 테스트를 일시 중지.
3. 다른 직렬 테스트들이 완료될 때까지 대기.
4. 다른 병렬 테스트들과 함께 실행.

코드 분석:

```go
func (t *T) Parallel() {
    if t.isParallel {
        panic("testing: t.Parallel called multiple times")
    }
    t.isParallel = true
    // ... (기타 초기화 코드)
    
    t.signal <- true   // 현재 테스트 일시 중지
    <-t.parent.barrier // 직렬 테스트 완료 대기
    t.context.waitParallel() // 다른 병렬 테스트와 함께 실행 시작
    
    // ... (재시작 코드)
}
```

### 4.2. 병렬 테스트의 이점과 주의점

이점:
- 전체 테스트 실행 시간 단축
- 리소스 활용도 향상
- 동시성 관련 버그 발견 용이

주의점:
- 테스트 간 독립성 확보 필요
- 공유 리소스 접근 시 주의 필요
- 비결정적 동작 가능성

## 5. 실제 예제와 시나리오

병렬 테스트 예제:

```go
func TestA(t *testing.T) {
    time.Sleep(2 * time.Second)
    t.Log("TestA completed")
}

func TestB(t *testing.T) {
    t.Parallel()
    time.Sleep(2 * time.Second)
    t.Log("TestB completed")
}

func TestC(t *testing.T) {
    t.Parallel()
    time.Sleep(2 * time.Second)
    t.Log("TestC completed")
}
```

실행 순서:
1. TestA 실행 (2초)
2. TestB와 TestC 동시 실행 (2초)

총 실행 시간: 약 4초 (병렬 실행 없이는 6초)

## 6. 결론 및 Best Practices

- 병렬성과 동시성의 차이를 이해하고 적절히 활용하세요.
- Go의 동시성 모델(고루틴, 채널)을 효과적으로 사용하세요.
- 테스트 작성 시 `t.Parallel()`을 고려하되, 테스트 독립성을 확보하세요.
- 공유 자원 접근 시 적절한 동기화 메커니즘을 사용하세요.
- 성능과 안정성의 균형을 유지하세요.

이 가이드를 통해 병렬성, 동시성, OS, 프로세스, 스레드, 그리고 Go 테스팅에 대한 종합적인 이해를 얻을 수 있기를 바랍니다.
