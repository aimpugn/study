# Go Workspace

## Go 작업 공간

Go 1.18부터 도입된 작업 공간(workspace) 기능은 개발자가 여러 Go 모듈을 하나의 작업 공간에서 관리할 수 있게 해준다.
이 기능은 주로 `go.work` 파일을 통해 구성된다.

### `go.work` 파일

`go.work` 파일은 작업 공간의 루트 디렉토리에 위치하며, 작업 공간에 포함될 모듈의 경로를 명시한다.
이 파일은 `use` 지시어를 사용하여 작업 공간에 포함할 모듈의 `go.mod` 파일 경로를 지정한다.

```plaintext
use (
    ./path/to/module1
    ./path/to/module2
)
```

`go.work` 파일이 존재하면, `go build`, `go run`, `go test` 등의 명령을 실행할 때 Go 도구는 이 파일을 찾아 해당 작업 공간 설정에 따라 모듈 해석을 수행한다. 이는 개발 중에 여러 관련 모듈을 함께 빌드하고 테스트하는 데 유용하다.

### `go.work.sum` 파일

`go.work.sum` 파일은 `go.work` 파일과 함께 작업 공간에 포함된 모듈의 의존성 정보를 포함한다.
이 파일은 `go.sum` 파일과 유사하게 작동하여, 모듈의 의존성이 변경되지 않았는지 검증하는 데 사용된다.
`go.work.sum` 파일은 `go mod tidy`, `go mod download`, `go build`, `go run` 등의 명령을 실행할 때 자동으로 생성되거나 업데이트된다.

### 동작 방식

- **go build/go run 시**

    `go.work` 파일이 있는 경우, Go 도구는 이 파일에 명시된 모듈들을 현재 작업 공간의 일부로 간주한다.
    이는 여러 모듈 간의 의존성을 해결하고, 모듈 간에 공유되는 코드를 함께 빌드하고 실행하는 데 도움이 된다.
    `go.work.sum` 파일은 이 과정에서 모듈의 의존성이 변경되지 않았는지 검증하는 데 사용된다.

- **모듈 해석**:

    `go.work` 파일이 있으면, Go 도구는 이 파일에 명시된 모듈 경로를 우선적으로 사용하여 의존성을 해석한다.
    이는 프로젝트 내에서 개발 중인 모듈 간의 의존성을 쉽게 관리할 수 있게 해준다.

- **의존성 검증**:

    `go.work.sum` 파일은 작업 공간에 포함된 모듈의 의존성이 변경되지 않았는지 검증하는 데 사용된다.
    이는 모듈의 의존성이 예상대로 안전하게 관리되고 있는지 확인하는 데 도움이 된다.

결론적으로, `go.work`와 `go.work.sum` 파일은 Go의 작업 공간 기능을 통해 여러 모듈을 효율적으로 관리하고, 모듈 간의 의존성을 쉽게 해결할 수 있게 해주며, `go build`, `go run` 등의 명령 실행 시 이러한 설정에 따라 동작한다.

## [Get familiar with workspaces](https://go.dev/blog/get-familiar-with-workspaces)

With Go workspaces, you control all your dependencies using a `go.work` file in the root of your workspace directory. The `go.work` file has `use` and `replace` directives that override the individual `go.mod` files, so there is no need to edit each `go.mod` file individually.

## 기타

### `cmd/go`와 GOWORK 변수

#### 문제점

`go.work` 파일을 커밋하는 것이 모든 개발자가 동일한 모듈 해석 결과를 얻게 하는 것은 맞고, 이는 프로젝트의 일관성을 유지하는 데 도움이 된다.
그러나 `GOWORK=on`이 기본값으로 설정되어 있을 때 발생할 수 있는 몇 가지 문제점들이 있다

1. **개발 환경과 생산 환경의 차이**:

    `GOWORK=on` 설정은 개발 중에 여러 모듈을 함께 작업할 때 유용할 수 있다.
    그러나 생산 환경에서는 일반적으로 단일 모듈 또는 프로젝트만 배포된다.
    `GOWORK=on`이 기본값이면, 개발 환경과 생산 환경 사이에 불일치가 발생할 수 있으며, 이는 배포 시 예기치 않은 문제를 야기할 수 있다.

2. **의도치 않은 모듈 해석**:

    `go.work` 파일이 프로젝트에 커밋되어 있으면, 해당 파일에 명시된 모듈 설정이 모듈 해석에 사용된다.
    이는 의도치 않은 의존성 버전이 사용되는 경우를 포함하여, 프로젝트의 모듈 해석에 영향을 줄 수 있다.
    특히, 프로젝트를 처음 접하는 개발자나 외부 기여자가 예상치 못한 빌드 결과를 얻을 수 있다.

3. **유연성 감소**:

    `GOWORK=on`이 기본값일 경우, 개발자는 `go.work` 파일의 사용 여부를 선택하는 대신 항상 이 설정에 따라야 한다.
    이는 특정 상황에서 개발자가 원하는 설정을 사용하는 데 제약을 줄 수 있다.

이러한 문제점들을 고려할 때, `GOWORK=off`를 기본값으로 설정하는 것은 개발자에게 더 많은 유연성을 제공하고, 개발 환경과 생산 환경 사이의 일관성을 유지하는 데 도움이 될 수 있다. 개발자는 필요에 따라 명시적으로 `GOWORK=on`을 설정하여 작업 공간 기능을 활용할 수 있으며, 이는 프로젝트의 특정 요구 사항에 더 잘 맞출 수 있게 해준다.

결론적으로, `GOWORK=on`을 기본값으로 하는 대신 `GOWORK=off`를 기본값으로 제안하는 것은 Go 프로젝트의 빌드와 배포 과정에서 발생할 수 있는 문제를 최소화하고, 개발자가 보다 명확하고 일관된 방식으로 의존성을 관리할 수 있게 하기 위함이다.

#### 기본으로 끄자는 제안

Go의 빌드 도구에 대한 좋은 점 중 하나는 대부분의 경우 임의의 Go 프로젝트에서 `go install`을 실행하여 완전히 작동하는 실행 파일을 얻을 수 있다는 것이다.
하지만 `GOWORK=on`이 기본값으로 설정되면, 더이상 완전히 작동하는 실행파일을 얻을 수 없게 된다.

- CVS(Concurrent Versions System")에 `go.work` 파일을 커밋했다면?

    그 파일이 모듈 해석에 사용된다.
    이는 해당 프로젝트를 클론하거나 작업하는 다른 개발자들이 동일한 작업 공간 설정을 사용하게 됨을 의미한다.
    따라서, 모듈 해석이 `go.work` 파일에 명시된 대로 이루어지게 된다.

- 그 파일을 `.gitignore`에 넣었다면?

    프로젝트를 클론하고 빌드하는 다른 사람과 비교하여 다른 빌드를 얻게 된다.
    이는 해당 파일이 버전 관리 시스템에 포함되지 않음을 의미하므로, 프로젝트를 클론하거나 작업하는 다른 개발자들은 `go.work` 파일 없이 프로젝트를 빌드하게 되며, 이로 인해 다른 모듈 해석 결과를 얻을 수 있다.

이슈 #51967에서는 Make 스크립트와 유사한 것으로 이를 제어해야 한다는 주장이 있었는데, 이는 저에게 이상한 주장으로 보인다.
기본값은 생산 빌드를 향해야 하며, 다시 말하지만, Go의 빌드 도구의 아름다움은 그저 `go install`을 실행하는 간단함에 있다.

관련 이슈 #53502는 `go.work`를 CVS에 커밋해야 하는지에 대한 논의를 하고 있으며, `GOWORK=off`가 기본값이었다면 이 질문에 답할 수 있었을 것이다.

이슈 #51967 스레드에서의 최종 주장은 다음과 같습니다

> 여기에는 새로운 문제가 없으며, 우리가 `replace` 지시어에서 가졌던 것과 같은 문제들뿐입니다...

여기서 큰 차이점은 이제 문제가 보이지 않는다는 것이다.

`replace` 지시어를 사용할 때는 "개발용 replace 지시어는 임시적이어야 하며 CVS에 절대 커밋되어서는 안 된다"는 잘 정의된 상황이 있었습니다. 이를 따르기 위해 주의가 필요했으며, 저는 확실히 한 번 이상 문제를 겪었습니다. 하지만 현재 상황은 저는 1) `go.work` 파일을 사용하지 않거나 2) 모든 프로젝트에 대해 Make 파일을 생성해야 합니다(또는 `GOWORK=off`를 설정하기 위한 다른 도구), 이를 스스로 기억하고 다른 사람들도 단순히 `go install`을 실행하지 않도록 문서화해야 합니다.

이상적인 상황은 개발을 할 때 GOWORK를 켤 수 있는 것이 될 것이다. e.g. `GOWORK=on code .`
