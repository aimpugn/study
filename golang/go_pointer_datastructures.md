# Go pointer and data structure

- [Go pointer and data structure](#go-pointer-and-data-structure)
    - [Slice: 참조 타입](#slice-참조-타입)
        - [메모리 할당](#메모리-할당)
        - [내부 구조](#내부-구조)
        - [공유와 복사](#공유와-복사)
    - [Map: 참조 타입](#map-참조-타입)
        - [메모리와 동작](#메모리와-동작)
        - [동시성 고려](#동시성-고려)
    - [Array: 값 타입](#array-값-타입)
        - [고정 길이의 이점](#고정-길이의-이점)
        - [값 타입의 특성](#값-타입의-특성)
    - [포인터의 포인터](#포인터의-포인터)
    - [고급 메모리 관리 전략](#고급-메모리-관리-전략)
        - [Escape Analysis](#escape-analysis)
        - [가비지 컬렉션 최적화](#가비지-컬렉션-최적화)

## Slice: 참조 타입

- 참조 타입: Slice는 참조 타입입니다. 이는 slice를 변수에 할당하거나 함수에 전달할 때 실제 데이터의 복사본이 아닌 데이터 구조 자체의 참조(포인터)가 전달된다는 것을 의미합니다.
- 포인터 사용: 일반적으로 slice 자체를 포인터(`*[]Type`)로 사용할 필요는 없습니다.
- 예시: `[]*MyType`은 `MyType` 포인터들의 slice를 나타냅니다.

### 메모리 할당

- **동적 크기 조정**: Slice는 동적 배열로서, 크기가 런타임에 조정됩니다. 이는 메모리를 효율적으로 사용하며, 불필요한 할당을 줄일 수 있습니다.

### 내부 구조

- **포인터, 길이, 용량**: Slice는 세 가지 주요 구성 요소를 가집니다: 데이터에 대한 포인터, 현재 길이, 최대 용량. 이는 slice가 메모리를 어떻게 사용하는지 이해하는 데 중요합니다.

### 공유와 복사

- **참조에 의한 전달**: Slice를 함수에 전달하면 참조가 전달되므로, 원본 slice가 수정될 수 있습니다. 이는 메모리 효율성을 높이지만, 부작용을 유발할 수 있습니다.

## Map: 참조 타입

- 참조 타입: Map 역시 참조 타입입니다.
- 포인터 사용: Map을 포인터(`*map[KeyType]ValueType`)로 사용하는 것은 일반적인 상황에서는 필요하지 않습니다.
- 예시: `map[string]*MyType`은 문자열 키와 `MyType` 포인터 값들을 갖는 map을 나타냅니다.

### 메모리와 동작

- **해시 테이블 구현**: Go의 map은 내부적으로 해시 테이블을 사용하여 구현됩니다. 이는 키-값 쌍의 빠른 조회와 삽입을 가능하게 합니다.

### 동시성 고려

- **안전하지 않은 동시 접근**: Map은 동시성에 안전하지 않습니다. 여러 고루틴에서 map을 수정할 경우 동기화 메커니즘을 사용해야 합니다.

## Array: 값 타입

- 값 타입: Array(`[Size]Type`)는 고정된 크기를 가지며, 값 타입입니다. 이는 배열을 함수에 전달하면 배열의 전체 내용이 복사된다는 것을 의미합니다.
- 포인터 사용: 큰 배열을 다룰 때는 배열 전체를 복사하는 것을 피하기 위해 포인터(`*[Size]Type`)를 사용할 수 있습니다.
- 예시: `[10]*MyType`은 `MyType`의 포인터 10개를 담는 배열입니다.

### 고정 길이의 이점

- **메모리 할당의 예측성**: Array는 고정된 크기를 가지며, 이는 메모리 할당과 사용의 예측 가능성을 제공합니다.

### 값 타입의 특성

- **복사에 의한 전달**: Array는 값 타입이므로, 함수에 전달 시 전체 배열이 복사됩니다. 이는 메모리와 성능 측면에서 중요한 고려사항입니다.

## 포인터의 포인터

- Slice와 Map의 포인터: Slice나 Map을 포인터로 사용(`*[]*MyType`, `*map[string]*MyType`)하면 포인터의 포인터가 됩니다.
- 특별한 상황: 이런 사용은 특별한 상황에서만 유용할 수 있으며, 코드의 복잡성과 가독성 저하를 초래할 수 있습니다.
- 일반적 사용: 대부분의 경우, slice와 map은 이미 참조 타입이므로 추가적인 포인터 사용은 필요하지 않습니다.

## 고급 메모리 관리 전략

### Escape Analysis

- **힙과 스택의 할당 결정**: Go 컴파일러는 escape analysis를 수행하여, 변수가 스택에 할당될지, 아니면 힙에 할당될지 결정합니다. 이는 메모리 사용의 최적화에 기여합니다.

### 가비지 컬렉션 최적화

- **효율적인 메모리 회수**: Go의 가비지 컬렉터는 메모리 관리를 단순화하며, 불필요한 메모리 할당을 최소화합니다.
