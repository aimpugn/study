# string

- [string](#string)
    - [문자열 종류](#문자열-종류)
        - [`String`](#string-1)
        - [`str`](#str)
        - [`&str`](#str-1)
        - [`CString`과 `CStr`](#cstring과-cstr)
        - [`OsString`과 `OsStr`](#osstring과-osstr)
        - [`PathBuf`과 `Path`](#pathbuf과-path)
        - [`Cow<'a, str>`](#cowa-str)
    - [문자열 연산](#문자열-연산)
        - [`+` 연산](#-연산)
            - [`String`과 `&str`의 결합](#string과-str의-결합)
            - [`String` 끼리의 결합](#string-끼리의-결합)

## 문자열 종류

Rust에서 문자열을 다루는 방법은 주로 세 가지 타입을 통해 이루어집니다: `String`, `str`, 그리고 `&str`. 이들 각각의 특성과 사용 방법, 그리고 연산에 대해 설명하겠습니다.

### `String`

- **특성**: `String`은 힙에 저장되는 가변, 소유권을 가진 문자열 타입입니다. 이는 크기가 컴파일 타임에 결정되지 않거나, 실행 중에 문자열의 내용이 변경될 수 있는 경우에 사용됩니다.
- **기반**: `String`은 `Vec<u8>`에 기반한 타입으로, UTF-8 인코딩된 바이트의 컬렉션입니다.
- **사용 예**:

    ```rust
    let mut s = String::from("hello");
    s.push_str(", world!");
    ```

### `str`

- `str`은 슬라이스 타입으로, 컴파일 타임에 크기가 결정되지 않은 문자열 데이터를 참조합니다. 보통 이 타입은 바이너리의 데이터 섹션에 직접 저장되거나, 다른 `String`이나 `str`에서 빌린 형태로 존재합니다.
- `str`은 보통 `&str` 형태로 사용되며, 이는 `str`의 안전한 참조를 나타냅니다. `&str`은 불변이기 때문에, 이를 통해 참조된 문자열 데이터를 변경할 수 없습니다.

- **특성**: `str`은 슬라이스 타입으로, 컴파일 타임에 크기가 결정되지 않은 문자열 데이터를 참조합니다. 보통 이 타입은 바이너리의 데이터 섹션에 직접 저장되거나, 다른 `String`이나 `str`에서 빌린 형태로 존재합니다.
- **사용**: `str`은 보통 `&str` 형태로 사용되며, 이는 `str`의 안전한 참조를 나타냅니다. `&str`은 불변이기 때문에, 이를 통해 참조된 문자열 데이터를 변경할 수 없습니다.
- **사용 예**:

    ```rust
    let s: &str = "Hello, world!";
    ```

### `&str`

- **특성**: `&str`은 `str` 타입의 불변 참조입니다. 이는 문자열 슬라이스라고도 하며, 문자열 데이터의 일부 또는 전체에 대한 참조를 나타냅니다.
- **일반적 사용**: `&str`은 가장 일반적으로 사용되는 문자열 타입으로, 문자열 리터럴은 모두 이 타입입니다.
- **사용 예**:

    ```rust
    let hello = "Hello, ";
    let world = "world!";
    let hello_world = format!("{}{}", hello, world);
    ```

### `CString`과 `CStr`

- **`CString`**: 널 종료 문자열(`NUL-terminated string`)을 다루기 위한 타입입니다. 이는 C 언어와의 상호 운용성(interoperability)을 위해 설계되었습니다. `CString`은 Rust 코드와 C 코드 간에 문자열을 전달할 때 사용됩니다.
- **`CStr`**: `CString`의 불변 참조 버전으로, C 스타일의 문자열을 Rust에서 안전하게 참조할 수 있게 해줍니다.

### `OsString`과 `OsStr`

- **`OsString`**: 운영 체제의 문자열 타입을 추상화한 것으로, 파일 경로나 환경 변수 등 운영 체제에 종속적인 문자열을 다룰 때 사용됩니다. 이는 내부적으로 운영 체제가 사용하는 인코딩을 그대로 유지합니다.
- **`OsStr`**: `OsString`의 불변 참조 버전으로, `OsString`을 참조하기 위해 사용됩니다.

### `PathBuf`과 `Path`

- **`PathBuf`**: 파일 시스템의 경로를 나타내는 데 사용되는 타입입니다. 내부적으로는 `OsString`을 사용하여 경로를 저장합니다.
- **`Path`**: `PathBuf`의 불변 참조 버전으로, 파일 시스템의 경로를 참조하기 위해 사용됩니다.

### `Cow<'a, str>`

- **`Cow`**: 'Copy on Write'의 약자로, 문자열 데이터를 효율적으로 복사하거나 참조할 수 있게 해주는 스마트 포인터입니다. `Cow<'a, str>`는 불변 데이터에 대한 참조(`&'a str`)와 소유한 데이터(`String`) 사이를 유연하게 전환할 수 있게 해줍니다. 이는 문자열 데이터를 수정할 필요가 있을 때만 실제로 데이터를 복사하므로, 성능 최적화에 유용하게 사용될 수 있습니다.

이러한 타입들은 Rust의 문자열 처리 능력을 확장하며, 특정 상황에서 문자열 데이터를 더 효율적이고 안전하게 다룰 수 있게 해줍니다. 각각의 타입은 그 사용 목적과 상황에 맞게 선택하여 사용되어야 합니다.

## 문자열 연산

- **`String`과 `&str`의 결합**:
    - `String`과 `&str`을 결합할 때는 `+` 연산자 또는 `format!` 매크로를 사용할 수 있습니다.
    - `+` 연산자를 사용할 때는 `String`이 첫 번째 피연산자여야 하며, 두 번째 피연산자는 `&str`이어야 합니다. 이 연산은 첫 번째 `String`을 소비하고, 새로운 `String`을 반환합니다.
    - `format!` 매크로를 사용하면, 여러 문자열을 더 유연하게 결합할 수 있습니다. 이 방법은 원본 문자열을 소비하지 않습니다.

- **`String` 끼리의 결합**:
    - `String` 타입 끼리 결합하려면, 하나를 `&str`로 참조해야 합니다. 이는 `&` 연산자와 `[]`를 사용하여 슬라이스로 변환함으로써 가능합니다.

### `+` 연산

#### `String`과 `&str`의 결합

- `String`과 `&str`을 결합할 때는 `+` 연산자 또는 `format!` 매크로를 사용할 수 있습니다.
- `+` 연산자를 사용할 때는 `String`이 첫 번째 피연산자여야 하며, 두 번째 피연산자는 `&str`이어야 합니다. 이 연산은 첫 번째 `String`을 소비하고, 새로운 `String`을 반환합니다.

```rust
let hello = "Hello, ".to_string();
let world = "world!";
let hello_world = hello + world; // `world`는 `&str` 타입이어야 함
```

- `format!` 매크로를 사용하면, 여러 문자열을 더 유연하게 결합할 수 있습니다. 이 방법은 원본 문자열을 소비하지 않습니다.

```rust
let hello = "Hello, ";
let world = "world!";
let hello_world = format!("{}{}", hello, world);
```

#### `String` 끼리의 결합

- `String` 타입 끼리 결합하려면, 하나를 `&str`로 참조해야 합니다. 이는 `&` 연산자와 `[]`를 사용하여 슬라이스로 변환함으로써 가능합니다.

```rust
let mut hello = "Hello, ".to_string();
let world = "world!".to_string();
hello += &world; // `world`를 `&str`로 참조
```
