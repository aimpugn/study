# Map

## `or_insert`와 `or_insert_with`

`or_insert`와 `or_insert_with` 메서드는 `HashMap`이나 유사한 키-값 컬렉션에서 사용된다.
주어진 키에 대응하는 값이 존재하지 않을 때만 새로운 값을 삽입한다.
두 메서드의 주요 차이점은 새 값을 삽입할 때 그 값을 생성하는 방식에 있다.

### `or_insert`

- **직접 값 지정**

    `or_insert` 메서드는 새 값을 삽입해야 할 때 사용할 값을 직접 인자로 받는다.
    이 값은 메서드가 호출될 때 이미 생성되어 있어야 한다.
    즉, 메서드 호출 시점에 값이 미리 평가(evaluate)되며, 메서드 내부에서는 이 값을 직접 삽입한다.

- **용도**

    이미 생성된 값을 삽입할 필요가 있거나, 값 생성 비용이 무시할 만큼 작은 경우에 적합하다.

### `or_insert_with`

- **지연된 값 생성**

    값이 실제로 필요한 경우(즉, 해당 키에 대응하는 값이 존재하지 않을 때) 값을 생성하기 위해 호출될 클로저를 인자로 받는다.
    이 클로저는 호출되기 전까지는 값을 생성하지 않으므로 값의 생성이 지연(lazy)된다.

- **용도**

    값 생성 비용이 높거나, 값이 실제로 필요할 때만 생성되어야 하는 경우에 적합하다.
    예를 들어, 값의 생성이 복잡한 계산을 필요로 하거나, 외부 리소스의 접근이 필요한 경우 등이 이에 해당한다.

### 예시

```rust
let mut map = std::collections::HashMap::new();

// 이미 생성된 `10`이라는 값을 직접 삽입한다.
map.entry("a").or_insert(10);

// 클로저를 받아 값의 필요성이 확인될 때(`"b"` 키가 맵에 없을 때)만 `20`이라는 값을 계산하여 삽입한다.
// 값의 생성을 지연시켜, 값이 실제로 필요한 순간에만 생성 비용을 지불하게 하므로, 불필요한 성능 저하를 방지할 수 있다.
map.entry("b").or_insert_with(|| {
    // 복잡한 계산을 통해 값을 생성
    20
});
```
