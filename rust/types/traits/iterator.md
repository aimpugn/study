# Iterator

- [Iterator](#iterator)
    - [`Peekable`](#peekable)
        - [`Peekable` 이터레이터의 특징](#peekable-이터레이터의-특징)
        - [사용 예](#사용-예)
        - [진행, 가리킴, 소비](#진행-가리킴-소비)

## `Peekable`

Rust의 표준 라이브러리에는 `Iterator` 트레잇(trait)을 확장하는 여러 유틸리티 메서드들이 포함되어 있으며, `peekable` 메서드도 그 중 하나다.
`peekable` 메서드는 기본 `Iterator`에 대해 호출될 수 있으며, 호출된 이터레이터(iterator)를 감싸는 새로운 `Peekable` 이터레이터를 반환한다.
`Peekable` 이터레이터는 기본 이터레이터의 모든 기능을 제공하면서, 추가적으로 `peek` 메서드를 통해 다음 요소를 미리 보고(pre-look) 접근할 수 있는 기능을 제공한다.

### `Peekable` 이터레이터의 특징

- **미리 보기(Pre-look) 기능**

    `Peekable` 이터레이터의 `peek` 메서드를 사용하면 다음 요소를 확인할 수 있으며, 이 요소를 실제로 소비(consume)하지 않는다.
    즉, `peek` 메서드를 호출한 후에도 이터레이터의 상태는 변경되지 않으며, 같은 요소에 대해 `next` 메서드를 호출할 수 있다.

- **상태 유지**

    `peek` 메서드는 이터레이터에서 다음 요소를 가져와 내부에 임시로 저장한다.
    이 요소는 `next` 메서드가 호출될 때까지 내부에 보관되며, `next` 호출 시에 실제로 소비되고 이터레이터는 다음 요소로 진행된다.

- **조건부 로직**

    `peek` 메서드는 반복 동안 조건부 로직을 구현할 때 유용하게 사용될 수 있다.
    예를 들어, 반복자의 다음 요소를 기반으로 특정 조건을 확인하고, 그 조건에 따라 다르게 처리하려는 경우에 `peek`을 사용할 수 있다.

### 사용 예

```rust
let mut iter = vec![1, 2, 3].into_iter().peekable();

if let Some(&&next) = iter.peek() {
    // 다음 요소를 확인하고 조건에 따라 처리
    if next % 2 == 0 {
        println!("다음 숫자는 짝수입니다.");
    } else {
        println!("다음 숫자는 홀수입니다.");
    }
}

// 실제로 다음 요소를 소비
assert_eq!(iter.next(), Some(1));
```

```rs
let xs = [1, 2, 3];

// 배열 `xs`에 대한 반복자(iterator)를 생성하고, 이 반복자를 `peekable`로 만든다.
// 이제 `iter`는 `.peek()` 메소드를 사용할 수 있다.
let mut iter = xs.iter().peekable();

// peek() lets us see into the future
// `.peek()` 메소드를 사용하여 반복자의 다음 요소를 확인한다.
// 이 경우, 반복자의 다음 요소는 `1`다. `peek()`는 요소를 참조로 반환하므로, `&1`이 된다.
// 반복자 자체가 참조이기 때문에, 실제로는 `&&1`로 표현된다. 이 호출 후에도 반복자는 진행 상태가 변경되지 않는다.
assert_eq!(iter.peek(), Some(&&1));

// `.next()` 메소드를 호출하여 반복자의 다음 요소를 실제로 소비한다. 이제 반복자는 `1`을 반환하고, 반복자는 `2`를 가리킨다.
assert_eq!(iter.next(), Some(&1));
// 다음 요소인 `2`로 진행되고 `2`를 소비한다. 이제 반복자는 `3`을 가리키고 있다.
assert_eq!(iter.next(), Some(&2));

// The iterator does not advance even if we `peek` multiple times
// `.peek()` 메소드를 두 번 호출한다고 해도, `.peek()`는 반복자를 진행시키지 않는다.
// 따라서 두 번의 `.peek()` 호출 모두 같은 값, 즉 다음 요소인 `3`을 반환한다.
assert_eq!(iter.peek(), Some(&&3));
assert_eq!(iter.peek(), Some(&&3));

// 마지막 요소인 `3`을 소비하고 이제 반복자는 더 이상 소비할 요소가 없다.
assert_eq!(iter.next(), Some(&3));

// After the iterator is finished, so is `peek()`
// 반복자에 더 이상 요소가 없으므로, `.peek()`와 `.next()` 모두 `None`을 반환한다.
assert_eq!(iter.peek(), None);
assert_eq!(iter.next(), None);
```

### 진행, 가리킴, 소비

"진행", "가리킴", 그리고 "소비한다"는 표현은 반복자와 관련된 작업을 설명할 때 사용되며, 각각 약간 다른 단계를 나타낸다.
반복자는 컬렉션(예: 벡터, 리스트 등)의 요소를 순차적으로 접근할 수 있는 방법을 제공한다.
반복자의 `next` 메서드는 반복자가 현재 가리키고 있는 요소를 반환하고, 반복자를 다음 요소로 진행시킨다.

- **`2`로 진행**

    반복자가 현재 요소(예: `1`)를 처리한 후, 다음 요소인 `2`로 "진행" 또는 "가리킴"을 의미한다.
    즉, 반복자가 다음 요소(`2`)를 가리키기 시작한다는 것을 의미한다.

- **`2`를 소비**

    반복자의 `next` 메서드가 호출될 때, 반복자가 현재 가리키고 있는 요소(`2`)를 "소비"한다.
    이는 `next` 메서드가 해당 요소를 반환하고, 반복자를 그 다음 요소(예: `3`)로 진행시킨다는 것을 의미한다.
    `next` 호출을 통해 요소가 반복자로부터 제공되고, 이후 반복자의 상태가 업데이트되어 다음 요소를 가리키게 된다는 것을 의미한다.
