# understanding ownership

## What Is Ownership?

소유권은 Rust 프로그램이 메모리를 관리하는 방법을 규정하는 일련의 규칙이다.
모든 프로그램은 실행 중 컴퓨터의 메모리를 사용하는 방식을 관리해야 한다.
일부 언어에는 프로그램이 실행되는 동안 더 이상 사용하지 않는 메모리를 정기적으로 찾는 가비지 컬렉션이 있지만,
또 다른 언어에서는 프로그래머가 명시적으로 메모리를 할당하고 해제해야 한다.
Rust는 세 번째 접근 방식을 사용한다. Rust에서 메모리는 컴파일러가 검사하는 일련의 규칙이 있는 소유권 시스템을 통해 관리된다.
규칙 중 하나라도 위반되면 프로그램이 컴파일되지 않습니다. 소유권 기능 중 어떤 것도 프로그램이 실행되는 동안 속도를 늦추지 않는다.

> The Stack and the Heap
>
> 많은 프로그래밍 언어에서는 스택과 힙에 대해 자주 생각할 필요가 없다.
> 하지만 Rust와 같은 시스템 프로그래밍 언어에서는 값이 스택 또는 힙에 있는지가 언어의 동작 방식과 어떤 결정을 내려야 하는 이유에 영향을 미친다.
> 이 장의 뒷부분에서 스택 및 힙과 관련하여 소유권의 일부를 설명할 것이므로 여기서는 이에 대비하여 간략하게 설명한다.
>
> 스택과 힙은 모두 런타임에 코드에서 사용할 수 있는 메모리의 일부이지만 구조는 서로 다르다.
> 스택은 값을 가져온 순서대로 값을 저장하고 반대 순서로 값을 제거한다. 이를 *라스트 인, 퍼스트 아웃*이라고 한다. 접시 더미를 생각해보자. 접시를 더 추가하면 더미 위에 올려놓고, 접시가 필요하면 맨 위에서 접시를 꺼내는 식이다. 중간이나 아래에서 접시를 추가하거나 제거하면 잘 작동하지 않는다!
> 데이터를 추가하는 것을 스택에 밀어 넣기(*pushing on to the stack*), 데이터를 제거하는 것을 스택에서 꺼내기(*popping off the stack*)라고 한다. **스택에 저장된 모든 데이터는 알려진 고정된 크기를 가져야** 한다. 컴파일 시 크기를 알 수 없거나 크기가 변경될 수 있는 데이터는 힙에 저장해야 한다.
>
> 힙은 덜 체계적이다(less organized). 데이터를 힙에 넣을 때 일정량의 공간을 요청한다. 메모리 할당자(memory allocator)는 힙에서 충분히 큰 빈 자리를 찾아 사용 중인 것으로 표시하고 해당 위치의 주소인 *포인터*를 반환한다.
> 이 프로세스를 힙에 할당하기(*allocating on the heap*)라고 하며 그냥 할당하기(*allocating*)라고 줄여서 부르기도 한다(**스택에 값을 추가하는 것은 할당으로 간주되지 않는다**).
> 힙에 대한 포인터는 알려진 고정된 크기이므로 스택에 포인터를 저장할 수 있지만 실제 데이터를 원할 때는 포인터를 따라가야 한다.
> 식당에 앉았다고 생각해 보자. 입장할 때 그룹에 속한 인원 수를 말하면 호스트가 모두에게 맞는 빈 테이블을 찾아서 그 자리로 안내한다.
> 그룹 중 누군가가 늦게 오면 당신이 어디을 찾기 위해 당신이 어디에 앉아 있는지 물어볼 수 있다.
>
> 스택으로 푸시하는 것이 힙에 할당하는 것보다 빠른 이유는 할당자(memory allocator)가 새 데이터를 저장할 위치를 찾을 필요가 없고 해당 위치가 항상 스택의 맨 위에 있기 때문이다.
> 이에 비해 힙에 공간을 할당하려면 할당자(memory allocator)가 먼저 데이터를 저장할 수 있는 충분한 공간을 찾은 다음 다음 할당을 준비하기 위해 부기(bookkeeping, 장부에 기록) 작업을 수행해야 하므로 더 많은 작업이 필요하다.
>
> 힙에 있는 데이터에 액세스하는 것은 포인터를 따라가야 하기 때문에 스택에 있는 데이터에 액세스하는 것보다 느리다.
> 현대의 프로세서는 메모리 내에서의 점프(이동)가 적을수록 더 빠르다.
> 비유를 이어 가자면, 여러 테이블에서 주문을 받는 레스토랑의 서버를 생각해 보자.
> 한 테이블에서 모든 주문을 받은 후 다음 테이블로 이동하는 것이 가장 효율적이다.
> A 테이블에서 주문 받은 다음 B 테이블에서 주문을 받고, 다시 A 테이블에서 주문 받은 다음 B 테이블에서 주문을 받는 것은 훨씬 느린 프로세스다.
> 마찬가지로 프로세서는 멀리 떨어져 있는 데이터(힙에 있는 데이터)보다는 다른 데이터와 가까운 데이터(스택에 있는 데이터)에서 작업할 때 더 나은 성능을 발휘할 수 있다.
>
> 코드에서 함수를 호출하면 함수에 전달된 값(힙의 데이터에 대한 포인터 포함)과 함수의 로컬 변수가 스택으로 푸시된다.
> 함수가 끝나면 해당 값은 스택에서 사라진다.
>
> 아래 사항들은 모두 소유권이 해결하는 문제들이다:
> - 힙에 있는 데이터를 어떤 코드 부분이 사용하고 있는지 추적하기
> - 힙 상의 중복 데이터 양을 최소화하기
> - 사용하지 않는 데이터를 힙에서 정리해서 공간이 부족해지지 않도록 하기
>
> 소유권을 이해하면 스택과 힙에 대해 자주 생각할 필요는 없지만, **소유권의 주된 목적이 힙 데이터를 관리하는 것**임을 알면 소유권이 왜 그렇게 작동하는지 설명하는 데 도움이 될 수 있다.

### Ownership Rules

먼저 소유권 규칙을 살펴보자. 이 규칙을 설명하는 예제를 살펴보면서 이 규칙을 염두에 두자:

- Rust의 각 값에는 소유자(*owner*)가 있다
- 한 번에 한 명의 소유자만 있을 수 있다.
- 소유자가 범위를 벗어나면 해당 값은 삭제된다(will be dropped).

### Variable Scope

이제 기본 Rust 구문을 넘어섰으므로 예제에 모든 `fn main() {` 코드를 포함하지 않으므로, 따라하는 경우 다음 예제를 메인 함수 안에 직접 넣어야 한다. 결과적으로 예제가 좀 더 간결해져서 상용구 코드가 아닌 실제 세부 사항에 집중할 수 있다.

소유권의 첫 번째 예로 몇 가지 변수의 범위(*scope*)를 살펴본다. 범위는 프로그램 내에서 항목이 유효한 범위다. 다음 변수를 예로 들어 보자:

```rs
let s = "hello";
```

변수 `s`는 문자열 리터럴을 나타내며, 문자열 값은 프로그램 텍스트에 하드코딩된다.
변수는 선언된 시점부터 현재 *범위*가 끝날 때까지 유효하다. 목록 4-1은 변수 `s`가 유효한 위치를 주석으로 표시한 프로그램을 보여준다.

```rs
    {                      // s is not valid here, it’s not yet declared
        let s = "hello";   // s is valid from this point forward

        // do stuff with s
    }                      // this scope is now over, and s is no longer valid
```

다시 말해, 여기에는 두 가지 중요한 점이 있다:

- `s`가 범위 *내에 들어오면* 유효하다.
- 범위를 *벗어날 때까지* 유효하다.

이 시점에서 범위와 변수가 유효한 시점의 관계는 다른 프로그래밍 언어의 관계와 유사하다.
이제 이러한 이해를 바탕으로 `String` 타입을 소개해 보겠다.

### The `String` Type

## references and borrowing

Rust에서 `&` 기호는 참조(reference)를 나타냅니다. 참조를 사용하는 이유는 소유권(ownership)을 이전하지 않고도 값에 접근할 수 있게 하기 위해서입니다. Rust의 핵심 개념 중 하나인 소유권 시스템은 메모리 안전성과 데이터 경쟁 조건을 방지하는 데 중요한 역할을 합니다. 이 시스템 내에서, 변수의 데이터는 단 하나의 소유자만을 가지며, 소유권은 변수 간에 이동될 수 있습니다.

`&`를 사용하여 참조를 생성하면, 데이터의 소유권을 이전하지 않고도 해당 데이터를 '빌려' 사용할 수 있습니다. 이를 통해 메모리 복사를 방지하고, 효율적인 데이터 접근을 가능하게 하면서도, 소유권 시스템의 규칙을 준수할 수 있습니다.

### 참조의 사용 예시

```rust
fn main() {
    let s = String::from("hello");

    // s의 값을 출력하는데 s의 소유권을 이전하지 않고 참조를 사용
    print_str(&s);

    // 이 지점에서도 여전히 s를 사용할 수 있음
    println!("{}", s);
}

fn print_str(s: &String) {
    println!("{}", s);
}
```

이 예제에서, `print_str` 함수는 `&String` 타입의 매개변수를 받습니다. 이는 `String` 값의 참조를 받겠다는 의미이며, 따라서 이 함수는 매개변수로 전달된 실제 `String` 값의 소유권을 갖지 않습니다. 함수 내부에서 `String` 데이터를 사용할 수 있지만, 그 데이터의 소유권을 가져오거나 수정할 수는 없습니다. 함수가 종료되어도 원본 데이터(`s`)의 소유권은 `main` 함수에 그대로 남아 있습니다.

### `&`의 중요성

- **메모리 효율성**: 참조를 사용함으로써 큰 데이터 구조를 함수에 전달할 때 메모리를 복사할 필요가 없어, 프로그램의 효율성을 높일 수 있습니다.
- **데이터 공유**: 소유권을 이전하지 않고도 여러 부분에서 데이터에 접근할 수 있게 합니다. 이는 특히 읽기 전용 데이터를 다룰 때 유용합니다.
- **소유권 규칙 준수**: Rust에서는 한 시점에 하나의 가변 참조 또는 여러 개의 불변 참조가 존재할 수 있습니다. 이 규칙은 데이터 경쟁과 같은 병렬 프로그래밍의 문제를 방지합니다.

이처럼 `&`는 Rust의 소유권 시스템에서 중요한 역할을 하며, Rust 프로그램을 작성할 때 핵심적인 부분입니다.
