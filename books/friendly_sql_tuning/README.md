# 친절한 SQL 튜닝

## 목차

1. SQL 처리 과정과 I/O
    1. SQL 파싱과 최적화
        1. 구조적, 집학적, 선언적 질의 언어
        2. SQL 최적화
        3. SQL 옵티마이저
        4. 실행계획과 비용
        5. 옵티마이저 힌트
    2. SQL 공유 및 재사용
        1. 소프트 파싱 vs. 하드 파싱
        2. 바인드 변수의 중요성
    3. 데이터 저장 구조 및 I/O 메커니즘
        1. SQL이 느린 이유
        2. 데이터베이스 저장 구조
        3. 블록 단위 I/O
        4. 시퀀셜 액세스 vs. 랜덤 액세스
        5. 논리적 I/O vs. 물리적 I/O
        6. Single Block I/O vs. Multiblock I/O
        7. Table Full Scan vs. Index Range SCan
        8. 캐시 탐색 메커니즘
2. 인덱스 기본
    1. 인덱스 구조 및 탐색
        1. 미리 보는 인덱스 튜닝
        2. 인덱스 구조
        3. 인덱스 수직적 탐색
        4. 인덱스 수평적 탐색
        5. 결합 인덱스 구조와 탐색
    2. 인덱스 기본 사용법
        1. 인덱스를 사용한다는 것
        2. 인덱스를 Range Scan 할 수 없는 이유
        3. 더 중요한 인덱스 사용 조건
        4. 인덱스를 이용한 소트 연산 생략
        5. ORDER BY 절에서 컬럼 가공
        6. SELECT-LIST에서 컬럼 가공
        7. 자동 형변환
    3. 인덱스 확장기능 사용법
        1. Index Range Scan
        2. Index Full Scan
        3. Index Unique Scan
        4. Index Skip Scan
        5. Index Fast Full Scan
        6. Index Range Scan Descending
3. 인덱스 튜닝
    1. 테이블 액세스 최소화
        1. 테이블 랜덤 액세스
        2. 인덱스 클러스터링 팩터
        3. 인덱스 손익분기점
        4. 인덱스 컬럼 추가
        5. 인덱스만 읽고 처리
        6. 인덱스 구조 테이블
        7. 클러스터 테이블
    2. 부분범위 처리 활용
        1. 부분범위 처리
        2. 부분범위 처리 구현
        3. OLTP 환경에서 부분범위 처리에 의한 성능개선 원리
    3. 인덱스 스캔 효율화
        1. 인덱스 탐색
        2. 인덱스 스캔 효율성
        3. 액세스 조건과 필터 조건
        4. 비교 연산자 종류와 컬럼 순서에 따른 군집성
        5. 인덱스 선행 컬럼이 등치(=) 조건이 아닐 때 생기는 비효율
        6. BETWEEN을 IN-List로 전환
        7. Index Skip Scan 활용
        8. IN 조건은 '='인가
        9. BETWEEN과 LIKE 스캔 범위 비교
        10. 범위검색 조건을 남용할 때 생기는 비효율
        11. 다양한 옵션 조건 처리 방식의 장단점 비교
        12. 함수호출부하 해소를 위한 인덱스 구성
    4. 인덱스 설계
        1. 인덱스 설계가 어려운 이유
        2. 가장 중요한 두 가지 선택 기준
        3. 스캔 효율성 이외의 판단 기준
        4. 공식을 초월한 전략적 설계
        5. 소트 연산을 생략하기 위한 컬럼 추가
        6. 결합 인덱스 선택도
        7. 중복 인덱스 제거
        8. 인덱스 설계도 작성
4. 조인 튜닝
    1. NL 조인
        1. 기본 메커니즘
        2. NL 조인 실행계획 제어
        3. NL 조인 수행 과정 분석
        4. NL 조인 튜닝 포인트
        5. NL 조인 특징 요약
        6. NL 조인 튜닝 실습
        7. NL 조인 확장 메커니즘
    2. 소트 머지 조인
        1. SGA vs. PGA
        2. 기본 메커니즘
        3. 소트 머지 조인이 빠른 이유
        4. 소트 머지 조인의 주용도
        5. 소트 머지 조인 제어하기
        6. 소트 머지 조인 특징 요약
    3. 해시 조인
        1. 기본 메커니즘
        2. 해시 조인이 빠른 이유
        3. 대용량 Build Input 처리
        4. 해시 조인 실행계획 제어
        5. 조인 메소드 선택 기준
    4. 서브쿼리 조인
        1. 서브쿼리 변환이 필요한 이유
        2. 서브쿼리와 조인
        3. 뷰(View)와 조인
        4. 스칼라 서브쿼리 조인
5. 소트 튜닝
    1. 소트 연산에 대한 이해
        1. 소트 수행 과정
        2. 소트 오퍼레이션
    2. 소트 발생하지 않도록 SQL 작성
        1. Union vs. Union All
        2. Exists 활용
        3. 조인 방식 변경
    3. 인덱스를 이용한 소트 연산 생략
        1. Sort Order By 생략
        2. Top N 쿼리
        3. 최소값/최대값 구하기
        4. 이력 조회
        5. Sort Group By 생략
    4. Sort Area를 적게 사용하도록 SQL 작성
        1. 소트 데이터 줄이기
        2. Top N 쿼리의 소트 부하 경감 원리
        3. Top N 쿼리가 아닐 때 발생하는 소트 부하
        4. 분석함수에서의 Top N 소트
6. DML 튜닝
    1. 기본 DML 튜닝
        1. DML 성능에 영향을 미치는 요소
        2. 데이터베이스 Call과 성능
        3. Array Processing 활용
        4. 인덱스 제약 해제를 통한 대량 DML 튜닝
        5. 수정가능 조인 뷰
        6. MERGE 문 활용
    2. Direct Path I/O 활용
        1. Direct Path I/O
        2. Direct Path Insert
        3. 병렬 DML
    3. 파티션을 활용한 DML 튜닝
        1. 테이블 파티션
        2. 인덱스 파티션
        3. 파티션을 활용한 대량 UPDATE 튜닝
        4. 파티션을 활용한 대량 DELETE 튜닝
        5. 파티션을 활용한 대량 INSERT 튜닝
    4. Lock과 트랜잭션 동시성 제어
        1. 오라클 Lock
        2. 트랜잭션 동시성 제어
        3. 채번 방식에 따른 INSERT 성능 비교
7. SQL 옵티마이저
    1. 통계정보와 비용 계산 원리
        1. 선택도와 카티널리티
        2. 통계정보
        3. 비용 계산 원리
    2. 옵티마이저에 대한 이해
        1. 옵티마이저 종류
        2. 옵티마이저 모드
        3. 옵티마이저에 영향을 미치는 요소
        4. 옵티마이저의 한계
        5. 개발자의 역할
        6. 튜닝 전문가 되는 공부방법
8. 부록: SQL 분석 도구
    1. 실행계획 확인
    2. Auto Trace
    3. SQL 트레이스
    4. DBMS_XPLAN 패키지
    5. 실시간 SQL 모니터링
    6. V$SQL

## 1장 SQL 처리 과정과 I/O

### 1.1. SQL 파싱과 최적화

#### 1.1.1. 구조적, 집학적, 선언적 질의 언어

```sql
SELECT
    E.EMPNO,
    E.ENAME,
    E.JOB,
    D.DNAME,
    D.LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
ORDER BY E.ENAME;
```

#### 1.1.2. SQL 최적화

SQL 실행 전 최적화 과정을 세분화하면 아래와 같습니다.
1. SQL 파싱
    - 파싱 트리 생성
    - syntax 체크
    - Semantic 체크
2. SQL 최적화

#### 1.1.3. SQL 옵티마이저

#### 1.1.4. 실행계획과 비용

#### 1.1.5. 옵티마이저 힌트

### 1.2. SQL 공유 및 재사용

### 1.3. 데이터 저장 구조 및 I/O 메커니즘

#### 1.3.1. SQL이 느린 이유

#### 1.3.2. 데이터베이스 저장 구조

#### 1.3.3. 블록 단위 I/O

#### 1.3.4. 시퀀셜 액세스 vs. 랜덤 액세스

#### 1.3.5. 논리적 I/O vs. 물리적 I/O

#### 1.3.6. Single Block I/O vs. Multiblock I/O

#### 1.3.7. Table Full Scan vs. Index Range SCan

#### 1.3.8. 캐시 탐색 메커니즘

## 2장 인덱스 기본

### 2.1. 인덱스 구조 및 탐색

#### 2.1.1. 미리 보는 인덱스 튜닝

#### 2.1.2. 인덱스 구조

#### 2.1.3. 인덱스 수직적 탐색

#### 2.1.4. 인덱스 수평적 탐색

#### 2.1.5. 결합 인덱스 구조와 탐색

### 2.2. 인덱스 기본 사용법

#### 2.2.1. 인덱스를 사용한다는 것

#### 2.2.2. 인덱스를 Range Scan 할 수 없는 이유

#### 2.2.3. 더 중요한 인덱스 사용 조건

#### 2.2.4. 인덱스를 이용한 소트 연산 생략

#### 2.2.5. ORDER BY 절에서 컬럼 가공

#### 2.2.6. SELECT-LIST에서 컬럼 가공

#### 2.2.7. 자동 형변환

### 2.3. 인덱스 확장기능 사용법

#### 2.3.1. Index Range Scan

#### 2.3.2. Index Full Scan

#### 2.3.3. Index Unique Scan

#### 2.3.4. Index Skip Scan

#### 2.3.5. Index Fast Full Scan

#### 2.3.6. Index Range Scan Descending

## 3장 인덱스 튜닝

### 3.1. 테이블 액세스 최소화

#### 3.1.1. 테이블 랜덤 액세스

#### 3.1.2. 인덱스 클러스터링 팩터

#### 3.1.3. 인덱스 손익분기점

#### 3.1.4. 인덱스 컬럼 추가

#### 3.1.5. 인덱스만 읽고 처리

#### 3.1.6. 인덱스 구조 테이블

#### 3.1.7. 클러스터 테이블

### 3.2. 부분범위 처리 활용

#### 3.2.1. 부분범위 처리

#### 3.2.2. 부분범위 처리 구현

#### 3.2.3. OLTP 환경에서 부분범위 처리에 의한 성능개선 원리

### 3.3. 인덱스 스캔 효율화

#### 3.3.1. 인덱스 탐색

#### 3.3.2. 인덱스 스캔 효율성

#### 3.3.3. 액세스 조건과 필터 조건

#### 3.3.4. 비교 연산자 종류와 컬럼 순서에 따른 군집성

#### 3.3.5. 인덱스 선행 컬럼이 등치(=) 조건이 아닐 때 생기는 비효율

#### 3.3.6. `BETWEEN`을 IN-List로 전환

#### 3.3.7. Index Skip Scan 활용

#### 3.3.8. `IN` 조건은 '='인가

#### 3.3.9. `BETWEEN`과 `LIKE` 스캔 범위 비교

#### 3.3.10. 범위검색 조건을 남용할 때 생기는 비효율

#### 3.3.11. 다양한 옵션 조건 처리 방식의 장단점 비교

#### 3.3.12. 함수호출부하 해소를 위한 인덱스 구성

## 5장 소트 튜닝

### 5.1. 소트 연산에 대한 이해

#### 5.1.1. 소트 수행 과정

#### 5.1.2. 소트 오퍼레이션

### 5.2. 소트 발생하지 않도록 SQL 작성

#### 5.2.1. `Union` vs. `Union All`

#### 5.2.2. `Exists` 활용

#### 5.2.3. 조인 방식 변경

### 5.3. 인덱스를 이용한 소트 연산 생략

#### 5.3.1. Sort Order By 생략

#### 5.3.2. Top N 쿼리

#### 5.3.3. 최소값/최대값 구하기

#### 5.3.4. 이력 조회

#### 5.3.5. Sort Group By 생략

### 5.4. Sort Area를 적게 사용하도록 SQL 작성

#### 5.4.1. 소트 데이터 줄이기

#### 5.4.2. Top N 쿼리의 소트 부하 경감 원리

#### 5.4.3. Top N 쿼리가 아닐 때 발생하는 소트 부하

#### 5.4.4. 분석함수에서의 Top N 소트

## 7장 SQL 옵티마이저

### 7.1. 통계정보와 비용 계산 원리

#### 7.1.1. 선택도와 카티널리티

#### 7.1.2. 통계정보

#### 7.1.3. 비용 계산 원리
