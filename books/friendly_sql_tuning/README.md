# 친절한 SQL 튜닝

- [친절한 SQL 튜닝](#친절한-sql-튜닝)
    - [목차](#목차)
    - [1장 SQL 처리 과정과 I/O](#1장-sql-처리-과정과-io)
        - [1.1. SQL 파싱과 최적화](#11-sql-파싱과-최적화)
            - [1.1.1. 구조적, 집학적, 선언적 질의 언어](#111-구조적-집학적-선언적-질의-언어)
            - [1.1.2. SQL 최적화](#112-sql-최적화)
            - [1.1.3. SQL 옵티마이저](#113-sql-옵티마이저)
            - [1.1.4. 실행계획과 비용](#114-실행계획과-비용)
            - [1.1.5. 옵티마이저 힌트](#115-옵티마이저-힌트)
        - [1.2. SQL 공유 및 재사용](#12-sql-공유-및-재사용)
            - [1.2.1. 소프트 파싱 vs. 하드 파싱](#121-소프트-파싱-vs-하드-파싱)
                - [1.2.2. 바인드 변수의 중요성](#122-바인드-변수의-중요성)
        - [1.3. 데이터 저장 구조 및 I/O 메커니즘](#13-데이터-저장-구조-및-io-메커니즘)
            - [1.3.1. SQL이 느린 이유](#131-sql이-느린-이유)
            - [1.3.2. 데이터베이스 저장 구조](#132-데이터베이스-저장-구조)
            - [1.3.3. 블록 단위 I/O](#133-블록-단위-io)
            - [1.3.4. 시퀀셜 액세스 vs. 랜덤 액세스](#134-시퀀셜-액세스-vs-랜덤-액세스)
            - [1.3.5. 논리적 I/O vs. 물리적 I/O](#135-논리적-io-vs-물리적-io)
            - [1.3.6. Single Block I/O vs. Multiblock I/O](#136-single-block-io-vs-multiblock-io)
            - [1.3.7. Table Full Scan vs. Index Range SCan](#137-table-full-scan-vs-index-range-scan)
            - [1.3.8. 캐시 탐색 메커니즘](#138-캐시-탐색-메커니즘)
    - [2장 인덱스 기본](#2장-인덱스-기본)
        - [2.1. 인덱스 구조 및 탐색](#21-인덱스-구조-및-탐색)
            - [2.1.1. 미리 보는 인덱스 튜닝](#211-미리-보는-인덱스-튜닝)
            - [2.1.2. 인덱스 구조](#212-인덱스-구조)
            - [2.1.3. 인덱스 수직적 탐색](#213-인덱스-수직적-탐색)
            - [2.1.4. 인덱스 수평적 탐색](#214-인덱스-수평적-탐색)
            - [2.1.5. 결합 인덱스 구조와 탐색](#215-결합-인덱스-구조와-탐색)
        - [2.2. 인덱스 기본 사용법](#22-인덱스-기본-사용법)
            - [2.2.1. 인덱스를 사용한다는 것](#221-인덱스를-사용한다는-것)
            - [2.2.2. 인덱스를 Range Scan 할 수 없는 이유](#222-인덱스를-range-scan-할-수-없는-이유)
            - [2.2.3. 더 중요한 인덱스 사용 조건](#223-더-중요한-인덱스-사용-조건)
            - [2.2.4. 인덱스를 이용한 소트 연산 생략](#224-인덱스를-이용한-소트-연산-생략)
            - [2.2.5. ORDER BY 절에서 컬럼 가공](#225-order-by-절에서-컬럼-가공)
            - [2.2.6. SELECT-LIST에서 컬럼 가공](#226-select-list에서-컬럼-가공)
            - [2.2.7. 자동 형변환](#227-자동-형변환)
        - [2.3. 인덱스 확장기능 사용법](#23-인덱스-확장기능-사용법)
            - [2.3.1. Index Range Scan](#231-index-range-scan)
            - [2.3.2. Index Full Scan](#232-index-full-scan)
            - [2.3.3. Index Unique Scan](#233-index-unique-scan)
            - [2.3.4. Index Skip Scan](#234-index-skip-scan)
            - [2.3.5. Index Fast Full Scan](#235-index-fast-full-scan)
            - [2.3.6. Index Range Scan Descending](#236-index-range-scan-descending)
    - [3장 인덱스 튜닝](#3장-인덱스-튜닝)
        - [3.1. 테이블 액세스 최소화](#31-테이블-액세스-최소화)
            - [3.1.1. 테이블 랜덤 액세스](#311-테이블-랜덤-액세스)
            - [3.1.2. 인덱스 클러스터링 팩터](#312-인덱스-클러스터링-팩터)
            - [3.1.3. 인덱스 손익분기점](#313-인덱스-손익분기점)
            - [3.1.4. 인덱스 컬럼 추가](#314-인덱스-컬럼-추가)
            - [3.1.5. 인덱스만 읽고 처리](#315-인덱스만-읽고-처리)
            - [3.1.6. 인덱스 구조 테이블](#316-인덱스-구조-테이블)
            - [3.1.7. 클러스터 테이블](#317-클러스터-테이블)
        - [3.2. 부분범위 처리 활용](#32-부분범위-처리-활용)
            - [3.2.1. 부분범위 처리](#321-부분범위-처리)
            - [3.2.2. 부분범위 처리 구현](#322-부분범위-처리-구현)
            - [3.2.3. OLTP 환경에서 부분범위 처리에 의한 성능개선 원리](#323-oltp-환경에서-부분범위-처리에-의한-성능개선-원리)
        - [3.3. 인덱스 스캔 효율화](#33-인덱스-스캔-효율화)
            - [3.3.1. 인덱스 탐색](#331-인덱스-탐색)
            - [3.3.2. 인덱스 스캔 효율성](#332-인덱스-스캔-효율성)
            - [3.3.3. 액세스 조건과 필터 조건](#333-액세스-조건과-필터-조건)
            - [3.3.4. 비교 연산자 종류와 컬럼 순서에 따른 군집성](#334-비교-연산자-종류와-컬럼-순서에-따른-군집성)
            - [3.3.5. 인덱스 선행 컬럼이 등치(=) 조건이 아닐 때 생기는 비효율](#335-인덱스-선행-컬럼이-등치-조건이-아닐-때-생기는-비효율)
            - [3.3.6. `BETWEEN`을 IN-List로 전환](#336-between을-in-list로-전환)
            - [3.3.7. Index Skip Scan 활용](#337-index-skip-scan-활용)
            - [3.3.8. `IN` 조건은 '='인가](#338-in-조건은-인가)
            - [3.3.9. `BETWEEN`과 `LIKE` 스캔 범위 비교](#339-between과-like-스캔-범위-비교)
            - [3.3.10. 범위검색 조건을 남용할 때 생기는 비효율](#3310-범위검색-조건을-남용할-때-생기는-비효율)
            - [3.3.11. 다양한 옵션 조건 처리 방식의 장단점 비교](#3311-다양한-옵션-조건-처리-방식의-장단점-비교)
            - [3.3.12. 함수호출부하 해소를 위한 인덱스 구성](#3312-함수호출부하-해소를-위한-인덱스-구성)
    - [5장 소트 튜닝](#5장-소트-튜닝)
        - [5.1. 소트 연산에 대한 이해](#51-소트-연산에-대한-이해)
            - [5.1.1. 소트 수행 과정](#511-소트-수행-과정)
            - [5.1.2. 소트 오퍼레이션](#512-소트-오퍼레이션)
        - [5.2. 소트 발생하지 않도록 SQL 작성](#52-소트-발생하지-않도록-sql-작성)
            - [5.2.1. `Union` vs. `Union All`](#521-union-vs-union-all)
            - [5.2.2. `Exists` 활용](#522-exists-활용)
            - [5.2.3. 조인 방식 변경](#523-조인-방식-변경)
        - [5.3. 인덱스를 이용한 소트 연산 생략](#53-인덱스를-이용한-소트-연산-생략)
            - [5.3.1. Sort Order By 생략](#531-sort-order-by-생략)
            - [5.3.2. Top N 쿼리](#532-top-n-쿼리)
            - [5.3.3. 최소값/최대값 구하기](#533-최소값최대값-구하기)
            - [5.3.4. 이력 조회](#534-이력-조회)
            - [5.3.5. Sort Group By 생략](#535-sort-group-by-생략)
        - [5.4. Sort Area를 적게 사용하도록 SQL 작성](#54-sort-area를-적게-사용하도록-sql-작성)
            - [5.4.1. 소트 데이터 줄이기](#541-소트-데이터-줄이기)
            - [5.4.2. Top N 쿼리의 소트 부하 경감 원리](#542-top-n-쿼리의-소트-부하-경감-원리)
            - [5.4.3. Top N 쿼리가 아닐 때 발생하는 소트 부하](#543-top-n-쿼리가-아닐-때-발생하는-소트-부하)
            - [5.4.4. 분석함수에서의 Top N 소트](#544-분석함수에서의-top-n-소트)
    - [7장 SQL 옵티마이저](#7장-sql-옵티마이저)
        - [7.1. 통계정보와 비용 계산 원리](#71-통계정보와-비용-계산-원리)
            - [7.1.1. 선택도와 카티널리티](#711-선택도와-카티널리티)
            - [7.1.2. 통계정보](#712-통계정보)
            - [7.1.3. 비용 계산 원리](#713-비용-계산-원리)
        - [7.2. 옵티마이저에 대한 이해](#72-옵티마이저에-대한-이해)
            - [7.2.1. 옵티마이저 종류](#721-옵티마이저-종류)
            - [7.2.2. 옵티마이저 모드](#722-옵티마이저-모드)
            - [7.2.3. 옵티마이저에 영향을 미치는 요소](#723-옵티마이저에-영향을-미치는-요소)
            - [7.2.4. 옵티마이저의 한계](#724-옵티마이저의-한계)
            - [7.2.5. 개발자의 역할](#725-개발자의-역할)
            - [7.2.6. 튜닝 전문가 되는 공부방법](#726-튜닝-전문가-되는-공부방법)

## 목차

1. SQL 처리 과정과 I/O
    1. SQL 파싱과 최적화
        1. 구조적, 집학적, 선언적 질의 언어
        2. SQL 최적화
        3. SQL 옵티마이저
        4. 실행계획과 비용
        5. 옵티마이저 힌트
    2. SQL 공유 및 재사용
        1. 소프트 파싱 vs. 하드 파싱
        2. 바인드 변수의 중요성
    3. 데이터 저장 구조 및 I/O 메커니즘
        1. SQL이 느린 이유
        2. 데이터베이스 저장 구조
        3. 블록 단위 I/O
        4. 시퀀셜 액세스 vs. 랜덤 액세스
        5. 논리적 I/O vs. 물리적 I/O
        6. Single Block I/O vs. Multiblock I/O
        7. Table Full Scan vs. Index Range SCan
        8. 캐시 탐색 메커니즘
2. 인덱스 기본
    1. 인덱스 구조 및 탐색
        1. 미리 보는 인덱스 튜닝
        2. 인덱스 구조
        3. 인덱스 수직적 탐색
        4. 인덱스 수평적 탐색
        5. 결합 인덱스 구조와 탐색
    2. 인덱스 기본 사용법
        1. 인덱스를 사용한다는 것
        2. 인덱스를 Range Scan 할 수 없는 이유
        3. 더 중요한 인덱스 사용 조건
        4. 인덱스를 이용한 소트 연산 생략
        5. ORDER BY 절에서 컬럼 가공
        6. SELECT-LIST에서 컬럼 가공
        7. 자동 형변환
    3. 인덱스 확장기능 사용법
        1. Index Range Scan
        2. Index Full Scan
        3. Index Unique Scan
        4. Index Skip Scan
        5. Index Fast Full Scan
        6. Index Range Scan Descending
3. 인덱스 튜닝
    1. 테이블 액세스 최소화
        1. 테이블 랜덤 액세스
        2. 인덱스 클러스터링 팩터
        3. 인덱스 손익분기점
        4. 인덱스 컬럼 추가
        5. 인덱스만 읽고 처리
        6. 인덱스 구조 테이블
        7. 클러스터 테이블
    2. 부분범위 처리 활용
        1. 부분범위 처리
        2. 부분범위 처리 구현
        3. OLTP 환경에서 부분범위 처리에 의한 성능개선 원리
    3. 인덱스 스캔 효율화
        1. 인덱스 탐색
        2. 인덱스 스캔 효율성
        3. 액세스 조건과 필터 조건
        4. 비교 연산자 종류와 컬럼 순서에 따른 군집성
        5. 인덱스 선행 컬럼이 등치(=) 조건이 아닐 때 생기는 비효율
        6. BETWEEN을 IN-List로 전환
        7. Index Skip Scan 활용
        8. IN 조건은 '='인가
        9. BETWEEN과 LIKE 스캔 범위 비교
        10. 범위검색 조건을 남용할 때 생기는 비효율
        11. 다양한 옵션 조건 처리 방식의 장단점 비교
        12. 함수호출부하 해소를 위한 인덱스 구성
    4. 인덱스 설계
        1. 인덱스 설계가 어려운 이유
        2. 가장 중요한 두 가지 선택 기준
        3. 스캔 효율성 이외의 판단 기준
        4. 공식을 초월한 전략적 설계
        5. 소트 연산을 생략하기 위한 컬럼 추가
        6. 결합 인덱스 선택도
        7. 중복 인덱스 제거
        8. 인덱스 설계도 작성
4. 조인 튜닝
    1. NL 조인
        1. 기본 메커니즘
        2. NL 조인 실행계획 제어
        3. NL 조인 수행 과정 분석
        4. NL 조인 튜닝 포인트
        5. NL 조인 특징 요약
        6. NL 조인 튜닝 실습
        7. NL 조인 확장 메커니즘
    2. 소트 머지 조인
        1. SGA vs. PGA
        2. 기본 메커니즘
        3. 소트 머지 조인이 빠른 이유
        4. 소트 머지 조인의 주용도
        5. 소트 머지 조인 제어하기
        6. 소트 머지 조인 특징 요약
    3. 해시 조인
        1. 기본 메커니즘
        2. 해시 조인이 빠른 이유
        3. 대용량 Build Input 처리
        4. 해시 조인 실행계획 제어
        5. 조인 메소드 선택 기준
    4. 서브쿼리 조인
        1. 서브쿼리 변환이 필요한 이유
        2. 서브쿼리와 조인
        3. 뷰(View)와 조인
        4. 스칼라 서브쿼리 조인
5. 소트 튜닝
    1. 소트 연산에 대한 이해
        1. 소트 수행 과정
        2. 소트 오퍼레이션
    2. 소트 발생하지 않도록 SQL 작성
        1. Union vs. Union All
        2. Exists 활용
        3. 조인 방식 변경
    3. 인덱스를 이용한 소트 연산 생략
        1. Sort Order By 생략
        2. Top N 쿼리
        3. 최소값/최대값 구하기
        4. 이력 조회
        5. Sort Group By 생략
    4. Sort Area를 적게 사용하도록 SQL 작성
        1. 소트 데이터 줄이기
        2. Top N 쿼리의 소트 부하 경감 원리
        3. Top N 쿼리가 아닐 때 발생하는 소트 부하
        4. 분석함수에서의 Top N 소트
6. DML 튜닝
    1. 기본 DML 튜닝
        1. DML 성능에 영향을 미치는 요소
        2. 데이터베이스 Call과 성능
        3. Array Processing 활용
        4. 인덱스 제약 해제를 통한 대량 DML 튜닝
        5. 수정가능 조인 뷰
        6. MERGE 문 활용
    2. Direct Path I/O 활용
        1. Direct Path I/O
        2. Direct Path Insert
        3. 병렬 DML
    3. 파티션을 활용한 DML 튜닝
        1. 테이블 파티션
        2. 인덱스 파티션
        3. 파티션을 활용한 대량 UPDATE 튜닝
        4. 파티션을 활용한 대량 DELETE 튜닝
        5. 파티션을 활용한 대량 INSERT 튜닝
    4. Lock과 트랜잭션 동시성 제어
        1. 오라클 Lock
        2. 트랜잭션 동시성 제어
        3. 채번 방식에 따른 INSERT 성능 비교
7. SQL 옵티마이저
    1. 통계정보와 비용 계산 원리
        1. 선택도와 카티널리티
        2. 통계정보
        3. 비용 계산 원리
    2. 옵티마이저에 대한 이해
        1. 옵티마이저 종류
        2. 옵티마이저 모드
        3. 옵티마이저에 영향을 미치는 요소
        4. 옵티마이저의 한계
        5. 개발자의 역할
        6. 튜닝 전문가 되는 공부방법
8. 부록: SQL 분석 도구
    1. 실행계획 확인
    2. Auto Trace
    3. SQL 트레이스
    4. DBMS_XPLAN 패키지
    5. 실시간 SQL 모니터링
    6. V$SQL

## 1장 SQL 처리 과정과 I/O

### 1.1. SQL 파싱과 최적화

#### 1.1.1. 구조적, 집학적, 선언적 질의 언어

```sql
SELECT
    E.EMPNO,
    E.ENAME,
    E.JOB,
    D.DNAME,
    D.LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
ORDER BY E.ENAME;
```

#### 1.1.2. SQL 최적화

SQL 실행 전 최적화 과정을 세분화하면 아래와 같습니다.
1. SQL 파싱
    - 파싱 트리 생성

        SQL 문을 이루는 개별 구성요소를 분석해서 파싱 트리를 생성합니다.

    - syntax 체크

        문법적 오류가 없는지 확인합니다.

        예를 들어, 다음과 같은 항목들을 확인합니다.
        - 사용할 수 없는 키워드를 사용했는지
        - 키워드의 순서가 바른지
        - 누락된 키워드가 있는지 등

    - Semantic 체크:

        의미상 오류가 없는지 확인합니다.

        예를 들어, 다음과 같은 항목들을 확인합니다.
        - 존재하지 않는 테이블 또는 칼럼을 사용했는지
        - 사용한 오브젝트에 대한 권한이 있는지 등

2. SQL 최적화

    [1.1.3. SQL 옵티마이저](#113-sql-옵티마이저)는 미리 수집한 시스템 및 오브젝트 통계정보를 바탕으로 다양한 실행경로를 생성해서 비교한 후 가장 효율적인 하나를 선택합니다.

3. 로우 소스 생성

    로우 소스 생성기(Row-Source Generator)는 SQL 옵티마이저가 선택한 실행경로를 실제 실행 가능한 코드 또는 프로시저 형태로 포맷팅합니다.

#### 1.1.3. SQL 옵티마이저

옵티마이저는 사용자가 원하는 작업을 가장 효율적으로 수행할 수 있는 최적의 데이터 액세스 경로를 선택해 주는 DBMS의 핵심 엔진입니다.
1. 사용자로부터 전달받은 쿼리를 수행하는 데 후보군이 될 만한 실행 계획들을 찾아냅니다.
2. 데이터 사전(Data Dictionary)에 미리 수집해 둔 오브젝트 통계 및 시스템 통계 정보를 이용해서 각 실행 계획의 예상 비용을 산정합니다.
3. 최저 비용을 나타내는 실행 계획을 선택합니다.

```plaintext
                통계 정보
                   │
            비용 기반 옵티마이저
                   │
                결정 트리
          ┌────────┼────────┐
          x        x        x
        ┌─┴─┐    ┌─┴─┐    ┌─┴─┐
비용:   73  128 [14]  64  143  173
                ^
               선택
```

> SQL 옵티마이저를 `DBWR`, `LGWR`, `PMON`, `SMON` 같은 백그라운드 프로세스로 이해하기 쉽습니다.
> 서버 프로세스가 SQL을 전달하면, 옵티마이저가 최적화해서 실행계획을 돌려준다고 생각할 수 있습니다.
> 하지만 옵티마이저는 별도 프로세스가 아니라, 서버 프로세스가 가진 기능일 뿐입니다.
> 이는 SQL 파서와 로우 소스 생성기도 마찬가지입니다.

#### 1.1.4. 실행계획과 비용

DBMS에는 SQL 실행경로를 미리 볼 수 있는 실행 계획(Execution Plan)이 있습니다.
옵티마이저가 생성한 처리 절차를 사용자가 트리 구조로 확인할 수 있습니다.

```sql
CREATE TABLE IF NOT EXISTS T
AS
SELECT d.no, e.*
FROM emp e, (SELECT rownum no FROM dual connect by level <= 1000) d;

-- MySQL
CREATE TABLE IF NOT EXISTS T
AS
-- MySQL에는 ROWNUM 같은 의사(가상) 컬럼이 없으므로,
-- 재귀 CTE(Common Table Expression)를 이용해 1,2,3 ... 일련번호를 생성합니다.
WITH RECURSIVE seq AS (
  SELECT 1 AS n
  UNION ALL
  SELECT n + 1 FROM seq WHERE n < 1000
)
SELECT seq.n AS no, e.*
FROM emp AS e
JOIN seq ON TRUE;   -- CROSS JOIN 과 동일

CREATE INDEX t_x01 ON t(deptno, no);
CREATE INDEX t_x02 ON t(deptno, job, no);

EXEC dbms_stats.gather_table_stats(user, 't');

-- MySQL 경우 통계 수집을 명시적으로 호출하는 함수가 없습니다.
-- 대신 자동으로 수집하거나, 수동 트리거를 실행합니다.
-- `ANALYZE TABLE`을 실행하면 InnoDB는 해당 테이블의 인덱스를 샘플링해 카디널리티를 다시 계산합니다.
-- 그리고 결과를 `mysql.innodb_index_stats`, `mysql.innodb_table_stats` 등의 시스템 테이블에 반영합니다.
-- Ref:
-- - https://dev.mysql.com/doc/refman/8.4/en/analyze-table.html
ANALYZE TABLE t;
-- +------------+---------+----------+----------+
-- | Table      | Op      | Msg_type | Msg_text |
-- +------------+---------+----------+----------+
-- | friendly.t | analyze | status   | OK       |
-- +------------+---------+----------+----------+
-- 1 row in set (0.04 sec)

-- SET AUTOTRACE: 모든 SQL 문에 대해 '실행 계획(Explain Plan)'과 '실행 통계'를 자동으로 보여 달라는 지시입니다.
-- TRACEONLY: 질의 결과 집합은 출력하지 말라는 뜻입니다.
-- EXP: 통계는 빼고, '실행 계획'만 보여 달라는 선택지입니다.
SET autotrace traceonly exp;

-- MySQL 클라이언트에는 `SET AUTOTRACE` 같은 세션 전역 스위치가 없습니다.
-- 대신 필요할 때마다 `EXPLAIN` 또는 `EXPLAIN ANALYZE`를 사용합니다.

EXPLAIN SELECT * FROM T WHERE DEPTNO = 10 AND NO = 1;
-- +----+-------------+-------+------------+------+---------------+-------+---------+-------------+------+----------+-------+
-- | id | select_type | table | partitions | type | possible_keys | key   | key_len | ref         | rows | filtered | Extra |
-- +----+-------------+-------+------------+------+---------------+-------+---------+-------------+------+----------+-------+
-- |  1 | SIMPLE      | T     | NULL       | ref  | t_x01,t_x02   | t_x01 | 11      | const,const |    3 |   100.00 | NULL  |
-- +----+-------------+-------+------------+------+---------------+-------+---------+-------------+------+----------+-------+
-- 1 row in set, 1 warning (0.04 sec)

EXPLAIN ANALYZE SELECT * FROM T WHERE DEPTNO = 10 AND NO = 1;
-- +-----------------------------------------------------------------------------------------------------------------------+
-- | EXPLAIN                                                                                                               |
-- +-----------------------------------------------------------------------------------------------------------------------+
-- | -> Index lookup on T using t_x01 (DEPTNO = 10, no = 1)  (cost=1.05 rows=3) (actual time=0.175..0.256 rows=3 loops=1)
-- |
-- +-----------------------------------------------------------------------------------------------------------------------+
-- 1 row in set (0.01 sec)

EXPLAIN ANALYZE SELECT /*+ INDEX(T T_X02) */ * FROM T WHERE DEPTNO = 10 AND NO = 1;
-- +------------------------------------------------------------------------------------------------------------------------------------------------------+
-- | EXPLAIN                                                                                                                                              |
-- +--------------------------------------------------------------------------------- --------------------------------------------------------------------+
-- | -> Index lookup on T using t_x02 (DEPTNO = 10), with index condition: (t.`no` = 1)  (cost=112 rows=3964) (actual time=0.896..1.57 rows=3 loops=1)
-- |
-- +------------------------------------------------------------------------------------------------------------------------------------------------------+

EXPLAIN ANALYZE SELECT /*+ NO_INDEX(T) */ * FROM T WHERE DEPTNO = 10 AND NO = 1;
-- +---------------------------------------------------------------------------------------------------------------------------+
-- | EXPLAIN                                                                                                                   |
-- +---------------------------------------------------------------------------------------------------------------------------+
-- | -> Filter: ((t.`no` = 1) and (t.DEPTNO = 10))  (cost=1214 rows=396) (actual time=4.2..8.07 rows=3 loops=1)
-- |   -> Table scan on T  (cost=1214 rows=11894) (actual time=0.289..7.3 rows=12000 loops=1)
-- |
-- +---------------------------------------------------------------------------------------------------------------------------+
```

> actual time가 여러 번 나오는 이유?
>
> 이 시간은 그 노드가 "직접 수행한 시간 + 하위 노드에서 전달된 결과를 기다린 시간"을 포함합니다.
>
> 즉, “루트 노드 13.3ms, 중간 노드 13.3ms, 리프 노드 12.6ms”라고 되어 있다면,
> 루트가 13.3ms 동안 실행되는 동안 중간과 리프도 함께 포함돼 있다는 뜻입니다.
>
> 그래서 각 actual time 은 누적되거나 직렬화되지 않습니다.
> 서로 “포함관계”일 뿐 “추가적인 소요 시간”이 아닙니다.

각 인덱스별 비용을 보면 다음과 같습니다.
- `T_X01` 경우 cost: 1.05
- `T_X02` 경우 cost: 112
- Full scan 경우 cost: 1214

위 실행 계획을 보면 `t_x01` 인덱스를 선택하는 것이 가장 적게 비용이 듭니다.
이 비용(Cost)은 쿼리를 수행하는 동안 발생할 것으로 예상하는 I/O 횟수 또는 예상 소요 시간을 표현한 값입니다.

`EXPLAIN ANALYZE`와 달리 `EXPLAIN`으로 볼 수 있는 실행계획에 표시되는 비용은 *예상치*로, 실행경로를 선택하기 위해 옵티마이저가 여러 통계정보를 활용해서 계산한 값입니다.
실측치가 아니므로 실제 수행할 때 발생하는 I/O 또는 시간과 많은 차이가 날 수 있습니다.

#### 1.1.5. 옵티마이저 힌트

SQL 옵티마이저는 대부분 좋은 선택을 하지만, 완벽한 것은 아닙니다.
SQL이 복잡할수록 실수할 가능성도 높아집니다.
이는 [7.2.4. 옵티마이저의 한계](#724-옵티마이저의-한계)에서 좀 더 자세하게 설명합니다.

통계정보에 담을 수 없는 데이터 또는 업무 특성을 활용해 개발자가 직접 더 효율적인 액세스 경로를 찾아낼 수도 있습니다. 이럴 때 옵티마이저 힌트를 이용해 데이터 액세스 경로를 바꿀 수 있습니다.

[옵티마이저 힌트](https://dev.mysql.com/doc/refman/8.4/en/optimizer-hints.html)는 `/*+ ... */` 문법으로 사용할 수 있습니다.

자주 사용하는 힌트 목록:
- 최적화 목표
    - ALL_ROWS: 전체 처리속도 최적화
    - FIRST_ROWS(N): 최초 N건 응답속도 최적화
- 액세스 방식
    - FULL: Table Full Scan 유도
    - INDEX: Index Scan 유도
    - INDEX_DESC: Index를 역순으로 스캔하도록 유도
    - INDEX_FFS: Index Fast Full Scan으로 유도
    - INDEX_SS: Index Skip Scan으로 유도
- 조인 순서
    - ORDERED: FROM 절에 나열된 순서대로 조인
    - LEADING: LEADING 힌트 괄호에 기술한 순서대로 조인(e.g. `LEADING(T1 T2)`)
    - SWAP_JOIN_INPUTS: 해시 조인 시, `BUILD INPUT`을 명시적으로 선택.(e.g. `SWAP_JOIN_INPUTS(T1)`)
- 조인 방식
    - USE_NL: NL 조인으로 유도
    - USE_MERGE: 소트 머지 조인으로 유도
    - USE_HASH: 해시 조인으로 유도
    - NL_SJ: NL 세미조인으로 유도
    - MERGE_SJ: 소트 머지 세미조인으로 유도
    - HASH_SJ: 해시 세미조인으로 유도
- 서브쿼리 팩토링
    - MATERIALIZE: `WITH` 문으로 정의한 집합을 물리적으로 생성하도록 유도.(e.g. `WITH /*+ MATERIALIZE */ T AS (SELECT ...)`)
    - INLINE: `WITH` 문으로 정의한 집합을 물리적으로 생성하지 않고 `INLINE` 처리하도록 유도. (e.g. `WITH /*+ INLINE */ T AS (SELECT ...)`)
- 쿼리 변환
    - MERGE: 뷰 머징 유도
    - NO_MERGE: 뷰 머징 방지
    - UNNEST: 서브쿼리 Unnesting 유도
    - NO_UNNEST: 서브쿼리 Unnesting 방지
    - PUSH_PRED: 조인 조건 Pushdown 유도
    - NO_PUSH_PRED: 조인 조건 Pushdown 방지
    - USE_CONCAT: OR 또는 IN-List 조건을 OR-Expansion으로 유도
    - NO_EXPAND: OR 또는 IN-List 조건에 대한 OR-Expansion 방지
- 병렬 처리
    - PARALLEL: 테이블 스캔 또는 DML을 병렬 방식으로 처리하도록 유도. (e.g. `PARALLEL(T1 2) PARALLEL(T2 2)`)
    - PARALLEL_INDEX: 인덱스 스캔을 병렬 방식으로 처리하도록 유도
    - PQ_DISTRIBUTE: 병렬 수행 시 데이터 분배 방식 결정. (e.g. `PQ_DISTRIBUTE(T1 HASH HASH)`)
- 기타
    - APPEND: Direct-Path Insert 유도
    - DRIVING_SITE: DB Link Remote 쿼리에 대한 최적화 및 실행 주체 지정(Local 또는 Remote)
    - PUSH_SUBQ: 서브쿼리를 가급적 빨리 필터링하도록 유도
    - NO_PUSH_SUBQ: 서브쿼리를 가급적 늦게 필터링하도록 유도

### 1.2. SQL 공유 및 재사용

#### 1.2.1. 소프트 파싱 vs. 하드 파싱

SQL 파싱, 최적화, 로우 소스 생성 과정을 거쳐 생성한 내부 프로시저를 반복 재사용할 수 있도록 캐싱해 두는 메모리 공간을 '라이브러리 캐시'(Library Cache)라고 합니다.

라이브러리 캐시는 SGA(System Global Area)의 구성요소입니다.
SGA(System Global Area)는 서버 프로세스와 백그라운드 프로세스가 공통적으로 액세스하는 데이터와 제어 구조를 캐싱하는 메모리 공간입니다.

[SGA](./resources/oracle_sga.jpg)

사용자가 SQL 문을 전달하면, DBMS는 SQL을 파싱한 후 해당 SQL이 라이브러리 캐시에 존재하는지부터 확인합니다.
- 캐시에서 찾으면
    - 곧바로 실행 단계로 진행 -> 소프트 파싱
- 캐시에서 찾지 못하면
    - 최적화 및 로우 소스 생성 단계 -> 하드 파싱

##### 1.2.2. 바인드 변수의 중요성

사용자 정의 함수/프로시저, 트리거, 패키지 등은 생성할 때부터 이름을 갖습니다.
컴파일한 상태로 딕셔너리에 저장되며, 사용자가 삭제하지 않는 한 영구적으로 보관되어 여러 사용자가 공유하면서 재사용할 수 있습니다.

반면 SQL은 이름이 따로 없고 전체 SQL 텍스트가 이름 역할을 합니다.
딕셔너리에 저장하지도 않습니다.
처음 실행할 때 최적화 과정을 거쳐 동적으로 생성한 내부 프로시저를 라이브러리 캐시에 적재함으로써 여러 사용자가 공유하면서 재사용합니다.
캐시 공간이 부족하면 버려졌다가 다음에 다시 실해할 때 똑같은 최적화 과정을 거쳐 캐시에 적재됩니다.

```java
public void login(String loginId) throws Exception {
    var sqlStmt = "SELECT * FROM CUSTOMER WHERE LOGIN_ID = '" + loginId + "'";
    var stmt = conn.createStatement();
    var rs = stmt.executeQuery(sqlStmt);
    if(rs.next()) {
        // do anything
    }
    rs.close();
    stmt.close();
}
```

만약 로그인 시 위와 같은 코드가 실행된다고 가정해 봅니다.
12시 정각부터 30분간 할인 이벤트를 진행해서, 500만명 중 20%에 해당하는 100만 고객이 당일 12시 전후로 시스템을 접속할 경우 어떻게 될까?

DBMS에서 발생하는 부하는 대개 과도한 I/O가 원인입니다.
하지만 이 날은 I/O가 거의 발생하지 않음에도 CPU 사용률이 급격히 올라가고, 라이브러리 캐시에서 발생하는 여러 종류의 경합 때문에 로그인이 제대로 처리되지 않을 겁니다.
각 고객에 대해 *동시다발적으로 발생하는 SQL 하드파싱* 때문입니다.

그 순간 라이브러리 캐시(`V$SQL`)를 조회해 보면, 다음과 같은 SQL로 가득 차 있을 거라고 합니다.

```log
SELECT * FROM CUSTOMER WHERE LOGIN_ID = 'oraking'
SELECT * FROM CUSTOMER WHERE LOGIN_ID = 'javaking'
SELECT * FROM CUSTOMER WHERE LOGIN_ID = 'tommy'
SELECT * FROM CUSTOMER WHERE LOGIN_ID = 'karajan'
... 생략 ...
```

위와 같이 로그인 프로그램을 작성하면, 고객이 로그인할 때마다 아래와 같이 DBMS 내부 프로시저를 하나씩 만들어서 라이브러리 캐시에 적재하는 것과 같습니다.

> 내부 프로시저 생성은 SQL 옵티마이저와 로우 소스 생성기가 담당합니다.

```sql
CREATE PROCEDURE LOGIN_ORAKING() { ... }
CREATE PROCEDURE LOGIN_JAVAKING() { ... }
CREATE PROCEDURE LOGIN_TOMMY() { ... }
CREATE PROCEDURE LOGIN_KARAJAN() { ... }
... 생략 ...
```

내부 처리 루틴은 모두 같으므로 프로시저를 여러 개 생성하는 대신 로그인 ID를 파라미터로 받는 프로시저 하나를 공유하면서 재사용하는 것이 좋을 겁니다.

```sql
CREATE PROCEDURE LOGIN (login_id in VARCHAR2) { ... }
```

이렇게 파라미터 Driven 방식으로 SQL을 작성하는 방법을 '바인드 변수'라고 합니다.

```diff
public void login(String loginId) throws Exception {
-    var sqlStmt = "SELECT * FROM CUSTOMER WHERE LOGIN_ID = '" + loginId + "'";
-    var stmt = conn.createStatement();
+    var sqlStmt = "SELECT * FROM CUSTOMER WHERE LOGIN_ID = ?";
+    var stmt = conn.prepareStatement(sqlStmt);
```

### 1.3. 데이터 저장 구조 및 I/O 메커니즘

#### 1.3.1. SQL이 느린 이유

SQL이 느린 이유는 십중팔구 I/O, 좀 더 구체적으로는 디스크 I/O 때문일 것이라고 합니다.

I/O란 무엇일까? 책의 저자는 "I/O = 잠(sleep)"이라고 설명합니다.
OS 또는 I/O 서브 시스템이 I/O를 처리하는 동안 프로세스는 잠을 자기 때문입니다.

프로세스는 '실행 중인 프로그램'이며, `new`, `read`, `running`, `waiting`, `terminated` 등의 생명 주기를 갖습니다.

[process_lifecycle](./resources/process_lifecycle.jpeg)

#### 1.3.2. 데이터베이스 저장 구조

#### 1.3.3. 블록 단위 I/O

#### 1.3.4. 시퀀셜 액세스 vs. 랜덤 액세스

#### 1.3.5. 논리적 I/O vs. 물리적 I/O

#### 1.3.6. Single Block I/O vs. Multiblock I/O

#### 1.3.7. Table Full Scan vs. Index Range SCan

#### 1.3.8. 캐시 탐색 메커니즘

## 2장 인덱스 기본

### 2.1. 인덱스 구조 및 탐색

#### 2.1.1. 미리 보는 인덱스 튜닝

#### 2.1.2. 인덱스 구조

#### 2.1.3. 인덱스 수직적 탐색

#### 2.1.4. 인덱스 수평적 탐색

#### 2.1.5. 결합 인덱스 구조와 탐색

### 2.2. 인덱스 기본 사용법

#### 2.2.1. 인덱스를 사용한다는 것

#### 2.2.2. 인덱스를 Range Scan 할 수 없는 이유

#### 2.2.3. 더 중요한 인덱스 사용 조건

#### 2.2.4. 인덱스를 이용한 소트 연산 생략

#### 2.2.5. ORDER BY 절에서 컬럼 가공

#### 2.2.6. SELECT-LIST에서 컬럼 가공

#### 2.2.7. 자동 형변환

### 2.3. 인덱스 확장기능 사용법

#### 2.3.1. Index Range Scan

#### 2.3.2. Index Full Scan

#### 2.3.3. Index Unique Scan

#### 2.3.4. Index Skip Scan

#### 2.3.5. Index Fast Full Scan

#### 2.3.6. Index Range Scan Descending

## 3장 인덱스 튜닝

### 3.1. 테이블 액세스 최소화

#### 3.1.1. 테이블 랜덤 액세스

#### 3.1.2. 인덱스 클러스터링 팩터

#### 3.1.3. 인덱스 손익분기점

#### 3.1.4. 인덱스 컬럼 추가

#### 3.1.5. 인덱스만 읽고 처리

#### 3.1.6. 인덱스 구조 테이블

#### 3.1.7. 클러스터 테이블

### 3.2. 부분범위 처리 활용

#### 3.2.1. 부분범위 처리

#### 3.2.2. 부분범위 처리 구현

#### 3.2.3. OLTP 환경에서 부분범위 처리에 의한 성능개선 원리

### 3.3. 인덱스 스캔 효율화

#### 3.3.1. 인덱스 탐색

#### 3.3.2. 인덱스 스캔 효율성

#### 3.3.3. 액세스 조건과 필터 조건

#### 3.3.4. 비교 연산자 종류와 컬럼 순서에 따른 군집성

#### 3.3.5. 인덱스 선행 컬럼이 등치(=) 조건이 아닐 때 생기는 비효율

#### 3.3.6. `BETWEEN`을 IN-List로 전환

#### 3.3.7. Index Skip Scan 활용

#### 3.3.8. `IN` 조건은 '='인가

#### 3.3.9. `BETWEEN`과 `LIKE` 스캔 범위 비교

#### 3.3.10. 범위검색 조건을 남용할 때 생기는 비효율

#### 3.3.11. 다양한 옵션 조건 처리 방식의 장단점 비교

#### 3.3.12. 함수호출부하 해소를 위한 인덱스 구성

## 5장 소트 튜닝

### 5.1. 소트 연산에 대한 이해

#### 5.1.1. 소트 수행 과정

#### 5.1.2. 소트 오퍼레이션

### 5.2. 소트 발생하지 않도록 SQL 작성

#### 5.2.1. `Union` vs. `Union All`

#### 5.2.2. `Exists` 활용

#### 5.2.3. 조인 방식 변경

### 5.3. 인덱스를 이용한 소트 연산 생략

#### 5.3.1. Sort Order By 생략

#### 5.3.2. Top N 쿼리

#### 5.3.3. 최소값/최대값 구하기

#### 5.3.4. 이력 조회

#### 5.3.5. Sort Group By 생략

### 5.4. Sort Area를 적게 사용하도록 SQL 작성

#### 5.4.1. 소트 데이터 줄이기

#### 5.4.2. Top N 쿼리의 소트 부하 경감 원리

#### 5.4.3. Top N 쿼리가 아닐 때 발생하는 소트 부하

#### 5.4.4. 분석함수에서의 Top N 소트

## 7장 SQL 옵티마이저

### 7.1. 통계정보와 비용 계산 원리

#### 7.1.1. 선택도와 카티널리티

#### 7.1.2. 통계정보

#### 7.1.3. 비용 계산 원리

### 7.2. 옵티마이저에 대한 이해

#### 7.2.1. 옵티마이저 종류

#### 7.2.2. 옵티마이저 모드

#### 7.2.3. 옵티마이저에 영향을 미치는 요소

#### 7.2.4. 옵티마이저의 한계

#### 7.2.5. 개발자의 역할

#### 7.2.6. 튜닝 전문가 되는 공부방법
