# variables

- [variables](#variables)
    - [변수 재사용](#변수-재사용)
        - [PHP 내부적인 차이점 및 영향](#php-내부적인-차이점-및-영향)
        - [베스트 프랙티스](#베스트-프랙티스)

## 변수 재사용

Guzzle http client 사용할 때 이런 코드들이 있습니다.

```php
$aResponse = $client->post($domain . self::PATH_A...
// $aResponse status 검증, contents 꺼내기

$bResponse = $client->post($domain . self::PATH_B... 
// $bResponse status 검증, contents 꺼내기
```

$aResponse, $bResponse 변수에 각각 결과를 따로 저장하는데,

```php
$response = $client->post($domain . self::PATH_A...
// $response status 검증, contents 꺼내기

$response = $client->post($domain . self::PATH_B... 
// $response status 검증, contents 꺼내기
```

이렇게 응답 결과를 담는 변수를 재사용하는 경우도 있습니다.

### PHP 내부적인 차이점 및 영향

PHP 내부적으로는 다음과 같은 차이점 및 영향이 있습니다.

1. **메모리 사용:**

   - **별도 변수 사용시**:

        각각의 변수 (`$aResponse`, `$bResponse`)는 각자 독립적으로 메모리를 할당받아 HTTP 응답 데이터를 저장합니다.
        이는 메모리를 더 많이 사용하게 되지만, 각 변수에 별도의 응답 데이터를 명확하게 저장할 수 있습니다.

        PHP의 가비지 컬렉터는 이 변수들을 독립적으로 관리합니다.
        각 변수가 스코프를 벗어날 때, 해당 변수가 사용하던 메모리는 개별적으로 해제됩니다.

        이는 메모리 사용량을 약간 증가시킬 수 있습니다.
        하지만 최신 PHP 엔진(PHP 7 이상)은 이러한 시나리오를 최적화하여 처리하므로 메모리 사용량의 차이는 일반적으로 미미합니다.

        ```php
        $aResponse = $client->post($domain . self::PATH_A...
        // 처리 로직
        $bResponse = $client->post($domain . self::PATH_B...
        // 처리 로직
        ```

        이 경우, 두 개의 별도 변수가 생성되어 각각 메모리를 차지합니다.
        두 응답 모두 스코프 내에서 유지되므로, 가비지 컬렉션이 즉시 발생하지 않을 수 있습니다.

   - **변수 덮어쓰기시**:

        단 하나의 변수 (`$response`)만 사용되고, 새로운 HTTP 응답이 있을 때마다 이 변수가 덮어쓰여집니다.
        이는 메모리를 효율적으로 사용할 수 있게 해줍니다.

        변수가 덮어쓰여질 때 이전 데이터는 참조가 해제되어 가비지 컬렉션 대상이 됩니다.
        덕분에 이전 응답의 메모리가 더 빨리 회수될 수 있습니다.
        이는 응답이 클 경우 메모리를 약간 더 효율적으로 사용할 수 있습니다.

        PHP에서 변수를 재사용하는 두 번째 방식은 일반적으로 메모리 사용 측면에서 약간 더 효율적입니다. 이는 다음과 같은 이유 때문입니다:

        ```php
        $response = $client->post($domain . self::PATH_A...
        // 처리 로직
        $response = $client->post($domain . self::PATH_B...
        // 처리 로직
        ```

        이 경우, `$response` 변수는 재사용됩니다.
        첫 번째 요청의 응답 데이터가 더 이상 필요하지 않다고 가정하면, 두 번째 할당 시 이전 데이터는 가비지 컬렉션의 대상이 되어 메모리에서 해제될 수 있습니다.

2. **가독성 및 유지보수성:**

   - **별도 변수 사용시**:

        이 접근 방식은 가독성과 유지보수성이 향상됩니다.
        두 개의 명확하게 구분된 응답이 처리되고 있다는 것을 쉽게 알 수 있습니다.
        미래의 개발자나 본인이 코드를 다시 봤을 때 흐름과 각 응답의 목적을 쉽게 이해할 수 있습니다.

   - **변수 덮어쓰기시**:

        이 접근 방식은 코드의 가독성과 유지보수성을 저하시킬 수 있습니다.
        두 개의 별도 요청이 있다는 것을 즉시 알기 어렵기 때문입니다.
        이는 특히 복잡한 코드베이스에서 혼란을 야기할 수 있습니다.

3. **변수의 스코프와 생명주기:**

   - **별도 변수 사용시**:

        각 응답의 생명주기를 개별적으로 관리할 수 있습니다.
        이는 나중에 두 응답을 비교하거나 독립적으로 처리해야 할 경우 유용합니다.

   - **변수 덮어쓰기시**:

        두 번째 요청이 첫 번째 응답을 덮어쓰므로 첫 번째 응답에 더 이상 접근할 수 없습니다.
        이는 첫 번째 응답이 두 번째 요청 후 더 이상 필요하지 않을 때에만 적합합니다.

4. **에러 처리:**

   - **별도 변수 사용시**:

        각 응답에 대해 독립적으로 에러 처리를 구현하기가 더 쉽습니다.
        `$aResponse`와 `$bResponse`에 대해 상태를 확인하고 에러를 처리할 수 있습니다.

   - **변수 덮어쓰기시**:

        에러 처리가 더 복잡해지고 덜 명확해질 수 있습니다.
        동일한 변수를 두 응답에 사용하기 때문에 `$response`의 스코프나 컨텍스트를 잘못 이해하면 논리적 에러가 발생할 수 있습니다.

### 베스트 프랙티스

1. **설명적인 변수명 사용:**

    각 응답의 목적을 설명하는 이름을 사용하세요.

    예를 들어, `$userDetailsResponse`와 `$orderDetailsResponse`와 같이 `$aResponse`와 `$bResponse` 대신 사용합니다.

2. **응답을 독립적으로 처리:**

    응답을 별도의 변수에 저장하는 것이 가독성과 유지보수성에 유리합니다.
    이 접근 방식은 코드 자체에서 문서화하는 효과가 있어 이해하기 쉽습니다.

3. **메모리 고려:**

    메모리 효율성은 중요하지만, 현대 PHP의 메모리 관리 및 가비지 컬렉션 기능 덕분에 대부분의 경우 차이는 미미합니다.
    가독성과 유지보수성을 우선시하는 것이 좋습니다. 응답이 매우 크거나 제한된 환경이 아닌 이상, 별도 변수 사용을 권장합니다.
