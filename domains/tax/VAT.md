# 부가가치세

- [부가가치세](#부가가치세)
    - [`VAT`?](#vat)
    - [유형](#유형)
        - [GNP(총생산)형](#gnp총생산형)
        - [소득형](#소득형)
        - [소비형(우리나라의 부가가치세)](#소비형우리나라의-부가가치세)
    - [계산방식](#계산방식)
        - [가산법](#가산법)
        - [전단계 거래액공제법](#전단계-거래액공제법)
        - [전단계 세액공제법](#전단계-세액공제법)
    - [영세율](#영세율)
    - [일반적인 부가세율 10%를 계산할 때 11로 나누기](#일반적인-부가세율-10를-계산할-때-11로-나누기)

## `VAT`?

- **V**alue **A**dded **T**ax
- `모든 거래 단계에서 창출되는 부가가치`가 과세대상인 **간접** 국세
    - 부가가치?
        - 생산 또는 유통 단계에 있는 사업자가
        - 생산활동 또는 유통과정을 통해
        - **독자적으로 새로이 창출한 가치의 증가** 금액
    - 간접세?
        - 납세의무자(사업자)와 담세자(최종소비자) 구분
        - 사업자가 부가가치세를 납부하고 그만큼 가격에 반영되어 최종소비자가 담세자가 된다

## 유형

### GNP(총생산)형

- 총산출액 - 중간생산재 = 임금 + 임차료 + 이자 + 이윤 + 감가상각비

### 소득형

- 총산출액 - 중간생산재 - 감가상각비 = 임금 + 임차료 + 이자 + 이윤

### 소비형(우리나라의 부가가치세)

- 총산출액 - 중간생산재 - 자본재구입액 = 임금 + 임차료 + 이자 + 이윤 - 순투자
    - 중간재와 자본재 구분 필요없이 매입총액을 매출액에서 공제

## 계산방식

### 가산법

### 전단계 거래액공제법

### 전단계 세액공제법

## 영세율

- [국가법령정보시스템 → 영세율](https://txsi.hometax.go.kr/docs_new/customer/dictionary/wordList.jsp):
    - 세율이 0인 경우로 **과세표준의 크기 관계없이 산출한 세액은 항상 0**
        - `세율`? 세액을 산출하기 위해 `과세표준에 곱하는 비율`([종가세](https://txsi.hometax.go.kr/docs_new/customer/dictionary/view.jsp?word=%EC%A2%85%EA%B0%80%EC%84%B8&word_id=1355) 경우) 또는 `과세표준의 단위당 금액`(종량세 경우)
            - `종가세`? 과세물건의 가격에 대해 부과하는 조세
            - `종량세`? 물품의 수량, 길이, 면적, 중량 등을 과세표준으로 하는 조세
    - 영세율이 적용되는 재화 또는 용역에 대해 부가가치세가 완전 면세
    - 대상
        - 주로 소비지국과세원칙에 따라 국외에서 사용·소비될 재화 또는 용역
        - 국내에서 사용·소비되는 재화 또는 용역의 공급이라 하더라도 외화를 획득하는 것인 경우
        - 증권거래세법상에서는 탄력세제를 선택하여 대통령령이 정하는 경우
- [영세율과 면세의 차이 제대로 알아보기](https://help.jobis.co/hc/ko/articles/360000466581--%EC%98%81%EC%84%B8%EC%9C%A8%EA%B3%BC-%EB%A9%B4%EC%84%B8%EC%9D%98-%EC%B0%A8%EC%9D%B4-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0)
    - 부가가치세 매**출**세액이 0% 적용 → 매**출** 세액만 0이 되고 매**입** 세액은 환급
    - 매입세액 환급 비교
        - 과세공급가액 + 부가세 = 전액

    |  | 과세사업자 | 영세율사업자 | 면세사업자 | 비고 |
    | --- | --- | --- | --- | --- |
    | 매입 | 100 | 100 | 100 |  |
    | 매입세액 | 10 | 10 | 10 |  |
    | 매출 | 120 | 120 | 120 |  |
    | 매출세액 | 12(=120 *10%) | 0(=120* 0%) | 0 |  |
    | 납부 | 2 | 0 | 0 |  |
    | 환급 | 0 | 10 | 0 |  |
    | 판매금액 | 120 + 12 | 120 | 120 + 10 | 매입세액 10을 최종소비자에게 전가 |

```php
// 나이스 신모듈의 부분취소시 부가세 계산방식. 문서화되어있지 않다.
// 아래 수식에서의 round는 round half up 방식의 반올림을 사용하고있음 (이른바 사사오입)

accumCancelAmount = "기존 누적 취소금액" // 기존 데이터로 계산해야함
accumCancelTaxFreeAmount = "기존 누적 취소금액 중 면세액" // 기존 데이터로 계산해야함
accumCancelTaxedAmount = "기존 누적 취소금액 중 과세액" = accumCancelAmount - accumCancelTaxFreeAmount
accumCancelVATAmount = "기존 누적 취소금액 중 부가가치세" = round(accumCancelTaxedAmount / 11)

newCancelAmount = "신규 취소금액" // 입력값
newCancelTaxFreeAmount = "신규 취소금액 중 면세액" // 입력값
newCancelTaxedAmount = "신규 취소금액 중 과세액" = newCancelAmount - newCancelTaxFreeAmount
newCancelVATAmount = "신규 취소금액 중 부가가치세" // 최종 결과, 이른바 vat_amount
  = round((newCancelTaxedAmount + accumCancelTaxedAmount)/11) - accumCancelVATAmount

newCancelVATAmount = 
round((newCancelAmount - newCancelTaxFreeAmount + accumCancelTaxedAmount)/11) - round(accumCancelTaxedAmount / 11)
```

- *신규 취소금액 중 과세액* + *기존 누적 취소금액 중 과세액* => *신규 누적 취소금액 중 과세액*
- *신규 누적 취소금액 중 과세액* / 11 => *신규 누적 취소금액 중 과세액의 부가가치세*
- *신규 누적 취소금액 중 과세액의 부가가치세* - *기존 누적 취소금액 중 부가가치세* => *신규 취소금액 중 부가가치세*

신규 취소금액과 기존 누적 취소금액을 합하여 새로운 부가가치세 총액을 계산한 뒤, 기존에 이미 계산된 부가가치세를 차감하여 신규 취소금액에 해당하는 부가가치세만을 도출한다. 이러한 계산의 논리적 근거는 다음과 같다:

1. 부가가치세의 누적 계산:
    - 신규 취소금액과 기존 누적 취소금액을 합치는 것은 *새로운 누적된 과세 금액을 구하기 위함*이다.
    - 이 누적된 금액에서 부가가치세를 계산하면, *신규와 기존 금액을 모두 포함한 총 부가가치세*를 얻을 수 있다.
2. 기존 부가가치세의 차감
    - 이미 계산된 기존 누적 부가가치세를 새로 계산된 총 부가가치세에서 빼는 것은, 신규 취소금액에만 해당하는 부가가치세를 분리하기 위함이다.
    - 이는 신규 취소금액이 발생함으로써 증가한 부가가치세의 정확한 양을 계산하기 위한 과정이다.
3. 변동 부가가치세의 정확한 계산
    1. 이 방식을 사용하면, 새로운 거래가 이전 거래에 미치는 실제적인 부가가치세의 변동을 정확하게 파악할 수 있다.
    2. 특히, 다수의 거래가 누적되어 있는 상황에서 각각의 거래가 전체 부가가치세에 미치는 영향을 분리하여 계산하는 데 유용하다.

이러한 계산 방식은 특히 부가가치세가 중간에 변동되는 경우(예: 취소, 환불 등)에 유용하며, *전체 누적 부가가치세와 신규 거래에 의한 추가 부가가치세 사이의 정확한 차이를 파악*할 수 있게 해준다. 이는 회계적 정확성을 유지하고, 각 거래에 대한 정확한 세금 부담을 계산하는 데 중요하다.

제시된 수식은 여러 차례의 취소 거래에서 발생하는 부가가치세(VAT)의 누적 오차를 최소화하기 위한 것입니다. 이러한 오차는 각 취소 거래마다 부가가치세를 개별적으로 계산하고 반올림할 때 발생합니다. 이제 아래의 수식을 분석해 보겠습니다:

```php
newCancelVATAmount = 
    round((newCancelAmount - newCancelTaxFreeAmount + accumCancelTaxedAmount) / 11) - 
    round(accumCancelTaxedAmount / 11)
```

이 수식은 다음과 같은 두 단계로 나눌 수 있습니다:

1. **신규 누적 부가가치세 계산**:
   - `(newCancelAmount - newCancelTaxFreeAmount + accumCancelTaxedAmount) / 11`
   - 이 부분은 신규 취소금액 중 과세액과 기존 누적 취소금액 중 과세액을 합산한 후, 11로 나누어 부가가치세를 계산합니다.
   - 여기서 `round` 함수는 부동소수점 연산에서 발생할 수 있는 소수점 이하의 오차를 반올림하여 처리합니다.

2. **기존 누적 부가가치세 차감**:
   - `round(accumCancelTaxedAmount / 11)`
   - 이 부분은 기존 누적 취소금액 중 과세액에 대한 부가가치세를 계산합니다.
   - 이 값 역시 반올림하여 오차를 최소화합니다.

3. **신규 취소금액 중 부가가치세 도출**:
   - 최종적으로, 신규 누적 부가가치세에서 기존 누적 부가가치세를 차감함으로써 신규 취소금액에 해당하는 순 부가가치세를 도출합니다.

이 계산 방식의 핵심은 각 취소 거래마다 발생하는 부가가치세를 개별적으로 계산하고 반올림하는 대신, 총 과세 금액에 대한 부가가치세를 한 번에 계산하여 누적 오차를 줄이는 것입니다. 이 방법은 다음과 같은 이점을 제공합니다:

- **누적 오차 최소화**: 여러 차례의 취소 거래에서 각각 반올림을 수행할 때 누적되는 오차를 줄일 수 있습니다.
- **정확도 향상**: 전체 과세 금액에 대한 부가가치세를 한 번에 계산함으로써, 각 거래의 세금 영향을 더 정확하게 평가할 수 있습니다.

따라서, 이 계산 방식은 부가가치세를 계산할 때 발생할 수 있는 누적 오차를 줄이는 효과적인 방법입니다. 특히, 부가가치세가 정수로 반올림될 때 이러한 접근 방식은 더욱 중요해집니다.

"누적 오차 최소화"의 원리는 부가가치세(VAT) 계산과 같은 금융 계산에서 반올림을 여러 차례 수행할 때 발생할 수 있는 오차를 줄이는 것을 목표로 합니다. 이를 이해하기 위해, 반올림이 왜 중요하며, 반올림을 여러 번 수행할 때 어떻게 오차가 누적되는지 살펴보겠습니다.

1. **반올림의 필요성**:
   - 부가가치세 계산에서, 과세 금액을 특정 수치로 나눈 후 (예: 한국에서는 11로 나눔), 결과는 일반적으로 가장 가까운 정수로 반올림됩니다.
   - 부동소수점 연산으로 인해, 나눗셈의 결과가 완벽한 정수가 아닌 근사값이 될 수 있습니다. 따라서, 반올림은 이러한 근사값을 실제 금액으로 변환하는 데 필요합니다.

2. **단일 거래에서의 반올림**:
   - 단일 거래에서 과세 금액에 대한 부가가치세를 계산할 때, 반올림은 결과값의 정확도를 향상시킵니다.
   - 예를 들어, 500원의 과세 금액에서 부가가치세는 45.45원입니다. 이를 반올림하면 45원이 됩니다.

3. **여러 거래에서의 누적 오차**:
   - 여러 거래에 걸쳐 각각 부가가치세를 계산하고 반올림할 때, 각 반올림 과정에서 발생하는 소수점 이하의 작은 오차가 누적될 수 있습니다.
   - 예를 들어, 1000원의 과세 금액에서 부가가치세는 90.91원입니다 (반올림하여 91원). 이후 500원을 취소하면 새로운 부가가치세는 45.45원입니다 (반올림하여 45원). 남은 부가가치세는 이론적으로 45.45원이어야 하지만, 두 번의 반올림으로 인해 실제 남은 부가가치세는 46원이 됩니다.

4. **누적 오차 최소화 방법**:
   - 여러 거래에 대한 부가가치세를 한 번에 계산함으로써, 각 거래에서 발생하는 반올림 오차를 줄일 수 있습니다.
   - 예를 들어, 총 1000원의 과세 금액에서 500원을 두 번 취소하는 경우, 각 500원에 대한 부가가치세를 개별적으로 계산하고 반올림하는 대신, 총 과세 금액(1000원 - 500원 - 500원)에 대한 부가가치세를 한 번에 계산합니다.
   - 이 방법은 각 단계에서의 반올림 오차를 줄이고, 결과적으로 더 정확한 부가가치세 계산을 가능하게 합니다.

요약하자면, "누적 오차 최소화"는 반올림을 여러 번 수행함으로써 발생할 수 있는 오차를 줄이는 방법입니다. 이는 특히 여러 차례의 금융 거래가 있는 경우에 중요하며, 각 거래에 대한 정확한 세금 부담을 계산하는 데 도움이 됩니다.

## 일반적인 부가세율 10%를 계산할 때 11로 나누기

기본 부가세율이 10%임을 나타내고, 이미 가격에 포함된 세금을 계산하는 데 사용된다는 점을 강조합니다.

1. `DEFAULT_VAT_INCLUSIVE_DIVISOR`
   - 기본 부가세가 포함된 금액에서 사용되는 제수임을 나타냅니다.

2. `STANDARD_VAT_EXTRACTION_FACTOR`
   - 표준 부가세를 추출하기 위한 계수임을 나타냅니다.

3. `BASE_VAT_INCLUSIVE_RATIO`
   - 기본 부가세가 포함된 비율을 나타냅니다.

4. `DEFAULT_VAT_INCLUDED_PRICE_DIVISOR`
   - 기본 부가세가 이미 포함된 가격에서 사용되는 제수임을 명확히 합니다.

5. `STANDARD_VAT_REVERSE_CALCULATION_FACTOR`
   - 표준 부가세의 역산 계산에 사용되는 계수임을 나타냅니다.

이 중에서 가장 적절해 보이는 것은 `DEFAULT_VAT_INCLUSIVE_DIVISOR`입니다. 이 이름은 다음과 같은 의미를 포함합니다:

- `DEFAULT`: 기본 세율(10%)을 사용한다는 것을 나타냅니다.
- `VAT`: 부가가치세에 관한 것임을 명시합니다.
- `INCLUSIVE`: 세금이 이미 가격에 포함되어 있음을 나타냅니다.
- `DIVISOR`: 나누는 데 사용되는 수임을 나타냅니다.

사용 예:

```php
/**
 * 기본 부가가치세(10%)가 포함된 금액에서 세액을 역산하기 위한 제수.
 * 계산식: 1 / (1 + 0.1) ≈ 0.90909...의 역수
 * 사용: 총액 / DEFAULT_VAT_INCLUSIVE_DIVISOR = 부가세 금액
 */
const DEFAULT_VAT_INCLUSIVE_DIVISOR = 11;

// 사용 예
$vatAmount = (int)round(max($totalAmount - $taxFreeAmount, 0) / DEFAULT_VAT_INCLUSIVE_DIVISOR);
```

이 방식은 다음과 같은 이점이 있습니다:

1. 상수명에서 이 값이 기본 세율(10%)을 가정한 것임을 명확히 합니다.
2. '포함된(inclusive)' 이라는 단어를 사용하여 이 값이 세금이 이미 포함된 가격에 적용됨을 나타냅니다.
3. 주석을 통해 이 값의 정확한 의미와 계산 방식, 사용법을 설명합니다.

이렇게 하면 코드를 처음 보는 개발자도 이 상수의 목적과 사용 방법을 쉽게 이해할 수 있을 것입니다.

---

네, 두 가지 제안 모두 매우 좋습니다. 각각의 장단점을 살펴보겠습니다:

1. `DEFAULT_INCLUDED_VAT_DIVISOR`

    장점:
    - "포함된(included)"이라는 단어를 사용하여 VAT가 이미 가격에 포함되어 있음을 명확히 나타냅니다.
    - "기본(default)"이라는 단어로 표준 세율(10%)을 사용한다는 것을 나타냅니다.
    - "divisor"라는 단어로 이 값이 나누는 데 사용된다는 것을 명확히 합니다.

    단점:
    - 단어 순서가 약간 어색할 수 있습니다 ("included VAT"보다는 "VAT-inclusive"가 더 일반적인 표현입니다).

2. `STANDARD_VAT_EXTRACTION_FACTOR`

    장점:
    - "추출(extraction)"이라는 단어를 사용하여 이 값의 목적(VAT를 전체 금액에서 분리해내는 것)을 잘 나타냅니다.
    - "표준(standard)"이라는 단어로 일반적인 세율을 사용한다는 것을 나타냅니다.
    - "factor"라는 단어는 이 값이 계산에 사용되는 요소임을 나타냅니다.

    단점:
    - "extraction"이라는 단어가 약간 기술적으로 들릴 수 있습니다.
    - VAT가 이미 포함되어 있다는 점을 직접적으로 나타내지 않습니다.

두 옵션을 비교해 볼 때, `DEFAULT_INCLUDED_VAT_DIVISOR`가 조금 더 직관적이고 명확해 보입니다. 하지만 단어 순서를 약간 조정하면 더 좋을 것 같습니다.

최종 제안:

```php
const DEFAULT_VAT_INCLUSIVE_DIVISOR = 11;
```

이 이름은 다음과 같은 장점을 가집니다:

1. "DEFAULT"로 시작하여 기본 세율을 사용한다는 점을 명시합니다.
2. "VAT_INCLUSIVE"라는 표현으로 부가가치세가 이미 포함되어 있음을 명확히 합니다.
3. "DIVISOR"로 끝나 이 값이 나누는 데 사용된다는 점을 나타냅니다.

사용 예와 주석:

```php
/**
 * 기본 부가가치세(10%)가 이미 포함된 금액에서 세액을 역산하기 위한 제수.
 * 계산식: 1 / (1 + 0.1) ≈ 0.90909...의 역수
 * 사용: 총액 / DEFAULT_VAT_INCLUSIVE_DIVISOR = 부가세 금액
 */
const DEFAULT_VAT_INCLUSIVE_DIVISOR = 11;

// 사용 예
$vatAmount = (int)round(max($totalAmount - $taxFreeAmount, 0) / DEFAULT_VAT_INCLUSIVE_DIVISOR);
```

이 방식은 상수의 목적과 사용법을 명확히 전달하면서도, VAT가 이미 포함된 금액에서 사용된다는 점을 강조합니다.
