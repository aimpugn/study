# Browser Redirection

- [Browser Redirection](#browser-redirection)
    - [브라우저 리디렉션 작동 방식](#브라우저-리디렉션-작동-방식)
    - [리디렉션 과정](#리디렉션-과정)
        - [1. 사용자 요청](#1-사용자-요청)
        - [2. 서버 응답](#2-서버-응답)
        - [3. 브라우저 처리](#3-브라우저-처리)
        - [4. 새 위치 요청](#4-새-위치-요청)
        - [5. 최종 응답](#5-최종-응답)
        - [추가 고려 사항](#추가-고려-사항)
    - [리디렉션과 JavaScript](#리디렉션과-javascript)

## 브라우저 리디렉션 작동 방식

브라우저의 리디렉션 메커니즘은 주로 HTTP 응답 상태 코드를 통해 구현됩니다.
가장 일반적인 리디렉션 방법은 *서버가 클라이언트(브라우저)에게 다음과 같은 HTTP 상태 코드를 전송*하는 것입니다.
- `302 Found`: 요청된 리소스가 일시적으로 다른 위치로 이동했음
- `301 Moved Permanently`: 요청된 리소스가 영구적으로 새 위치로 이동했음
- `303 See Other`: 요청에 대한 응답을 다른 URI에서 가져와야 함
- [`307 Temporary Redirect`](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/307): 요청된 리소스가 일시적으로 다른 위치로 이동했으며, 메서드가 변경되지 않아야 함
- [`308 Permanent Redirect`](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/308): 청된 리소스가 영구적으로 새 위치로 이동했으며, 메서드가 변경되지 않아야 함

이 상태 코드와 함께 `Location` 헤더가 응답에 포함되며,
이 헤더는 클라이언트가 다음에 요청해야 할 URL을 지정합니다.

브라우저는 HTTP 응답을 받았을 때 상태 코드를 확인합니다.
리디렉션을 나타내는 상태 코드(예: 301, 302, 303, 307, 308)를 감지하면,
응답 헤더에서 `Location` 필드를 찾아 그 값(새로운 URL)으로 자동으로 이동합니다.

## 리디렉션 과정

### 1. 사용자 요청

사용자가 웹 브라우저의 주소창에 URL을 입력하거나, 웹 페이지 내의 링크를 클릭합니다.
브라우저는 이 URL에 대한 HTTP GET 요청을 생성하고, 이를 서버로 전송합니다.

### 2. 서버 응답

웹 서버는 요청을 받고, 요청된 URL이 리디렉션을 필요로 하는지 판단합니다.
이는 서버 설정 파일(`.htaccess`, `nginx.conf` 등) 또는 서버 사이드 스크립트(PHP, Node.js 등)를 통해 구성될 수 있습니다.

리디렉션이 필요한 경우, 서버는 `Location` 헤더와 함께 리디렉션을 나타내는 특정 HTTP 상태 코드(예: `301`, `302`)를 클라이언트에게 전송합니다.
`Location` 헤더는 사용자가 리디렉션될 새로운 URL을 포함합니다.

> HTTP 리디렉션은 서버 단에서 처리되며, 클라이언트 측 JavaScript는 이후 단계에서 페이지 상태를 추가로 제어할 수 있습니다.
>
> 예를 들어, 서버에서 `302` 리디렉션 후, 페이지 로딩 시 JavaScript를 사용하여 추가 리디렉션을 수행하거나, DOM을 조작할 수 있습니다.

### 3. 브라우저 처리

브라우저는 서버로부터 받은 응답을 분석합니다.
HTTP 상태 코드가 리디렉션을 나타내는 경우(예: `301`, `302`), 브라우저는 `Location` 헤더에서 제공된 새 URL로 자동으로 이동합니다.

이 과정에서 브라우저는 새 URL에 대한 새로운 HTTP 요청을 생성합니다.
이 요청은 보통 GET 메서드를 사용하지만, 일부 상황에서는 원래 요청의 메서드를 유지할 수도 있습니다(`307`, `308` 상태 코드 참조).

### 4. 새 위치 요청

브라우저는 `Location` 헤더에 지정된 새 URL로 새로운 요청을 보냅니다.
이는 사용자가 직접 새 URL을 입력한 것과 유사한 과정입니다.

서버는 이 새로운 요청을 받고, 요청된 리소스에 대한 응답을 준비합니다.
이 때, 추가적인 리디렉션이 발생할 수도 있습니다.

### 5. 최종 응답

서버는 최종적으로 요청된 리소스에 대한 응답을 브라우저에 전달합니다.
이 응답은 HTML 문서, 이미지, CSS 파일 등 다양한 형태일 수 있습니다.

브라우저는 이 응답을 받고, 사용자에게 최종 리소스를 표시합니다.

### 추가 고려 사항

- **리디렉션 루프**: 리디렉션 과정이 무한히 반복되는 상황을 피해야 합니다. 이는 서버 구성 오류나 프로그래밍 실수로 발생할 수 있습니다.
- **성능**: 리디렉션은 추가적인 HTTP 요청을 발생시키므로, 웹 페이지 로딩 시간에 영향을 줄 수 있습니다. 가능한 한 리디렉션을 최소화하는 것이 좋습니다.
- **HTTP 상태 코드**: 영구적 리디렉션(`301`)과 일시적 리디렉션(`302`) 사이에서 적절한 상태 코드를 선택하는 것이 중요합니다.

    이는 SEO와 사용자 경험에 영향을 줄 수 있습니다.
    `301` 영구적 리디렉션은 검색 엔진에 원본 URL이 새 URL로 교체되어야 한다고 알리는 역할을 하기 때문에,
    일시적 리디렉션(302)보다 선호된다고 합니다.

    [URL 리다이렉트가 SEO에 영향을 미치나요?](https://www.redirhub.com/ko/blog/does-redirecting-a-url-affect-seo) 참고.

## 리디렉션과 JavaScript

JavaScript는 `window.location` 객체를 통해 페이지 리디렉션을 제어할 수 있습니다.
이 객체는 현재 페이지의 URL을 나타내며, 여러 방식으로 페이지를 리디렉션할 수 있습니다.

```js
// 새 URL을 설정하여 페이지를 리디렉션합니다.
// 이 방식은 브라우저의 히스토리에 현재 페이지와 새 페이지가 모두 기록됩니다.
window.location.href = newURL;

// 현재 페이지를 새 페이지로 대체합니다.
// 이 방식은 현재 페이지를 히스토리에서 제거하므로, 사용자가 뒤로 가기 버튼을 눌러도 이전 페이지로 돌아가지 않습니다.
window.location.replace(newURL);

// HTML5 히스토리 API를 사용하여 브라우저 히스토리의 상태를 조작합니다.
// 페이지를 리로드하지 않고 URL을 변경할 수 있습니다.
// `pushState`는 새 항목을 히스토리에 추가합니다.
// https://developer.mozilla.org/en-US/docs/Web/API/History/pushState
history.pushState(newURL)
// `replaceState`는 현재 항목을 새 상태로 대체합니다.
// https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState
history.replaceState()
```

JavaScript의 `history` 객체를 사용하면 사용자가 사이트 내에서 이동할 때의 브라우저 히스토리를 세밀하게 제어할 수 있습니다.
이를 통해 SPA(Single Page Application)에서 사용자 경험을 개선할 수 있습니다.
