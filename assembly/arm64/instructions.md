# ARM64 instructions

- [ARM64 instructions](#arm64-instructions)
    - [ARM64 instructions](#arm64-instructions-1)
    - [데이터 이동 및 레지스터 조작](#데이터-이동-및-레지스터-조작)
    - [산술 연산](#산술-연산)
    - [메모리 접근](#메모리-접근)
    - [조건 분기](#조건-분기)
    - [주소 계산](#주소-계산)
    - [비트 연산](#비트-연산)
    - [분기 및 프로시저 호출](#분기-및-프로시저-호출)
    - [기타](#기타)

## ARM64 instructions

ARM64 아키텍처에서 사용되는 주요 어셈블리 명령어들의 카테고리화 및 각각의 사용 목적에 대한 설명입니다.

## 데이터 이동 및 레지스터 조작

- `MOVD`: 64비트 레지스터 간의 데이터 이동을 수행합니다.
- `MOVWU`: 32비트 레지스터의 값을 64비트 레지스터로 이동하며, 상위 32비트는 0으로 채워집니다.
- `MOVK`: 16비트 또는 32비트 상수를 레지스터의 특정 비트 위치에 삽입합니다.

## 산술 연산

- `SUB`: 두 레지스터의 값을 빼는 산술 연산을 수행합니다.
- `ADD`: 두 레지스터의 값을 더하는 산술 연산을 수행합니다.

## 메모리 접근

- `STP`: 두 레지스터의 값을 메모리에 저장합니다.
- `MOVBU`: 메모리에서 8비트 값을 불러와 레지스터에 저장합니다.

## 조건 분기

- `CMP`: 두 레지스터의 값을 비교하여 조건 코드를 설정합니다.
- `CMPW`: 두 레지스터의 32비트 값을 비교하여 조건 코드를 설정합니다.
- `BLS`: 조건 코드가 설정되어 있지 않으면 분기합니다.
- `BHI`: 조건 코드가 설정되어 있으면 분기합니다.
- `BEQ`: 조건 코드가 설정되어 있으면 분기합니다.
- `BNE`: 조건 코드가 설정되어 있지 않으면 분기합니다.

## 주소 계산

- `ADRP`: 주소 계산을 위해 프로그램 카운터를 사용하여 페이지 주소를 계산합니다.

## 비트 연산

- `AND`: 두 레지스터의 값을 비트 AND 연산합니다.
- `ORR`: 두 레지스터의 값을 비트 OR 연산합니다.
- `EOR`: 두 레지스터의 값을 비트 XOR 연산합니다.

## 분기 및 프로시저 호출

- `B`: 무조건 분기합니다.
- `BL`: 프로시저를 호출하고 반환 주소를 링크 레지스터에 저장합니다.
- `RET`: 링크 레지스터에 저장된 반환 주소로 분기합니다.

## 기타

- `NOOP`: 아무런 작업도 수행하지 않는 명령어입니다.
- `CBZ`: 레지스터의 값이 0인 경우 분기합니다.
- `CBNZ`: 레지스터의 값이 0이 아닌 경우 분기합니다.

이러한 명령어들은 프로그램의 다양한 부분에서 사용되며, 각각의 명령어는 특정 작업을 수행하기 위해 설계되었습니다. 예를 들어, `MOVD`와 `MOVWU`는 데이터를 레지스터 간에 이동하거나 메모리에서 레지스터로 데이터를 로드할 때 사용됩니다. `SUB`와 `ADD`는 산술 연산을 수행하며, `CMP`와 관련 조건 분기 명령어들은 조건부 분기를 수행하기 위해 사용됩니다. `ADRP`는 주소 계산을 위해 사용되며, `BL`과 `RET`는 프로시저 호출과 반환을 관리합니다. 이러한 명령어들은 프로그램의 흐름을 제어하고, 데이터를 조작하며, 메모리에 접근하는 등의 작업을 수행하는 데 사용됩니다.
