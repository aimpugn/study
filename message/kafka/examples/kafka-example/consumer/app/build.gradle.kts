/*
 * This file was generated by the Gradle 'init' task.
 *
 * This generated file contains a sample Kotlin application project to get you started.
 * For more details on building Java & JVM projects, please refer to https://docs.gradle.org/8.11/userguide/building_java_projects.html in the Gradle documentation.
 */

plugins {
    // Apply the org.jetbrains.kotlin.jvm Plugin to add support for Kotlin.
    alias(libs.plugins.kotlin.jvm)

    // Apply the application plugin to add support for building a CLI application in Java.
    application
    idea

    /**
     * Spring 관련 플러그인
     */
    alias(libs.plugins.spring.boot)
    alias(libs.plugins.spring.dependency.management)
}

repositories {
    // Use Maven Central for resolving dependencies.
    mavenCentral()
}

dependencies {
    implementation(libs.spring.boot.starter)
    implementation(libs.spring.boot.starter.web)
    implementation(libs.kotlinx.coroutines.core)

    // Use the Kotlin JUnit 5 integration.
    testImplementation("org.jetbrains.kotlin:kotlin-test-junit5")

    // Use the JUnit 5 integration.
    testImplementation(libs.junit.jupiter.engine)

    testRuntimeOnly("org.junit.platform:junit-platform-launcher")

    // This dependency is used by the application.
    implementation(libs.guava)
}

// Apply a specific Java toolchain to ease working on different environments.
java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

application {
    // Define the main class for the application.
    mainClass = "test.consumer.ConsumerAppKt"
}

/**
 * [application] 플러그인이 메인 클래스를 [run] 태스크에서만 활용할 수 있도록 설정하고, `META-INF/MANIFEST.MF`에 명시적으로 추가하지 않을 수 있습니다.
 *
 * References:
 * - https://stackoverflow.com/a/32567525
 */
tasks.jar {
    /**
     * 런타임 클래스패스(Class-Path)는 JAR 파일을 실행할 때 해당 애플리케이션이 의존하는 외부 라이브러리를 JVM이 올바르게 로드할 수 있도록 지정하는 데 필요합니다.
     *
     * JVM은 애플리케이션 JAR 파일 내에 포함되지 않은 외부 라이브러리를 기본적으로 로드하지 않습니다. 즉:
     * - JAR 파일 내부의 코드만 인식하고 실행할 수 있습니다.
     * - 의존성 파일이 JAR 외부에 있을 경우, JVM은 이 의존성을 명시적으로 알려줘야 합니다.
     *
     * `Class-Path`는 실행 시 애플리케이션이 의존하는 JAR 파일들의 위치를 지정합니다. 이를 통해:
     * - 의존성 로드: JVM이 애플리케이션 JAR 파일 외부에 위치한 의존성을 로드할 수 있게 합니다.
     * - 애플리케이션 실행 가능: JVM이 모든 필요한 클래스를 메모리에 로드하여 애플리케이션이 정상적으로 실행될 수 있게 보장합니다.
     */
    val runtimeClassPath = configurations.runtimeClasspath.get().joinToString(" ") { it.name }

    manifest {
        attributes(
            "Main-Class" to application.mainClass.get(),
            "Class-Path" to runtimeClassPath
        )
    }
}

tasks.named<Test>("test") {
    // Use JUnit Platform for unit tests.
    useJUnitPlatform()
}
