# Process substitution

- [Process substitution](#process-substitution)
    - [프로세스 치환의 기본 개념](#프로세스-치환의-기본-개념)
    - [작동 원리](#작동-원리)
    - [프로세스 치환이 가능하게 하는 것들](#프로세스-치환이-가능하게-하는-것들)
        - [a. 여러 명령어의 출력 비교](#a-여러-명령어의-출력-비교)
        - [b. 출력을 여러 명령어로 동시에 파이프](#b-출력을-여러-명령어로-동시에-파이프)
        - [c. 임시 파일 없이 복잡한 데이터 처리](#c-임시-파일-없이-복잡한-데이터-처리)
    - [활용](#활용)
        - [phpunit 예제에서의 활용](#phpunit-예제에서의-활용)
    - [프로세스 치환의 장점](#프로세스-치환의-장점)
    - [주의사항](#주의사항)
    - [결과 출력과 동시에 변수에 저장하기](#결과-출력과-동시에-변수에-저장하기)

## 프로세스 치환의 기본 개념

프로세스 치환(Process Substitution)은 Bash와 같은 현대적인 쉘에서 제공하는 고급 기능입니다.
이 기능은 명령어의 출력을 파일처럼 다른 명령어의 입력으로 직접 전달할 수 있게 해줍니다.

프로세스 치환은 명령어나 함수의 출력을 임시 파일처럼 취급하여 다른 명령어의 입력으로 사용할 수 있게 합니다.

문법은 다음과 같습니다:

- 출력 프로세스 치환: `<(command)`
- 입력 프로세스 치환: `>(command)`

## 작동 원리

- 쉘은 프로세스 치환 구문을 만나면 새로운 프로세스를 생성합니다.
- 이 프로세스는 명령어를 실행하고 그 출력을 파이프(named pipe)나 `/dev/fd/`의 특수 파일로 리다이렉션합니다.
- 쉘은 이 파이프나 특수 파일의 경로를 프로세스 치환 구문 대신 명령줄에 넣습니다.
- 결과적으로, 명령어의 출력이 파일처럼 다뤄질 수 있게 됩니다.

예를 들어, 다음과 같은 명령을 실행한다고 가정해보겠습니다:

```bash
diff <(ls dir1) <(ls dir2)
```

이 명령의 프로세스 치환 작동 원리를 단계별로 설명하겠습니다:

1. 구문 분석:
    쉘(예: Bash)은 명령줄을 파싱하고 `<(ls dir1)`와 `<(ls dir2)`라는 두 개의 프로세스 치환 구문을 식별합니다.

2. 프로세스 생성:
    - 쉘은 각 프로세스 치환 구문에 대해 새로운 프로세스를 생성합니다.
    - 이 경우, 두 개의 새로운 프로세스가 생성됩니다
        - 하나는 `ls dir1`을 실행하기 위한 것
        - 다른 하나는 `ls dir2`를 실행하기 위한 것

3. 파이프 또는 특수 파일 생성:
    - 각 프로세스에 대해, 쉘은 named pipe(FIFO)나 `/dev/fd/` 디렉토리의 특수 파일을 생성합니다.
    - 예를 들어, `/dev/fd/63`과 `/dev/fd/64`와 같은 파일이 생성될 수 있습니다.
    - 이러한 파일들은 실제로는 프로세스 간 통신을 위한 인터페이스입니다.

4. 출력 리다이렉션:
    - 쉘은 각 `ls` 명령의 출력을 해당하는 파이프나 특수 파일로 리다이렉션합니다.
    - `ls dir1`의 출력은 `/dev/fd/63`으로, `ls dir2`의 출력은 `/dev/fd/64`로 리다이렉션될 수 있습니다.

5. 명령줄 재구성:
    - 쉘은 원래의 프로세스 치환 구문을 해당하는 파이프나 특수 파일의 경로로 대체합니다.
    - 결과적으로, 실제로 실행되는 명령은 다음과 같이 변형됩니다:

    ```bash
    diff /dev/fd/63 /dev/fd/64
    ```

6. 명령 실행:
    - 변형된 명령이 실행됩니다. `diff` 명령은 두 개의 파일 경로를 인자로 받아 실행됩니다.
    - `diff`는 이 특수 파일들을 일반 파일처럼 읽을 수 있습니다.

7. 데이터 흐름:
    - `ls dir1`의 출력이 `/dev/fd/63`을 통해 `diff`의 첫 번째 입력으로 전달됩니다.
    - `ls dir2`의 출력이 `/dev/fd/64`를 통해 `diff`의 두 번째 입력으로 전달됩니다.
    - `diff`는 이 두 입력을 비교하여 결과를 출력합니다.

8. 리소스 정리:
    명령 실행이 완료되면, 쉘은 생성된 프로세스들을 종료하고 임시 파이프나 특수 파일들을 제거합니다.

9. 결과 출력:
    `diff` 명령의 결과가 표준 출력으로 전송되어 사용자에게 보여집니다.

이 과정을 통해 프로세스 치환은 다음과 같은 이점을 제공합니다:

- 임시 파일을 명시적으로 생성하지 않고도 명령어의 출력을 다른 명령어의 입력으로 직접 사용할 수 있습니다.
- 여러 명령어의 출력을 동시에 처리할 수 있어 복잡한 데이터 처리 작업을 단순화할 수 있습니다.
- 디스크 I/O를 줄일 수 있어 성능상 이점이 있을 수 있습니다.

이러한 메커니즘을 통해 프로세스 치환은 유닉스 철학인 "모든 것은 파일이다"라는 개념을 확장하여, 프로세스의 출력도 파일처럼 다룰 수 있게 해줍니다. 이는 쉘 스크립팅에서 매우 강력하고 유연한 도구로 활용됩니다.

## 프로세스 치환이 가능하게 하는 것들

### a. 여러 명령어의 출력 비교

```bash
diff <(ls dir1) <(ls dir2)
```

이 명령은 두 디렉토리의 내용을 직접 비교합니다.

### b. 출력을 여러 명령어로 동시에 파이프

```bash
echo "Hello" | tee >(grep 'H' > file1) >(grep 'o' > file2)
```

이 명령은 "Hello"를 출력하면서 동시에 'H'를 포함한 줄을 file1에, 'o'를 포함한 줄을 file2에 저장합니다.

### c. 임시 파일 없이 복잡한 데이터 처리

```bash
join <(sort file1) <(sort file2)
```

두 파일을 정렬하고 바로 join 명령으로 처리합니다.

## 활용

### phpunit 예제에서의 활용

```bash
phpunit_output=$(phpunit | tee >(cat - > "$temp_file"))
```

- `phpunit`의 출력이 `tee` 명령으로 전달됩니다.
- `tee`는 이 출력을 화면에 표시하고 동시에 프로세스 치환 `>(cat - > "$temp_file")`으로 전달합니다.
- 프로세스 치환은 출력을 임시 파일에 저장합니다.
- 전체 명령의 출력은 `phpunit_output` 변수에 저장됩니다.

## 프로세스 치환의 장점

- 임시 파일을 명시적으로 생성하고 관리할 필요가 없습니다.
- 여러 명령어의 출력을 동시에 처리할 수 있습니다.
- 파이프라인을 더 유연하게 구성할 수 있습니다.
- 디스크 I/O를 줄일 수 있어 성능상 이점이 있을 수 있습니다.

## 주의사항

- 모든 쉘에서 지원되는 것은 아닙니다 (주로 bash, zsh 등 현대적인 쉘에서 지원).
- 과도한 사용은 코드의 가독성을 해칠 수 있습니다.
- 복잡한 프로세스 치환은 디버깅이 어려울 수 있습니다.

## 결과 출력과 동시에 변수에 저장하기

Shell script를 사용해서 phpunit의 출력을 보여주면서 동시에 그 결과를 변수에 저장할 수 있습니다.
이를 위해 "프로세스 치환(Process Substitution)" 기능과 "tee" 명령어를 사용할 수 있습니다.

```bash
#!/bin/bash

# 임시 파일 생성
temp_file=$(mktemp)

# phpunit 실행, 출력을 화면에 보여주고 동시에 임시 파일에 저장
phpunit_output=$(phpunit | tee >(cat - > "$temp_file"))

# 임시 파일에서 결과를 읽어 변수에 저장
phpunit_result=$(<"$temp_file")

# 임시 파일 삭제
rm "$temp_file"

# 이제 $phpunit_result 변수에 phpunit의 전체 출력이 저장되어 있습니다.
# 이를 활용하여 추가 작업을 수행할 수 있습니다.

# 예: 결과에서 특정 문자열 찾기
if echo "$phpunit_result" | grep -q "FAILURES!"; then
    echo "테스트에 실패했습니다."
else
    echo "모든 테스트가 통과했습니다."
fi

# 예: 결과를 파일로 저장
echo "$phpunit_result" > phpunit_results.txt

# 예: 결과의 줄 수 계산
line_count=$(echo "$phpunit_result" | wc -l)
echo "총 $line_count 줄의 출력이 있었습니다."
```

이 스크립트는 다음과 같이 작동합니다:

1. `mktemp`를 사용해 임시 파일을 생성합니다.

2. `phpunit` 명령을 실행하고, 그 출력을 `tee` 명령어를 통해 화면에 출력함과 동시에 임시 파일에 저장합니다.

3. 임시 파일의 내용을 `phpunit_result` 변수에 저장합니다.

4. 임시 파일을 삭제합니다.

5. 이제 `$phpunit_result` 변수에 phpunit의 전체 출력이 저장되어 있으며, 이를 활용하여 다양한 후속 작업을 수행할 수 있습니다.

이 방식의 장점은 다음과 같습니다:

- phpunit의 실행 결과를 실시간으로 볼 수 있습니다.
- 동시에 전체 결과를 변수에 저장하여 추후 분석이나 처리에 사용할 수 있습니다.
- 임시 파일을 사용하므로 메모리 사용량이 적습니다.

주의할 점:

- 출력량이 매우 많은 경우, 변수에 저장하는 것이 메모리 문제를 일으킬 수 있습니다. 이 경우 결과를 직접 파일로 저장하는 것이 좋을 수 있습니다.
- 쉘 스크립트의 호환성을 위해, 이 스크립트는 bash나 zsh 같은 현대적인 쉘에서 실행해야 합니다. sh에서는 작동하지 않을 수 있습니다.

이 스크립트를 사용하면 phpunit의 출력을 보면서 동시에 그 결과를 변수에 저장하여 다양한 방식으로 활용할 수 있습니다.
