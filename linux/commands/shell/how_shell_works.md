# How shell works

## 쉘의 동작 방식

셸의 동작 방식을 이해하는 것은 컴퓨터 시스템의 핵심 원리를 파악하는 데 매우 중요합니다.
셸의 동작을 단계별로 상세하게 설명해드리겠습니다.

### 셸의 입력 대기 및 처리 방식

a. 입력 대기:
    - 셸은 일반적으로 `read()` 시스템 콜을 사용하여 사용자 입력을 대기합니다.
    - 이는 실제로 무한 루프 내에서 이루어지지만, 운영체제 수준에서 효율적으로 관리됩니다.
    - 예를 들어, Bash의 간단한 구현은 다음과 같을 수 있습니다:

    ```c
    while (1) {
        char *line = readline("prompt> ");
        if (line) {
            execute_command(line);
            free(line);
        }
    }
    ```

b. 입력 인식:
    - 사용자가 키를 누르면, 키보드 드라이버가 이를 감지하고 운영체제에 알립니다.
    - 운영체제는 이 입력을 현재 포커스가 있는 프로세스(이 경우 셸)로 전달합니다.
    - 셸은 입력 버퍼에서 이 데이터를 읽어들입니다.

c. 입력 처리:
    - 사용자가 Enter 키를 누르면, 셸은 이를 명령의 끝으로 인식합니다.
    - 셸은 입력된 문자열을 파싱하여 명령어와 인자들로 분리합니다.

### 명령어 실행 방법

a. 명령어 검색:
    - 셸은 먼저 내장 명령어인지 확인합니다(예: cd, echo).
    - 내장 명령어가 아니라면, PATH 환경 변수에 지정된 디렉토리에서 실행 파일을 검색합니다.

b. 프로세스 생성:
    - 실행 파일을 찾으면, 셸은 `fork()` 시스템 콜을 사용하여 새로운 프로세스를 생성합니다.
    - 새 프로세스는 셸의 복사본으로 시작됩니다.

c. 프로그램 로딩:
    - 자식 프로세스는 `execve()` 시스템 콜을 사용하여 새로운 프로그램을 메모리에 로드합니다.
    - 이 과정에서 자식 프로세스의 메모리 내용이 새 프로그램으로 대체됩니다.

### 프로세스 관리

a. 포그라운드 vs 백그라운드:
    - 셸은 일반적으로 포그라운드 프로세스가 완료될 때까지 대기합니다.
    - 백그라운드 프로세스(&로 실행)의 경우, 셸은 즉시 다음 명령어 입력을 받습니다.

b. 프로세스 상태 모니터링:
    - 셸은 `wait()` 또는 `waitpid()` 시스템 콜을 사용하여 자식 프로세스의 종료를 감지합니다.
    - 이를 통해 프로세스의 종료 상태를 확인하고 좀비 프로세스를 방지합니다.

### 출력 처리

a. 표준 출력/에러:
    - 각 프로세스는 기본적으로 세 개의 파일 디스크립터를 가집니다: `stdin(0)`, `stdout(1)`, `stderr(2)`.
    - 프로세스의 출력은 일반적으로 `stdout`과 `stderr`로 전송됩니다.
    - 셸은 이 출력을 터미널로 리다이렉트합니다.

b. 출력 리다이렉션:
    - 셸은 `>`, `>>`, `2>` 등의 연산자를 해석하여 출력을 파일로 리다이렉트할 수 있습니다.
    - 이는 `dup2()` 시스템 콜을 사용하여 구현됩니다.

출력 리디렉션을 이해하기 위해 각 리다이렉션 연산자의 동작 원리와 `dup2()` 시스템 콜의 사용 방법을 살펴볼 필요가 있습니다.

1. 기본 출력 리다이렉션 (`>`)

   예: `ls > file.txt`

   동작 원리:
    1. 셸은 `>` 연산자를 만나면
        - file.txt를 생성하거나
        - 또는 기존 파일을 덮어씁니다.
    2. `open()` 시스템 콜을 사용하여 file.txt를 엽니다.
    3. `dup2()` 시스템 콜을 사용하여 표준 출력(파일 디스크립터 1)을 file.txt로 리다이렉트합니다.
    4. `ls` 명령을 실행합니다.

    의사 코드:

    ```c
    int fd = open("file.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);
    dup2(fd, 1);  // 표준 출력을 file.txt로 리다이렉트
    close(fd);    // 원본 파일 디스크립터는 더 이상 필요 없음
    execve("/bin/ls", args, env);
    ```

2. 추가 모드 출력 리다이렉션 (`>>`)

    예: `echo "Hello" >> log.txt`

    동작 원리:
    1. `>>` 연산자는 파일 끝에 내용을 추가합니다.
    2. 파일을 추가 모드로 엽니다.
    3. `open()` 시스템 콜을 사용하여 file.txt를 엽니다.
    4. `dup2()` 시스템 콜을 사용하여 표준 출력(파일 디스크립터 1)을 file.txt로 리다이렉트합니다.
    5. `echo` 명령어를 실행합니다.

    의사 코드:

    ```c
    int fd = open("log.txt", O_WRONLY | O_CREAT | O_APPEND, 0644);
    dup2(fd, 1);
    close(fd);
    execve("/bin/echo", args, env);
    ```

3. 표준 에러 리다이렉션 (`2>`)

    예: `ls /nonexistent 2> error.log`

    동작 원리:
    1. `2>` 연산자는 표준 에러(파일 디스크립터 2)를 리다이렉트합니다.
    2. 파일을 생성하거나 덮어씁니다.
    3. 표준 에러를 해당 파일로 리다이렉트합니다.

   의사 코드:

    ```c
    int fd = open("error.log", O_WRONLY | O_CREAT | O_TRUNC, 0644);
    dup2(fd, 2);  // 표준 에러를 error.log로 리다이렉트
    close(fd);
    execve("/bin/ls", args, env);
    ```

4. 표준 출력과 표준 에러를 같은 파일로 리다이렉션 (`&>`)

    예: `ls /nonexistent &> output.log`

    동작 원리:
    1. `&>` 연산자는 표준 출력과 표준 에러 모두를 같은 파일로 리다이렉트합니다.
    2. 파일을 생성하거나 덮어씁니다.
    3. 표준 출력과 표준 에러 모두를 해당 파일로 리다이렉트합니다.

    의사 코드:

    ```c
    int fd = open("output.log", O_WRONLY | O_CREAT | O_TRUNC, 0644);
    dup2(fd, 1);  // 표준 출력을 output.log로 리다이렉트
    dup2(fd, 2);  // 표준 에러를 output.log로 리다이렉트
    close(fd);
    execve("/bin/ls", args, env);
    ```

5. 표준 에러를 표준 출력으로 리다이렉션 (`2>&1`)

    예: `ls /nonexistent > output.log 2>&1`

    동작 원리:
    1. 먼저 표준 출력을 파일로 리다이렉트합니다.
    2. 그 다음 표준 에러를 표준 출력으로 리다이렉트합니다.

    의사 코드:

    ```c
    int fd = open("output.log", O_WRONLY | O_CREAT | O_TRUNC, 0644);
    dup2(fd, 1);  // 표준 출력을 output.log로 리다이렉트
    dup2(1, 2);   // 표준 에러를 표준 출력으로 리다이렉트
    close(fd);
    execve("/bin/ls", args, env);
    ```

`dup2()` 시스템 콜의 작동 원리:
- `dup2(oldfd, newfd)`는 `newfd`가 가리키는 파일 디스크립터를 `oldfd`가 가리키는 파일로 변경합니다.
- 만약 `newfd`가 이미 열려있던 파일 디스크립터였다면, 그 파일은 자동으로 닫힙니다.
- 이를 통해 표준 입력(0), 표준 출력(1), 표준 에러(2)와 같은 미리 정의된 파일 디스크립터를 다른 파일로 쉽게 리다이렉트할 수 있습니다.

실제 구현 시 주의사항:
1. 파일 열기 실패, 권한 문제 등의 에러 처리가 필요합니다.
2. 메모리 누수를 방지하기 위해 사용이 끝난 파일 디스크립터는 반드시 닫아야 합니다.
3. 셸은 리다이렉션을 처리한 후에 실제 명령어를 실행해야 합니다.

이러한 메커니즘을 통해 셸은 사용자가 지정한 대로 프로그램의 출력을 유연하게 제어할 수 있습니다. 리다이렉션은 로깅, 디버깅, 데이터 처리 등 다양한 시나리오에서 매우 유용하게 사용됩니다.

### 파이프 처리

a. 파이프 생성:
    - 파이프는 `pipe()` 시스템 콜을 사용하여 생성됩니다.
    - 파이프 자체는 프로세스가 아니라 *커널 수준의 버퍼*입니다.

b. 파이프 연결:
    - 셸은 `|`로 연결된 두 명령어에 대해 각각 프로세스를 생성합니다.
    - 첫 번째 프로세스의 `stdout`을 파이프의 쓰기 끝으로, 두 번째 프로세스의 `stdin`을 파이프의 읽기 끝으로 연결합니다.

c. 데이터 흐름:
    - 첫 번째 프로세스가 파이프에 데이터를 쓰면, 두 번째 프로세스는 이를 읽을 수 있습니다.
    - 이 과정은 커널에 의해 관리되며, 버퍼링과 동기화가 자동으로 처리됩니다.

### 동시 출력과 파일 저장 (tee 명령어의 원리)

- `tee` 명령어는 입력을 받아 이를 stdout으로 출력하면서 동시에 지정된 파일에 씁니다.
- 이는 `read()` 시스템 콜로 입력을 받고, `write()` 시스템 콜을 사용하여 stdout과 파일에 동시에 쓰는 방식으로 구현됩니다.

아래 명령은 "Hello"를 화면에 출력하면서 동시에 file.txt에 저장합니다.

```bash
echo "Hello" | tee file.txt
```

## bash -c 명령어의 작동 방식

- 기본 구문: `bash -c "command"`
- 작동 원리:
    1. 새로운 bash 프로세스가 생성됩니다.
    2. 이 프로세스는 `-c` 다음에 오는 문자열을 명령어로 해석합니다.
    3. 해당 명령어를 실행한 후 종료됩니다.
- 예: `bash -c "echo Hello, World!"`

이 방식은 현재 셸 환경에 영향을 주지 않고 독립적인 환경에서 명령을 실행할 때 유용합니다.

## 파이프(|)

- 기본 구문: `command1 | command2`
- 작동 원리:
    1. `command1`의 표준 출력(stdout)이 `command2`의 표준 입력(stdin)으로 연결됩니다.
    2. 두 명령어는 동시에 실행되며, 데이터는 실시간으로 전달됩니다.
- 예: `echo "Hello" | grep "Hell"`

파이프는 한 프로그램의 출력을 다른 프로그램의 입력으로 직접 전달할 수 있게 해주는 강력한 도구입니다.

## tee 명령어

- 기본 구문: `command | tee file`
- 작동 원리:
    1. 입력 받은 데이터를 파일에 쓰면서 동시에 표준 출력으로 전달합니다.
    2. 이를 통해 데이터를 저장하면서 동시에 화면에 출력할 수 있습니다.
- 예: `echo "Hello" | tee output.txt`

tee는 데이터 스트림을 "분기"시키는 역할을 합니다, 마치 배관의 T자 연결부와 같이 작동합니다.

## 프로세스 치환

- 기본 구문: `command <(another_command)` 또는 `command >(another_command)`
- 작동 원리:
    1. 명령어의 출력이나 입력을 임시 파일처럼 취급합니다.
    2. 실제로는 파이프를 사용하여 데이터를 전달합니다.
- 예: `diff <(ls dir1) <(ls dir2)`

프로세스 치환은 명령어의 출력을 파일처럼 다룰 수 있게 해주어, 파일 입력을 요구하는 명령어와 함께 사용할 수 있게 해줍니다.

이제 이 개념들이 어떻게 함께 작동하는지 예를 들어 설명하겠습니다:

```bash
bash -c "echo 'Hello, World!' | tee >(grep 'Hello' > hello.txt) >(grep 'World' > world.txt)"
```

1. `bash -c`가 새로운 bash 프로세스를 생성하고 뒤따르는 명령을 실행합니다.
2. `echo 'Hello, World!'`가 문자열을 출력합니다.
3. 이 출력은 `tee` 명령으로 파이프됩니다.
4. `tee` 명령은 입력 받은 데이터를 표준 출력(화면)으로 보내면서 동시에 두 개의 프로세스 치환으로 전달합니다:
    - `>(grep 'Hello' > hello.txt)`: 'Hello'를 포함한 줄을 hello.txt에 저장
    - `>(grep 'World' > world.txt)`: 'World'를 포함한 줄을 world.txt에 저장
5. 결과적으로:
    - 'Hello, World!'가 화면에 출력됩니다.
    - 'Hello, World!'가 hello.txt에 저장됩니다.
    - 'Hello, World!'가 world.txt에 저장됩니다.

이 예제는 bash -c, 파이프, tee, 프로세스 치환을 모두 사용하여 하나의 출력을 여러 방식으로 처리하는 방법을 보여줍니다.

이러한 기술들을 이해하고 조합하면, 복잡한 데이터 처리 작업을 효율적으로 수행할 수 있습니다.
예를 들어, 로그 파일을 분석하면서 동시에 여러 패턴을 검색하고, 결과를 다양한 파일에 저장하는 작업을 단일 명령줄에서 수행할 수 있습니다.

이러한 개념들은 유닉스 철학인 "작은 도구들을 조합하여 복잡한 작업을 수행한다"는 원칙을 잘 보여줍니다. 각 도구는 한 가지 일을 잘 수행하도록 설계되었으며, 이들을 조합함으로써 강력하고 유연한 시스템을 구축할 수 있습니다.
