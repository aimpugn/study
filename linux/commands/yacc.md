# yacc

- [yacc](#yacc)
    - [`yacc`란?](#yacc란)
    - [`LR(1) 파서`](#lr1-파서)
    - [`LR(1) 파싱 테이블`](#lr1-파싱-테이블)
    - [Yacc을 사용하는 과정](#yacc을-사용하는-과정)

## `yacc`란?

- **Y**et **A**nother **C**ompiler-**C**ompiler
- Yacc (Yet Another Compiler-Compiler)은 프로그래밍 언어의 파서 생성기
- Yacc은 **프로그래밍 언어의 구문 분석기를 만드는 데 필요한 반복적이고 복잡한 작업을 간소화**한다. 그래서 "컴파일러-컴파일러"라고 불리기도 하는데, Yacc가 컴파일러를 위한 핵심 부분인 **파서를 '컴파일'**하는 데 사용된다는 의미
- 구문 분석기(parser)는 프로그래밍 언어의 컴파일러나 인터프리터에서 중요한 역할을 하는데, 소스 코드를 읽고 그 구조를 이해하여 기계가 실행할 수 있는 형태로 변환하는 작업을 수행한다
- Yacc는 특정 프로그래밍 언어의 문법을 기술하는 데 사용되며, 그 문법을 기반으로 `LR(1) 파싱 테이블`을 생성합니다.

## `LR(1) 파서`

- 프로그래밍 언어의 구문 분석에 사용되는 하향식 파서의 한 종류
- 왼쪽에서 오른쪽으로(Left-to-right) 읽으면서 가장 오른쪽 유도(Rightmost derivation)를 수행하는 파서
- 1은 한 개의 입력 심볼을 미리 보면서 분석하는 Lookahead를 의미합니다. 이러한 파서는 복잡한 문법을 가진 언어도 효율적으로 분석할 수 있는 강력한 기능을 가지고 있습니다.

## `LR(1) 파싱 테이블`

- `LR(1) 파싱 테이블`은 `LR(1) 파서`가 소스 코드를 구문 분석할 때 사용하는 데이터 구조
- 이 테이블은 파서가 입력 토큰을 어떻게 처리할지 결정하는 데 필요한 정보를 포함한다
- 컴파일러 또는 인터프리터가 구문 분석 과정에서 현재의 상태와 입력 토큰을 기반으로 어떤 동작을 취할지를 결정하는 데 중요한 역할을 한다.
- `LR(1) 파서`는
    1. 구문 분석 트리를 만들어내거나,
    2. 직접적으로 중간 코드를 생성하거나,
    3. 다른 변환 작업을 수행할 수 있다
- LR(1) 파싱 테이블은 주로 두 가지 주요 구성 요소로 이루어져 있다:
    1. 상태(State): 각 상태는 파싱 과정 중의 특정 지점을 나타냅니다. 파서는 이 상태들을 사용하여 어떤 규칙에 따라 입력을 처리할지를 알 수 있습니다.
    2. 동작(Action)과 이동(Goto):
        - 동작 테이블(Action Table): 이 테이블은 현재 상태와 다음 입력 토큰에 따라 파서가 취해야 할 동작을 나타냅니다. 동작에는:
            - `Shift` (다음 토큰을 쉬프트하여 파싱 스택에 넣음),
            - `Reduce` (특정 규칙에 따라 스택의 아이템들을 줄여나감),
            - `Accept` (파싱을 성공적으로 마침),
            - 또는 `Error` (오류 발생)
        - 이동 테이블(Goto Table):
            - `Reduce` 동작 후에, 파서는 이동 테이블을 참조하여 다음에 어떤 상태로 이동할지 결정
            - 이 테이블은 `Reduce` 동작이 발생한 후 파서가 이동해야 할 새로운 상태를 나타낸다
예를 들어,
- ex1: 파서가 현재 상태 `S1`에 있고 다음 입력 토큰이 `+`라면, 파싱 테이블은 `Shift S2`와 같은 동작을 지시할 수 있다. 이는 파서가 토큰 `+`를 받아들이고 상태 `S2`로 이동하라는 의미한다.
- ex2: 반면, 파서가 상태 `S3`에 있고 입력이 규칙 `E → E + E`를 만족시킨다면, 파싱 테이블은 `Reduce` 동작을 지시하여 파싱 스택의 아이템들을 줄이라고 할 수 있다

## Yacc을 사용하는 과정

1. 문법 정의
    - 개발자는 Yacc을 사용하여 문법 규칙을 정의
    - 이 규칙들은 `Yacc` 파일에 `BNF`(Backus-Naur Form) 또는 `EBNF`(Extended Backus-Naur Form)와 같은 형식으로 작성
2. 우선순위와 결합 규칙
    - 문법이 모호할 수 있기 때문에, 우선순위(priority)와 결합 규칙(associativity rules)을 정의하여 이 모호성을 해결
    - 예를 들어, 연산자의 우선순위를 정의할 수 있다
3. 변환 코드
    - 문법 규칙과 함께 변환 코드(translation code)를 포함시킬 수 있다
    - 이 코드는 파싱 중에 실행되며, 구문 분석 트리를 생성하거나 중간 코드를 생성하는 데 사용된다
4. 파서 생성
    - Yacc은 이 정보를 바탕으로 LR(1) 파서를 위한 테이블을 생성
    - 생성된 테이블은 소스 코드를 구문 분석하는 데 사용된다
5. 사용
    - 생성된 테이블과 파서는 컴파일러나 인터프리터에 통합되어 실제 소스 코드를 분석하고 실행 가능한 코드를 생성하는 데 사용된다
